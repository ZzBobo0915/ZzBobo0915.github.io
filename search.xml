<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BlendMask笔记</title>
    <url>/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="实例分割算法BlendMask"><a href="#实例分割算法BlendMask" class="headerlink" title="实例分割算法BlendMask"></a>实例分割算法BlendMask</h1><p>论文地址：<a href="https://arxiv.org/abs/2001.00309">https://arxiv.org/abs/2001.00309</a></p>
<p>github代码：<a href="https://github.com/aim-uofa/AdelaiDet">https://github.com/aim-uofa/AdelaiDet</a></p>
<h2 id="密集实例分割"><a href="#密集实例分割" class="headerlink" title="密集实例分割"></a>密集实例分割</h2><p>​    密集实例分割主要分为自上而下top-down与自下而上bottom-up两类方法：</p>
<h3 id="Top-down方法"><a href="#Top-down方法" class="headerlink" title="Top-down方法"></a>Top-down方法</h3><p>​    top-down方法主要表现为先检测后分割，先通过一些方法获得box区域，然后对区域内的像素进行mask提取，比如著名的Mask-RCNN就是top-down方法。</p>
<p>​    这种模型一般有以下问题：</p>
<ol>
<li>特征和mask之间的局部一致性会丢失</li>
<li>冗余的特征提取，不同的bbox会重新提取一次mask</li>
<li>由于使用了缩小的特征图卷积，位置信息会损失</li>
</ol>
<h3 id="Bottom-up方法"><a href="#Bottom-up方法" class="headerlink" title="Bottom-up方法"></a>Bottom-up方法</h3><p>​    bottom-up方法将整个图进行逐像素的预测（per-pixel prediction），然后按照聚类等方法，对每个像素做embedding，最后group出不同的instance。虽然保留个更好的低层特征，但是效果一般略差于top-down方法。</p>
<p>​    这种模型一般存在以下问题：</p>
<ol>
<li>严重依赖逐像素预测的质量，容易导致非最优的分割</li>
<li>由于mask在低维度提取，对于复杂场景的分割能力有限</li>
<li>需要复杂的后处理方法</li>
</ol>
<h3 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h3><p>​    BlendMask主要结合了top-down与botton-up两种思路，利用t-d方法生成实例级别的高维信息（如bbox），利用b-u方法生成per-pixel的预测进行融合。基于FCOS，融合的方法借鉴FCIS（裁剪）与YOLACT（权重加法）的思想，提出了blender模块，更好的将实例级别的全局信息与提供细节的底层特征融合。</p>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422102619797.png" class="" title="BlendMask整体架构">

<p>   整体架构如上图所示，包含一个detector模块与BlendMask模块。detector模块直接采用的FCOS，BlendMask模块分为三部分：</p>
<ul>
<li>Bottom Module：对底层特征进行处理，生成的score map称为Bases</li>
<li>Top Layer：串联在检测器的box head上，生成Base对应的top level attention</li>
<li>Blender：将Bases与attention融合</li>
</ul>
<h3 id="Bottom-Module"><a href="#Bottom-Module" class="headerlink" title="Bottom Module"></a>Bottom Module</h3><p>​    采用Deelpabv3+的decoder，包含两个输入，一个低层特征一个高层特征，对高层特征进行上采用后与低层特征融合输出，</p>
<img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422103608570.png" class="" title="Deeplabv3+结构">

<p>​    bottom输出的feature特征为：(N * K * H&#x2F;s * W&#x2F;s)，N为channel，K为bases的数量，(H,W)为输入的size，s为scroe的步长。</p>
<h3 id="Top-Layer"><a href="#Top-Layer" class="headerlink" title="Top Layer"></a>Top Layer</h3><p>​    在检测的特征金字塔的每一层后都加了一层卷积，用来预测top-level attentions(A)，输出的特征为：(N * (K*M*M)) * H_i * W_i)，M*M为attention的分辨率，即对应的base的每个像素点的权重值，包含的粒度更细。</p>
<h3 id="Blender"><a href="#Blender" class="headerlink" title="Blender"></a>Blender</h3><p>​    Blender的输入为bottom的输出B、top-level的输出attentions(A)和bbox(P)，该部分的融合如下：</p>
<ol>
<li>使用RoiPooler来裁取每个bbox对应的区域，并resize成固定的RxR大小的特征图。训练时直接使用ground truth bbox作为propasals，而在推理时直接用FCOS的结果<img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422104735998.png" class="" title="RoIPool"></li>
<li>attention的大小M是比R小的，因此需要插值，这里采用的双线性插值，从MxM变为RxR<img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422105051459.png" class="" title="attention上采样"></li>
<li>接着插值完的attention进行softmax，产生一组score map<img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422105309801.png" class="" title="attention的score map"></li>
<li>对每个r_d和对应的s_d进行逐像素的相加，最后将K个结果相加得到m_d<img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422105357473.png" class=""></li>
</ol>
<p>​    可视化的blender过程：</p>
<img src="/2023/04/22/BlendMask%E7%AC%94%E8%AE%B0/image-20230422105439280.png" class="" title="可视化过程">
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>实例分割</tag>
      </tags>
  </entry>
  <entry>
    <title>FCOS笔记</title>
    <url>/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="FCOS笔记"><a href="#FCOS笔记" class="headerlink" title="FCOS笔记"></a>FCOS笔记</h1><h2 id="1-FCOS基本"><a href="#1-FCOS基本" class="headerlink" title="1.FCOS基本"></a>1.FCOS基本</h2><p>《FCOS: A Simple and Strong Anchor-free Object Detector》</p>
<p>FCOS 第二篇paper地址：<a href="https://arxiv.org/pdf/1904.01355.pdf">https://arxiv.org/pdf/1904.01355.pdf</a></p>
<p>FCOS 第二篇paper地址：<a href="https://arxiv.org/pdf/2006.09214.pdf">https://arxiv.org/pdf/2006.09214.pdf</a></p>
<p>FCOS code地址：<a href="https://github.com/tianzhi0549/FCOS">https://github.com/tianzhi0549/FCOS</a></p>
<h3 id="1-1-核心概念"><a href="#1-1-核心概念" class="headerlink" title="1.1 核心概念"></a>1.1 核心概念</h3><p>​    将锚框转换为铺设锚点进行物体检测。</p>
<p>​    FCOS是基于无锚框（Anchor-Free）的目标检测方法，是指将锚框（Anchor-Based）中的对锚框分类与回归转变为：对锚点进行分类与回归，其中回归是预测这个锚点到检测框上下左右四条边界的距离。</p>
<h3 id="1-2-Anchor-Based的缺点"><a href="#1-2-Anchor-Based的缺点" class="headerlink" title="1.2 Anchor-Based的缺点"></a>1.2 Anchor-Based的缺点</h3><ul>
<li>Anchor-Based对检测框anchor的大小、数量、长款都比较敏感</li>
<li>固定尺寸size和纵横比aspext ratio的锚框不利于检测器的泛化能力，导致对不同任务，anchor可能需要重新设置大小和尺寸</li>
<li>为了达到更好的效果，需要生成很多的anchor，但是大部分anchor都为负样本，造成了样本的不均衡</li>
<li>在训练中，需要计算所有anchor与真实框的IOU，消耗大量资源内存资源与时间</li>
</ul>
<h3 id="1-3-FCOS优点"><a href="#1-3-FCOS优点" class="headerlink" title="1.3 FCOS优点"></a>1.3 FCOS优点</h3><ul>
<li>检测问题完全交给FCN去处理，可以复用到其他任务上，比如语义分割、关键点检测</li>
<li>anchor-free方法减少了参数的设计，使训练更简单</li>
<li>不需要计算IOU，节省资源</li>
</ul>
<h2 id="2-FCOS网络结构"><a href="#2-FCOS网络结构" class="headerlink" title="2.FCOS网络结构"></a>2.FCOS网络结构</h2><h3 id="2-1-原始的FCOS"><a href="#2-1-原始的FCOS" class="headerlink" title="2.1 原始的FCOS"></a>2.1 原始的FCOS</h3><img src="/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/fcos_structure-16820799089041.png" class="" title="FCOS Structure">

<p>​    初始的FCOS网络如上图所示，C3、C4、C5代表了骨干网络的特征映射，P3-P7为最终预测所使用的特征层，hw为特征图的高和宽，最左侧为下采样比例。</p>
<p>​    然后将P3-P7输入检测头，每个检测头head包含以下三个分支：</p>
<ul>
<li>Classification分支：预测类别分支，预测类别，图中的C即表示类别</li>
<li>Center-ness分支：中心度分支，一个锚点对应一个中心都，用于锚点相对检测框中心的判断</li>
<li>Regression分支：回归位置分支，用来回归正样本锚点到检测框的距离，图中的4表示<code>l t r b</code>即上下左右四条边界</li>
</ul>
<p>​    改进前Classification分支既包含了正、负样本锚点的类别预测分支，又包含了正、负样本锚点中心性判断的center-ness分支。</p>
<h3 id="2-2-改进的FCOS"><a href="#2-2-改进的FCOS" class="headerlink" title="2.2 改进的FCOS"></a>2.2 改进的FCOS</h3><p>​    后来发现Center-ness分支与Regression分支放在一起更好，所以就将这二者放在了一起：</p>
<p>​    下图引自我的b站导师：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_37541097/article/details/124844726?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165884537116782246451205%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165884537116782246451205&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-124844726-null-null.185%5Ev2%5Econtrol&utm_term=fpn&spm=1018.2226.3001.4450">FCOS网络解析_太阳花的小绿豆的博客-CSDN博客_fcos网络</a></p>
<img src="/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/fcos_structure_gai-16820799089052.png" class="" title="改进的FCOS Structure">

<h3 id="2-3-损失函数"><a href="#2-3-损失函数" class="headerlink" title="2.3 损失函数"></a>2.3 损失函数</h3><p>​    以改进版的损失函数为例，Head总共有三个输出分支，故损失由分类损失 L_cls、定位损失 L_rcs与center-ness损失 L_ctrness三部分组成 ：</p>
<img src="/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/fcos_loss-16820799089053.png" class="" title="FCOS损失函数">

<p>   其中：</p>
<img src="/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/fcos_loss_expr-16820799089054.png" class="" title="参数详解">

<ul>
<li><p>分类损失L_cls采用 BCE Loss+Focal Loss，计算损失时所有样本都会参与</p>
</li>
<li><p>定位损失L_rcs次啊用GIoU Loss（即现在的IoU Loss），计算损失时只有正样本参与</p>
</li>
<li><p>center-ness损失L_ctrness采用BCE Loss，计算损失时只有正样本参与，s*x,y的计算公式如下：<img src="/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/centerness-16820799089055.png" class="" title="center-ness损失"></p>
<p>  center-ness距离GT（ground truth框，即人工标注的真实样本框）中心点越近，centerness*值越大，反之越小。在推理时，center-ness还可以类别权重，在NMS（非极大值抑制）中，其排序所用的置信度由center-ness与类别概率（类别得分）得到</p>
</li>
</ul>
<h2 id="3-正样本、负样本、模糊样本的定义"><a href="#3-正样本、负样本、模糊样本的定义" class="headerlink" title="3.正样本、负样本、模糊样本的定义"></a>3.正样本、负样本、模糊样本的定义</h2><h3 id="3-1-正样本、负样本"><a href="#3-1-正样本、负样本" class="headerlink" title="3.1 正样本、负样本"></a>3.1 正样本、负样本</h3><p>​    有目标的就是正样本、没有目标的就是负样本。</p>
<p>​    对于anchor-free来说，锚点落在了特征图上的GT框内，他就是正样本，否则就是负样本。</p>
<h3 id="3-2-模糊样本"><a href="#3-2-模糊样本" class="headerlink" title="3.2 模糊样本"></a>3.2 模糊样本</h3><p>​    FCOS里的模糊样本指的是那些锚点落在多个GT框的样本，一般取最小的GT框作为回归目标。</p>
<h2 id="4-特征图上的点映回原图"><a href="#4-特征图上的点映回原图" class="headerlink" title="4.特征图上的点映回原图"></a>4.特征图上的点映回原图</h2><p>​    为了知道特征图上的点在原图的位置，我们需要上采样，根据总体的stride来定义上采样倍率</p>
<h2 id="5-锚点回归值"><a href="#5-锚点回归值" class="headerlink" title="5.锚点回归值"></a>5.锚点回归值</h2><p>​    锚点回归的回归计算公式如下所示，其中(l∗,t∗,r∗,b∗)是锚点距离物体的真实标注框左、上、右、下边界的距离，(x,y)为特征图上锚点映射到原图上的位置；在回归分支中，每个锚点预测一个四维向量，即四条边界，网络能把每个锚点距离真实标准框的距离预测的越准，说明检测效果越好：</p>
<img src="/2023/04/21/FCOS%E7%AC%94%E8%AE%B0/regression-16820799089056.png" class="">

<h2 id="6-模糊样本的处理"><a href="#6-模糊样本的处理" class="headerlink" title="6.模糊样本的处理"></a>6.模糊样本的处理</h2><p>​    采用FPN时会将大小不同的anchor放置在不同大小的特征图上，特征图越小，感受野越大，用来检测更大的物体，FCOS采用5个不同大小的特征图P3-P7(P_i)，stride对应8,16,32,64,128。</p>
<p>​    在anchor-based中，根据anchor与GT框的IoU来匹配，而FCOS直接通过限制不同特征图上的回归目标值来达到这一目的，每个特征图P都会设定一个回归下限值与回归上限值，作为其回归距离的限制。如果特征图上P_i的坐标点(x,y)满足小于下限或大于上限，这个特征层就将其设置为负样本，不再进行回归。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://blog.csdn.net/weixin_45377629/article/details/124844405">https://blog.csdn.net/weixin_45377629/article/details/124844405</a></li>
<li><a href="https://blog.csdn.net/weixin_44135282/article/details/89703818">https://blog.csdn.net/weixin_44135282/article/details/89703818</a></li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>STL知识点</title>
    <url>/2023/04/20/STL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="STL知识点"><a href="#STL知识点" class="headerlink" title="STL知识点"></a>STL知识点</h2><h3 id="STL序列式容器有哪些？"><a href="#STL序列式容器有哪些？" class="headerlink" title="STL序列式容器有哪些？"></a>STL序列式容器有哪些？</h3><ul>
<li>array</li>
<li>vector</li>
<li>list</li>
<li>deque</li>
<li>forward_list</li>
</ul>
<h3 id="array底层原理"><a href="#array底层原理" class="headerlink" title="array底层原理"></a>array底层原理</h3><p>​    array本质就是一个<strong>大小固定的数组</strong>，无法动态改变，只允许访问或替换数组中的元素。</p>
<h3 id="vector底层原理"><a href="#vector底层原理" class="headerlink" title="vector底层原理"></a>vector底层原理</h3><p>​    vector底层是一个<strong>动态数组</strong>，包含三个迭代器，start, finish, end_of_storage；当数组空间装不下时，会自动申请另一篇更大的空间（1.5倍或2倍），把原来的数据拷贝带新的内存空间，然后释放原来的那片空间。</p>
<p>​    vector调用clear()函数只是清空了里面的数据，其存储空间不释放。</p>
<h3 id="vector中reserver与resize"><a href="#vector中reserver与resize" class="headerlink" title="vector中reserver与resize"></a>vector中reserver与resize</h3><p>​    vector中reverse()是直接扩充到确定的大小下，可以减少多次开辟、释放空间的问题；resize()可以改变有效空间的大小，也有改变默认值的功能。</p>
<h3 id="vector中size与capacity"><a href="#vector中size与capacity" class="headerlink" title="vector中size与capacity"></a>vector中size与capacity</h3><p>​    vector中size表示当前有多少元素，capacity表示当前分配的内存能容纳多少元素。</p>
<h3 id="如何正确释放vector内存"><a href="#如何正确释放vector内存" class="headerlink" title="如何正确释放vector内存"></a>如何正确释放vector内存</h3><ul>
<li>vec.clear(); vec.shrink_to_fit();  清空内容并且释放内存</li>
<li>vector(Vec).swap(Vec); 清除内存</li>
<li>vector().swap(Vec); 清除内存</li>
</ul>
<h3 id="list底层原理"><a href="#list底层原理" class="headerlink" title="list底层原理"></a>list底层原理</h3><p>​    list底层是一个<strong>双向链表</strong>，以节点为单位存储数据，节点的地址在内存中不一定连续，每次插入或者删除一个元素，就配置或释放一个元素空间。</p>
<p>​    list不支持随机存取，适合需要大量的插入和删除，而不关心随机存取的应用场景。</p>
<h3 id="deque底层原理"><a href="#deque底层原理" class="headerlink" title="deque底层原理"></a>deque底层原理</h3><p>​    deque底层是一个<strong>双向开口的线性连续空间（双端队列</strong>），在头部和尾部插入、删除元素有理想的复杂度；并且deque也不保证存储元素所有元素都存储在连续的空间内。</p>
<h3 id="vector、list与deque都适用于什么情况？"><a href="#vector、list与deque都适用于什么情况？" class="headerlink" title="vector、list与deque都适用于什么情况？"></a>vector、list与deque都适用于什么情况？</h3><p>​    vector可以随机存储元素，不需要挨个查找，适合随机存取的场景使用，除非必要情况尽量都使用vecter而非deque；</p>
<p>​    list适用于对象大、对象数量频繁变化，插入和删除频繁的场景；</p>
<p>​    deque适合在头尾两端进行操作的场景。</p>
<h3 id="forwrad-list底层原理"><a href="#forwrad-list底层原理" class="headerlink" title="forwrad_list底层原理"></a>forwrad_list底层原理</h3><p>​    froward_list和list差不多，只不过他是一个<strong>单向链表</strong>，节点的地址在内存中不一定连续。</p>
<h3 id="STL关联容容器是什么？有哪些？"><a href="#STL关联容容器是什么？有哪些？" class="headerlink" title="STL关联容容器是什么？有哪些？"></a>STL关联容容器是什么？有哪些？</h3><p>​    关联式容器是指存储元素是会为元素配备一个键Key，整体以键值对的方式存储在容器中；另外，关联式容器在存储元素时会根据元素的大小进行排序(less&lt;T&gt;, greater&lt;T&gt;)。</p>
<ul>
<li>map</li>
<li>multimap</li>
<li>set</li>
<li>multiset</li>
</ul>
<h3 id="上述几个关联式容器的的底层原理是什么？"><a href="#上述几个关联式容器的的底层原理是什么？" class="headerlink" title="上述几个关联式容器的的底层原理是什么？"></a>上述几个关联式容器的的底层原理是什么？</h3><p>​    关联式容器的底层都是根据<strong>红黑树</strong>实现的，epoll模型的低层也是红黑树。红黑树具有以下特点：</p>
<ol>
<li>是一个棵平衡二叉树</li>
<li>节点分为两种颜色：红色和黑色</li>
<li>根节点和叶子节点为黑色</li>
<li>红色结点的子节点必须是黑色节点</li>
<li>根节点到任意一个叶子节点的路径上黑色节点个数相同</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>​    map容器存储的都是pair对象（键值对），默认情况下会自定根据键的大小按照升序排序std::less&lt;T&gt;。map中存储的键不能重复也不能被修改（注意是键不能修改！值可以）。</p>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>​    multimap与map一样按照键值对存储，不相同的是multimap可以存入多个相同键的键值对。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>​    与两个map容器不同，使用set容器存储的各个键值对的key和value都相等。set还要求存储的键不能重复，并且默认情况下也会根据键的大小按升序排序。</p>
<h3 id="multeset"><a href="#multeset" class="headerlink" title="multeset"></a>multeset</h3><p>​     multiset与set一样按照键值对存储key和value都相等，不同的是multiset可以存入多个相同的键值对。</p>
<h3 id="map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？"><a href="#map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？" class="headerlink" title="map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？"></a>map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？</h3><p>​    map和set的插入删除速度都是logN。</p>
<p>​    由于红黑树存储的是节点，不需要内存拷贝和内存移动，插入和删除操作也只是将节点的指针换来换去，节点内存没有改变。</p>
<h3 id="为何map和set不能像vector一样有个reserve函数来预分配数据"><a href="#为何map和set不能像vector一样有个reserve函数来预分配数据" class="headerlink" title="为何map和set不能像vector一样有个reserve函数来预分配数据?"></a>为何map和set不能像vector一样有个reserve函数来预分配数据?</h3><p>​    因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map&lt;Key, Data, Compare, Alloc&gt;声明的时候从参数中传入的Alloc。</p>
<h3 id="map的插入方式有几种？"><a href="#map的插入方式有几种？" class="headerlink" title="map的插入方式有几种？"></a>map的插入方式有几种？</h3><ul>
<li>用insert插入pair数据 <code>mapM.insert(pair&lt;char, int&gt;(&#39;a&#39;, 1));</code></li>
<li>用insert插入value_type数据 <code>mapM.insert(map&lt;char, int&gt;::value_type(&#39;a&#39;, 1));</code></li>
<li>在insert函数中使用make_pair()函数 <code>mapM.insert(make_pair(&#39;a&#39;, 1));</code></li>
<li>用数组下标方式插入 <code>mapM[&#39;a&#39;] = 1;</code></li>
</ul>
<h3 id="STL无序式关联容器有哪些？"><a href="#STL无序式关联容器有哪些？" class="headerlink" title="STL无序式关联容器有哪些？"></a>STL无序式关联容器有哪些？</h3><p>​    无序式关联容器，又称哈希容器，采用的存储结构为哈希表。<strong>哈希表可以根据关键字直接找到数据的存储位置，不需要进行任何比较，大大降低数据查找和存储消耗的时间，但是需要比较多的内存。</strong></p>
<ul>
<li>unordered_map</li>
<li>unordered_set    </li>
<li>unordered_multimap</li>
<li>unordered_multiset</li>
</ul>
<h3 id="unordered-map底层原理、unordered-set底层原理"><a href="#unordered-map底层原理、unordered-set底层原理" class="headerlink" title="unordered_map底层原理、unordered_set底层原理"></a>unordered_map底层原理、unordered_set底层原理</h3><p>​    unordered_map的底层是一个防冗余的哈希表（采用除留余数法），还是采用键值对的方式存储，键值对互不相等并且不会对存储内容进行排序。</p>
<p> unordered_set低层也是一个防冗余的哈希表，不以键值对存储，直接存储数据的值，元素值互不相同并且不会对内容进行排序。</p>
<p>​    使用一个下标范围较大的数组来存储元素，设计一个哈希函数(散列函数)，使得每一个元素的key都与一个函数值(数组下表，hash值)相对应，用这个数组单元来存储这个元素，这个数组单元也被成为桶。</p>
<p>​    对于不同元素计算出相同哈希值(即发生冲突)的时候，一般采用开链法解决冲突。</p>
<h3 id="STL的容器适配器有哪些？"><a href="#STL的容器适配器有哪些？" class="headerlink" title="STL的容器适配器有哪些？"></a>STL的容器适配器有哪些？</h3><p>​    容器适配器是一个封装了序列容器的模板。</p>
<ul>
<li>stack</li>
<li>queue</li>
<li>priority_queue</li>
</ul>
<h3 id="stack底层原理"><a href="#stack底层原理" class="headerlink" title="stack底层原理"></a>stack底层原理</h3><p>​    stack适配器是一个<strong>单端开口的容器</strong>，模拟栈存储结构，无论存数据还是读数据，都只能从这个一个开口操作。满足后进先出LIFO准则。</p>
<h3 id="queue底层原理"><a href="#queue底层原理" class="headerlink" title="queue底层原理"></a>queue底层原理</h3><p>​    queue适配器有<strong>两个开口的容器，一个专门输入数据，一个专门输出数据</strong>，模拟单向队列存储结构。满足先入先出FIFO准则。</p>
<h3 id="priority-queue底层原理"><a href="#priority-queue底层原理" class="headerlink" title="priority_queue底层原理"></a>priority_queue底层原理</h3><p>​    priority_queue适配器模拟的也是队列这种存储结构，只能一端进，另一段出，且每次访问只能访问队头元素，本质是一个堆，又被称为优先队列(最大堆&#x2F;最小堆)，队头元素永远都是优先级最大的元素。可以在创建优先队列对象时指明是最大堆less&lt;T&gt;还是最小堆greater&lt;T&gt;，这里less与greater与其他容器不同，priority_queue默认最大堆。</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建自己的网站</title>
    <url>/2023/04/20/hexo%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>  <strong>Hexo是一个快读、简洁高效的博客框架，使用Markdown解析文章</strong></p>
<h3 id="1-在安装hexo前我们必须要安装Node和Git：-有的就直接第2步"><a href="#1-在安装hexo前我们必须要安装Node和Git：-有的就直接第2步" class="headerlink" title="1.在安装hexo前我们必须要安装Node和Git：(有的就直接第2步)"></a>1.在安装hexo前我们必须要安装Node和Git：(有的就直接第2步)</h3><ul>
<li><p>Git官方下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p>
<p>  下载完在cmd输入 <code>git --version</code> 查看Git版本并确认是否安装成功 </p>
<p>  （若未出现可能是环境变量未配置，去环境变量配置一下就行）</p>
</li>
<li><p>Node.js官网下载地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p>
<p>  下载完在cmd输入 <code>node -v</code> 查看Node版本并确认是否安装成功</p>
</li>
</ul>
<h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h2><p><code>npm install -g hexo-cli</code></p>
<h2 id="3-配置github"><a href="#3-配置github" class="headerlink" title="3.配置github"></a>3.配置github</h2><h3 id="3-1创建github仓库"><a href="#3-1创建github仓库" class="headerlink" title="3.1创建github仓库"></a>3.1创建github仓库</h3><p>首先你需要创建一个github账户（略）</p>
<p>  创建完账户需要新建一个名为: <code>username.github.io</code>的仓库， <code>username</code>为你的github用户名，并且这个仓库有且只能有唯一一个，这样就可以通过访问 <code>https://username.github.io</code>来访问你的仓库。</p>
<h3 id="3-2配置SSH免密登录"><a href="#3-2配置SSH免密登录" class="headerlink" title="3.2配置SSH免密登录"></a>3.2配置SSH免密登录</h3><ol>
<li>首先打开首先打开电脑文件夹，找到 C:\Users\你的用户名\ .ssh文件夹并删除(如果没有，则直接进入第二步)</li>
<li>在 C:\Users\你的用户名 文件夹下右键打开 Git Bash Here 输入命令: <code>ssh-keygen -t rsa -C &quot;你的github登录邮箱&quot;</code> 生成.ssh秘钥，输入后连敲三次回车，出一个框里面一堆字符情况代表成功</li>
<li>生成了一个新的 C:\Users\你的用户名\ .ssh文件夹，打开这个文件夹，找到 .ssh\id_rsa.pub 文件，记事本打开并复制里面的内容</li>
<li>打开您的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title 随便填，保存即可，我们的公钥就添加成功了</li>
<li>输入命令: <code>ssh -T git@github.com</code>，会给你返回以下内容：<code>Hi 你的Github username!You&#39;ve successfully authenticated, but GitHub does not provide shell access.   </code>说明配置成功</li>
</ol>
<p>此外你还需要配置以下内容</p>
<p><code>git config --global user.name &quot;你的 Github username&quot;</code>  你的github的username</p>
<p><code>git config --global user.email &quot;xxx@qq.com&quot;</code>  你的github邮箱</p>
<h2 id="4-使用Hexo搭建博客"><a href="#4-使用Hexo搭建博客" class="headerlink" title="4.使用Hexo搭建博客"></a>4.使用Hexo搭建博客</h2><h3 id="4-1进行hexo初始化"><a href="#4-1进行hexo初始化" class="headerlink" title="4.1进行hexo初始化"></a>4.1进行hexo初始化</h3><ol>
<li>在电脑的某个磁盘或路径创建一个文件夹（名字随便取），我这里取得是D:\blog，由于这个文件夹作为将来存放代码的地方，所以一定要好好记住。</li>
<li>打开这个文件夹，在文件夹右键打开GIt Base Here，如果没有就在显示更多选项中寻找，输入命令 <code>hexo init</code> 进行初始化：hexo会下载一些文件和文件夹</li>
<li>在D:\blog这个文件夹中执行 <code>hexo g</code> 会在public文件夹下生相关的html文件</li>
<li>在D:\blog这个文件夹中执行 <code>hexo s</code> 会开启本地预览，打开浏览器访问<a href="http://localhost:4000即可看到博客内容">http://localhost:4000即可看到博客内容</a></li>
</ol>
<h3 id="4-2部署至github"><a href="#4-2部署至github" class="headerlink" title="4.2部署至github"></a>4.2部署至github</h3><ol>
<li><p>还在D:\blog这个文件夹中，执行<code>npm install hexo-deployer-git --save</code>命令</p>
</li>
<li><p>编辑D:\blog中的<code>_config.yml</code>文件，在文件末尾处添加以下内容</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repository:</span> <span class="string">git@github.com:ZzBobo0915/ZzBobo0915.github.io.git</span></span><br><span class="line">   <span class="attr">brance:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<p> 其中<code>repository</code>中的内容是你的github项目的SSH链接地址</p>
</li>
<li><p>在D:\blog这个文件夹中，执行<code>hexo d</code>将本地项目推送到github远程仓库，有可能要需要输入用户名和密码</p>
<p> 推送成功后，即可通过仓库名<code>zzbobo0915.github.io/</code>访问个人博客了</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>暑期实习知识点总结</title>
    <url>/2023/04/20/knowledge-summarize/</url>
    <content><![CDATA[<h1 id="暑期实习知识点总结"><a href="#暑期实习知识点总结" class="headerlink" title="暑期实习知识点总结"></a>暑期实习知识点总结</h1><p>对准备暑期实习的过程中遇到的问题与八股文进行了总结（不定期更新），主要内容包括c&#x2F;c++基本知识点、stl基础、网络编程、计算机网络、数据库等，有错误的地方请指出并多包涵！</p>
<span id="more"></span>

<h2 id="c-x2F-c-基础知识点"><a href="#c-x2F-c-基础知识点" class="headerlink" title="c&#x2F;c++基础知识点"></a>c&#x2F;c++基础知识点</h2><h3 id="c-x2F-c-代码到可执行二进制文件的过程："><a href="#c-x2F-c-代码到可执行二进制文件的过程：" class="headerlink" title="c&#x2F;c++代码到可执行二进制文件的过程："></a>c&#x2F;c++代码到可执行二进制文件的过程：</h3><ul>
<li>预编译：展开所有头文件、宏置换、去掉注释、条件编译、添加行号和文件名标识；得到一个 <code>.i</code> 的文件  </li>
<li>编译：进行词法、语法、语义分析，代码优化等；使用g++或gcc编译预处理过的 <code>.i</code> 文件，得到一个 <code>.s</code> 文件</li>
<li>汇编：将代码 <code>.s</code> 汇编成机器指令 <code>.o</code> 文件</li>
<li>链接：将不同<code>.o</code> 文件与静态库或动态库进行链接，形成可执行程序 <code>.exe</code></li>
</ul>
<h3 id="硬链接、软链接"><a href="#硬链接、软链接" class="headerlink" title="硬链接、软链接"></a>硬链接、软链接</h3><p>​    <code>ln [选项] 源文件 目标文件</code> 创建链接，选项中是 <code>-s</code> 就是创建软连接，否则就是硬链接</p>
<ul>
<li>硬链接：实际上是文件的一个别名，只能引用同一系统中的文件，他引用的是文件的inode，当移动或删除原文件时，硬链接不会被破坏；硬链接不允许链接目录文件。</li>
<li>软链接：又叫符号链接，和原文件不是一个文件，类似windows的快捷方式；如果原始文件被删除，所有指向他的符号链接也就被破坏，有自己的inode；可以跨越文件系统链接，也可以为目录建立链接。</li>
</ul>
<h3 id="动态库与静态库"><a href="#动态库与静态库" class="headerlink" title="动态库与静态库"></a>动态库与静态库</h3><p>​    库文件的命名一般都是 <code>libxxx.so  libxxx.a</code> ，真实名字一般都是去掉 <code>lib</code> 与 <code>.a-  .so-</code>后缀剩下的名字。</p>
<ul>
<li>静态库：编译时，把库文件的代码全部加入到可执行文件中，因此生成的文件较大，但在运行时就不再需要库文件了，后缀名一般为 <code>.a</code></li>
<li>动态库：在编译连接时并没有把库文件代码加入可执行文件中，而是在程序执行时由运行时链接文件加载库文件加载库，这样可以节省系统的开销，后缀名一般为 <code>.so</code></li>
</ul>
<h3 id="gdb常用指令"><a href="#gdb常用指令" class="headerlink" title="gdb常用指令"></a>gdb常用指令</h3><ul>
<li><code>gdb xxx</code> 执行xxx可执行文件</li>
<li><code>l</code> list 默认显示10行代码，回车继续10行</li>
<li><code>b 10</code> break 在10行打断点</li>
<li><code>r</code> run 开始运行，直到断点</li>
<li><code>n</code> next 执行当前语句，如果为函数调用，不会进入函数</li>
<li><code>s</code> step 执行当前语句，如果为函数调用，进入函数执行第一条语句</li>
<li><code>p name</code> print 显示变量名name的值</li>
<li><code>c</code> continue 继续运行，直到断点</li>
<li><code>set var name=&quot;zhuzhibo&quot;</code>  改变变量值</li>
</ul>
<h3 id="static关键字有什么用？"><a href="#static关键字有什么用？" class="headerlink" title="static关键字有什么用？"></a>static关键字有什么用？</h3><ul>
<li>修饰局部变量，使得在静态存储区分配内存，编译时赋初值且只能赋值一次，作用域依旧是局部作用域，但是函数结束后依然存在，只不过不能被其他函数调用</li>
<li>修饰全局变量，使得该变量在静态存储区分配存储，在整个文件中可见</li>
<li>修饰函数，在整个文件中可见，可以避免多人协作时避免同名函数的冲突</li>
<li>静态成员变量：c++才有</li>
<li>静态成员函数：c++才有</li>
</ul>
<h3 id="什么是静态成员变量？"><a href="#什么是静态成员变量？" class="headerlink" title="什么是静态成员变量？"></a>什么是静态成员变量？</h3><p>​    将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区</p>
<ul>
<li><p>静态成员变量</p>
</li>
<li><p>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。</p>
<p>  无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。</p>
<p>  非静态成员类外不能初始化。</p>
<p>  静态成员数据是共享的。</p>
</li>
</ul>
<h3 id="什么是静态成员函数？"><a href="#什么是静态成员函数？" class="headerlink" title="什么是静态成员函数？"></a>什么是静态成员函数？</h3><p>​    将类成员函数声明为static，则为静态成员函数。</p>
<ul>
<li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。<br>  -普通成员函数可以访问普通成员变量，也可以访问静态成员变量。<br>  -静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。</li>
</ul>
<h3 id="volatile有什么用？"><a href="#volatile有什么用？" class="headerlink" title="volatile有什么用？"></a>volatile有什么用？</h3><p>​    volatile字面意思可变的，被它修饰的变量表示可以被某些编译器未知的原因更改，编译器访问这个变量时不会在优化，常用在多线程间被几个任务共享的变量。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化。</p>
<h3 id="define与const有什么不同？"><a href="#define与const有什么不同？" class="headerlink" title="#define与const有什么不同？"></a>#define与const有什么不同？</h3><ol>
<li>编译时期不同：define在预处理阶段展开，const在编译阶段使用</li>
<li>安全检查同：define宏没有安全检查，而const是有具体类型，会执行类型检查</li>
<li>定义域不同：define宏不受定义域限制，而const只在定义域内有效</li>
<li>存储方式不同：define宏不会给分派内存，而const会分配，但也只是维持一份拷贝</li>
</ol>
<h3 id="变量的声明和定义有什么区别？"><a href="#变量的声明和定义有什么区别？" class="headerlink" title="变量的声明和定义有什么区别？"></a>变量的声明和定义有什么区别？</h3><p>​    声明：不分配地址空间；可以多次声明</p>
<p>​    定义：为变量分配地址空间；只能定义一次，加入extern修饰的是变量的声明，说明此变量在文件外或文件后定义。</p>
<h3 id="简述-ifdef、-else、-endif和-ifndef的作用"><a href="#简述-ifdef、-else、-endif和-ifndef的作用" class="headerlink" title="简述#ifdef、#else、#endif和#ifndef的作用"></a>简述#ifdef、#else、#endif和#ifndef的作用</h3><p>​    这些统称为条件编译，这几个配合使用可以防止头文件的重复包含和编译，并且便于程序的调试和移植。</p>
<h3 id="sizeof和strlen区别"><a href="#sizeof和strlen区别" class="headerlink" title="sizeof和strlen区别"></a>sizeof和strlen区别</h3><p>​    sizeof为操作符，计算占内存的字节数大小，不同的计算机或编译器下不一定相同；编译期就算出了结果。</p>
<p>​    strlen为库函数，计算一个以’\0’结尾的字符串的实际长度；必须运行才能算出结果。</p>
<h3 id="简述strcpy、sprintf与memcpy区别："><a href="#简述strcpy、sprintf与memcpy区别：" class="headerlink" title="简述strcpy、sprintf与memcpy区别："></a>简述strcpy、sprintf与memcpy区别：</h3><ul>
<li>操作对象不同：两个操作对象都是字符串；源对象可以是多种类型，目的对象是字符串；两个内存地址。</li>
<li>执行效率不同：memcpy&gt;strcpy&gt;sprintf</li>
<li>实现功能不同：字符串拷贝；其他类型到字符串的转换；内存拷贝。</li>
</ul>
<h3 id="简述内联函数inline的优缺点："><a href="#简述内联函数inline的优缺点：" class="headerlink" title="简述内联函数inline的优缺点："></a>简述内联函数inline的优缺点：</h3><ul>
<li>优点：在调用地方进行代码展开，省去调用函数时间，提高了程序的效率；并且会进行安全类型检查。内联函数比较适合用在频繁使用且内容不多的地方。</li>
<li>缺点：代码膨胀，产生更多的函数；如果内联函数执行时间比调用事件长很多，提升的效率也不高；修改麻烦，修内联所有调用的地方都需要重新编译。</li>
</ul>
<h3 id="智能指针分为哪几种？各自有什么特点？"><a href="#智能指针分为哪几种？各自有什么特点？" class="headerlink" title="智能指针分为哪几种？各自有什么特点？"></a>智能指针分为哪几种？各自有什么特点？</h3><p>​    智能指针是一个RAII资源获取即初始化类模型，用于动态分配内存，智能指针的作用是能够处理内存泄漏和空悬指针问题。分为四种：</p>
<ul>
<li>auto_ptr，实现所有权的概念，被抛弃了，由于对象所有权问题，不能指向数组，不能作为STL的成员；</li>
<li>shared_ptr，实现共享式拥有的概念，多个智能指针可以同时指向该对象；底层使用引用计数，每多一个智能指针指向同一内存就把该计数加1，该对象和其相关资源会在“最后一个引用被销毁”时候释放。使用reset()放弃内部对象的所有权或拥有对象的变更。</li>
<li>weak_ptr，实现了弱共享、弱引用的 概念，为了解决shared_prt相互引用时引用永远不会变为0而导致的死锁问题，依赖shared_ptr生存，只能由一个shared_ptr 或另一个 weak_ptr 对象构造</li>
<li>unique_ptr，实现独占式拥有的概念，同一时间只能由一个智能指针指向该对象。</li>
</ul>
<h3 id="shared-ptr的数据结构与安全性"><a href="#shared-ptr的数据结构与安全性" class="headerlink" title="shared_ptr的数据结构与安全性"></a>shared_ptr的数据结构与安全性</h3><p>​    shared_ptr是引用计数的智能指针，计数值保存在堆上动态分配的内存。对于具体类型<code>shared_ptr&lt;Foo&gt;</code>来说包含两个成员：</p>
<ol>
<li>Foo类型的指针，指向管理的对象</li>
<li>一个ref_count指针，指向堆上的控制块</li>
</ol>
<p>​    对于线程安全来说：<code>shared_ptr</code>的引用计数本身是线程安全的且无锁的，但是 <code>shared_ptr</code>对象本身的读写则不是，因为 <code>shared_ptr</code>有两个数据成员，读写操作不能原子化：</p>
<ul>
<li>多个线程可以同时读取同一个 <code>shared_ptr</code>对象</li>
<li>多个线程同时读写一个 <code>shared_ptr</code>对象需要加锁</li>
</ul>
<h3 id="右值引用有什么作用？"><a href="#右值引用有什么作用？" class="headerlink" title="右值引用有什么作用？"></a>右值引用有什么作用？</h3><p>​    右值引用作为参数的目的是实现转移语义，而作为返回值的意义是完美转发，消除两个对象交互时不必要的对象拷贝，也能够更加简洁明确地定义泛型函数。</p>
<ul>
<li>左值引用：可以去取地址的，有名字的，非临时的</li>
<li>右值引用：no取地址的，没名字的，临时的</li>
</ul>
<h3 id="悬挂指针和野指针有什么区别？"><a href="#悬挂指针和野指针有什么区别？" class="headerlink" title="悬挂指针和野指针有什么区别？"></a>悬挂指针和野指针有什么区别？</h3><ul>
<li>悬挂指针是指当对象被释放，但是该指针没有任何改变，指向了被回收的内存</li>
<li>野指针：未被初始化的指针</li>
</ul>
<h3 id="指针和引用的区别？"><a href="#指针和引用的区别？" class="headerlink" title="指针和引用的区别？"></a>指针和引用的区别？</h3><ul>
<li>指针有自己的地址空间，引用只是一个别名</li>
<li>sizeof(指针)为4，sizeof(引用)为引用对象的大小，sizeof(空的类型)大小为1</li>
<li>如果返回动态分配的对象或者内存，必须使用指针，引用会引起内存泄露</li>
<li>引用必须初始化，而指针而不一定</li>
</ul>
<h3 id="typedef和define的区别"><a href="#typedef和define的区别" class="headerlink" title="typedef和define的区别"></a>typedef和define的区别</h3><ul>
<li>用法不同：typedef用作给一种数据类型外号，增强程序可读性；define宏主要就是定义常量</li>
<li>执行时间不同：typedef是编译过程中的一部分，进行类型检查；define是预编译部分，不进行类型检查</li>
<li>作用域不同：：typedef有作用域限定，define不受作用域约束</li>
<li>对指针操作不同：typedef如果对指针进行封装，无论后面有多少变量都会被声明为指针；而define只会将后面的第一个声明变为指针</li>
</ul>
<h3 id="C语言的结构体和C-的类有什么区别？"><a href="#C语言的结构体和C-的类有什么区别？" class="headerlink" title="C语言的结构体和C++的类有什么区别？"></a>C语言的结构体和C++的类有什么区别？</h3><ul>
<li>修饰不一样：结构体全部都是public修饰，类可以指定public、private与protected三种修饰符</li>
<li>默认修饰也不一样：结构体默认就是public，类不指明的话默认是private</li>
<li>结构体不能有成员函数，类可以有</li>
<li>结构体没有继承，类有继承</li>
</ul>
<h3 id="extern-C有什么作用？"><a href="#extern-C有什么作用？" class="headerlink" title="extern  C有什么作用？"></a>extern  C有什么作用？</h3><p>​    extern C主要的作用就是正确实现在C++代码中调用其他C语言代码，加上这段代码，编译器会按照C语言的编译方式来对这段代码进行编译。</p>
<h3 id="面向对象的三大特征："><a href="#面向对象的三大特征：" class="headerlink" title="面向对象的三大特征："></a>面向对象的三大特征：</h3><ul>
<li>封装：将客观事物封装为类，而类可以很好的隐藏自己的信息</li>
<li>继承：可以使用现有的类所有功能，并且无需重新编写就可以对原来的类进行拓展</li>
<li>多态：一个类实例的相同方法在不同情况下有不同的表现形式</li>
</ul>
<h3 id="多态的实现方式："><a href="#多态的实现方式：" class="headerlink" title="多态的实现方式："></a>多态的实现方式：</h3><ul>
<li>动态多态：虚函数、继承，执行动态绑定，在运行期间确定</li>
<li>静态多态：重载、模板，指定静态绑定，在编译期间确定</li>
</ul>
<h3 id="动态绑定是如何实现的？"><a href="#动态绑定是如何实现的？" class="headerlink" title="动态绑定是如何实现的？"></a>动态绑定是如何实现的？</h3><p>​    编译器发现有虚函数时，会创建一张虚函数表，把虚函数的入口地址放在虚函数表中，并且在对象中增加一个vptr虚函数指针，用于指向虚函数表，当派生类覆盖基类的虚函数时，会将虚函数指针进行替换，从而调用派生后覆盖的的虚函数，从而实现动态绑定。</p>
<p>​    虚函数表是针对类的，类的所有对象共享这个虚函数表，每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象vptr指针的地址不一样，但是都指向同一虚函数表。</p>
<h3 id="动态绑定有什么作用？有哪些必要条件？"><a href="#动态绑定有什么作用？有哪些必要条件？" class="headerlink" title="动态绑定有什么作用？有哪些必要条件？"></a>动态绑定有什么作用？有哪些必要条件？</h3><p>作用：</p>
<ul>
<li>隐藏实现细节，使代码模块化，提高复用性</li>
<li>接口重用，是派生类功能可以被基类指针&#x2F;引用所调用，即向后兼容</li>
</ul>
<p>必要条件：</p>
<ul>
<li>继承</li>
<li>虚函数</li>
<li>需要基类指针&#x2F;引用指向子类对象</li>
</ul>
<h3 id="c-类中的默认函数有哪些"><a href="#c-类中的默认函数有哪些" class="headerlink" title="c++类中的默认函数有哪些"></a>c++类中的默认函数有哪些</h3><ul>
<li>构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>赋值运算符重载</li>
<li>取地址运算符</li>
<li>const取地址运算符</li>
</ul>
<h3 id="为什么基类的构造函数不能定义为虚函数？"><a href="#为什么基类的构造函数不能定义为虚函数？" class="headerlink" title="为什么基类的构造函数不能定义为虚函数？"></a>为什么基类的构造函数不能定义为虚函数？</h3><p>​    虚函数的调用依赖虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。</p>
<h3 id="为什么基类的析构函数要定义为虚函数？"><a href="#为什么基类的析构函数要定义为虚函数？" class="headerlink" title="为什么基类的析构函数要定义为虚函数？"></a>为什么基类的析构函数要定义为虚函数？</h3><p>​    为了实现动态绑定，基类指针指向派生类，如果析构不是虚函数，那么会实现静态绑定，在删除基类指针时只会调用基类的析构函数，而不会调用派生类的析构函数，只能销毁基类对象中的数据部分，所以必须将析构函数定义为虚函数。</p>
<h3 id="构造函数和析构函数可以抛出异常么？"><a href="#构造函数和析构函数可以抛出异常么？" class="headerlink" title="构造函数和析构函数可以抛出异常么？"></a>构造函数和析构函数可以抛出异常么？</h3><ul>
<li>构造函数可以，但是不好，会导致内存泄漏</li>
<li>析构函数不可以，如果析构时抛出异常，异常点之后的程序不会执行，一些释放资源的语句不会被执行，会导致内存泄漏，而且一般发生异常时，对象会调用自己的析构函数来释放资源，如果在析构函数中在抛出异常，会造成程序崩溃。</li>
</ul>
<h3 id="如果不让一个类实例化？"><a href="#如果不让一个类实例化？" class="headerlink" title="如果不让一个类实例化？"></a>如果不让一个类实例化？</h3><ul>
<li>纯虚函数</li>
<li>将构造函数定义为private</li>
</ul>
<h3 id="多继承存在什么问题？如何消除多继承中的二义性？"><a href="#多继承存在什么问题？如何消除多继承中的二义性？" class="headerlink" title="多继承存在什么问题？如何消除多继承中的二义性？"></a>多继承存在什么问题？如何消除多继承中的二义性？</h3><p>多继承存在的问题：</p>
<ul>
<li>程序复杂，维护困难</li>
<li>在继承时，如果基类之间或者基类与派生类之间发生成员同名时，会出现对成员访问的不确定，造成同名二义性</li>
<li>当派生类从多个基类派生，而这些基类又从同一个基类派生（菱形继承），则在访问此共同基类的成员时将会产生不确定性，即路径二义性；菱形继承另外一个缺点就是冗余性：存在在重复的数据。</li>
</ul>
<p>消除同名二义性：</p>
<ul>
<li>利用作用域运算符::，限定派生类使用哪个基类的成员</li>
<li>在派生类中定义同名成员，覆盖基类相关成员</li>
</ul>
<p>消除路径二义性：</p>
<ul>
<li>同名那两个都可以</li>
<li>使用虚继承，使不同路径继承来的同名成员在内存中只有一份拷贝</li>
</ul>
<h3 id="覆盖和重载的区别："><a href="#覆盖和重载的区别：" class="headerlink" title="覆盖和重载的区别："></a>覆盖和重载的区别：</h3><ul>
<li>覆盖：派生类中重新定义基类中的函数，其函数名、参数列表、返回值与父类完全相同，指示函数体存在区别，覆盖只发生在类的成员函数中</li>
<li>重载：是指两个具有相同名字的函数，有不同的参数列表，不关心返回值</li>
</ul>
<h3 id="类怎么防止继承？"><a href="#类怎么防止继承？" class="headerlink" title="类怎么防止继承？"></a>类怎么防止继承？</h3><ul>
<li>可以将类变为一个内部类</li>
<li>可以将构造函数设置为private</li>
<li>可以在Class前使用关键字final</li>
</ul>
<h3 id="final的含义及用法"><a href="#final的含义及用法" class="headerlink" title="final的含义及用法"></a>final的含义及用法</h3><p>​    final表示最终的、不可变的，可以修饰变量、方法还有类；final修饰的类无法被继承；final修饰的方法无法被覆盖，无法被重写；final修饰的变量只能赋一次值；final修饰的实例变量一般会添加static修饰，static final联合修饰的变量被称为“常量”。</p>
<h3 id="c-中四种强制类型转换"><a href="#c-中四种强制类型转换" class="headerlink" title="c++中四种强制类型转换"></a>c++中四种强制类型转换</h3><ul>
<li>const_cast&lt;type-id&gt; (expression)，该运算符用来修改类型的const或volatile属性（只有该运算符可以去掉const属性）</li>
<li>static_cast&lt;type-id&gt; (expression)强转类型，用于基本数据之间的类型转换，子类向父类的安全转换，void*与其他具体指针类型的转换，没有运行时类型检查保证转换的安全性。</li>
<li>reinterpret_cast&lt;type-id&gt; (expression) 只能用于不同类型指针之间或引用之间强制转化，可以完成一些static_cast不能完成的转换（比如两个具体类型指针的转换、int与指针之间的转换），本质是编译器面向二进制的转换，风险很大</li>
<li>dynamic_cast&lt;type-id&gt;(expression)有类型检查，只能用于含有虚函数表的类；派生类向基类转化不太安全(向上转化)，但是都能成功。可以使虚基类向子类转化，基类向派生类转换比较安全(向下转化)，在向下转化时，对于非法的指针返回NULL，对于引用返回bad_cast异常</li>
</ul>
<h3 id="new-x2F-delete和malloc-x2F-free之间有什么关系"><a href="#new-x2F-delete和malloc-x2F-free之间有什么关系" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free之间有什么关系"></a>new&#x2F;delete和malloc&#x2F;free之间有什么关系</h3><ul>
<li>new与delete直接带具体数据类型，malloc和free返回void类型的指针</li>
<li>new类型是安全的，malloc不是</li>
<li>new调用构造函数，malloc不能；delete调用析构函数，free不能</li>
<li>malloc&#x2F;free是C&#x2F;C++的库函数，而new&#x2F;delete是C++的运算符，可以重载</li>
<li>new是从自由存储区分配内存，而malloc是从堆分配的</li>
<li>new申请空间失败会抛出bad_alloc异常，而malloc会返回NULL</li>
</ul>
<p>​    <strong>ps：delete和free调用后，内存不会立刻回收，指针也不会指空，释放完内存应该让指针指向NULL。并且new与delete本质也是封装了malloc与free的函数。</strong></p>
<h3 id="delete与delete-的区别？"><a href="#delete与delete-的区别？" class="headerlink" title="delete与delete []的区别？"></a>delete与delete []的区别？</h3><ul>
<li>对于简单类型来说，new分配以后调用两个都可以释放内存</li>
<li>对于自定义类型而言，需要对单个对象使用delete，对数组对象使用delete []</li>
<li>最恰当的方式是如果new一个对象，就delete它，如果new []对象，就delete []</li>
</ul>
<h3 id="内存泄漏的场景有哪些？"><a href="#内存泄漏的场景有哪些？" class="headerlink" title="内存泄漏的场景有哪些？"></a>内存泄漏的场景有哪些？</h3><ul>
<li>malloc&#x2F;free没有成对使用，new&#x2F;delete没有成对出现</li>
<li>在堆中创建对象分配内存，但是未显式释放内存；比如通过局部分配的内存，未在调用者函数体内释放</li>
<li>在构造函数内动态分配内存，没有在析构函数中正确释放</li>
<li>未定义拷贝构造函数或未重载赋值运算符。从而造成两次释放相同的内存</li>
<li>没有将基类的析构函数定义为虚函数</li>
</ul>
<h3 id="内存泄露怎么避免"><a href="#内存泄露怎么避免" class="headerlink" title="内存泄露怎么避免"></a>内存泄露怎么避免</h3><ul>
<li>使用智能指针</li>
<li>malloc&#x2F;free new&#x2F;delete一一对应</li>
<li>尽量资源获取即初始化 RAII</li>
</ul>
<h3 id="c-的内存的分配方式"><a href="#c-的内存的分配方式" class="headerlink" title="c++的内存的分配方式"></a>c++的内存的分配方式</h3><ul>
<li>从栈上分配：局部变量，一般由编译器创建释放</li>
<li>从堆上分配：是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free()可把内存交还</li>
<li>自由存储区：是C++中通过new和delete动态分配和释放对象的抽象概念，过new来申请的内存区域可称为自由存储区。（为c+特有的，c，没有这一块）</li>
<li>从常量存储区分配：存放常量，不可修改</li>
<li>从全局&#x2F;静态存储区分配：全局变量和静态变量被分派带同一块内存（c中全局和静态变量分为初始化和未初始化的，在c++中无区分共用同一块内存）</li>
</ul>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>​    从上到下为高地址到低地址，分四个区：</p>
<ul>
<li>栈区，从低字节向向字节存储，主要存放局部变量，一般由编译器释放</li>
<li>堆区，从高字节向低字节存储，主要存放new和malloc的对象，一般由程序员释放</li>
<li>全局区：主要包含静态全局区和常量区</li>
<li>代码区：存放函数体的二进制代码</li>
</ul>
<h3 id="堆和栈有什么区别？"><a href="#堆和栈有什么区别？" class="headerlink" title="堆和栈有什么区别？"></a>堆和栈有什么区别？</h3><ul>
<li>分配和管理方式不同：堆是动态分配；栈是编译器自动管理</li>
<li>产生碎片不同：对于堆来说，频繁使用new&#x2F;delete会造成内存空间的不连续，产生大量碎片；对栈来说，不存在碎片问题，后进先出</li>
<li>生长方向不同：堆是向着内存地址增长的方向增长，由内存低地址到高地址方向增长；栈正好相反</li>
<li>申请大小限制不同：堆是不连续的区域，大小可以灵活调整；栈的栈顶和栈底都是预设好的，大小固定</li>
</ul>
<h3 id="深拷贝与浅拷贝有什么区别？"><a href="#深拷贝与浅拷贝有什么区别？" class="headerlink" title="深拷贝与浅拷贝有什么区别？"></a>深拷贝与浅拷贝有什么区别？</h3><ul>
<li>浅拷贝是将原对象或原数组的引用直接赋给新对象或新数组，新的只是原来的一个引用，新旧对象还是共享一块内存</li>
<li>深拷贝是创建一个新的对象和数组，将原对象的各项属性的“值”(数组的所有元素)拷贝过来，是值而不是引用，新旧对象不共享一块内存，修改新对象不会对旧对象发生影响</li>
</ul>
<h3 id="什么是字节对齐？原则是什么？"><a href="#什么是字节对齐？原则是什么？" class="headerlink" title="什么是字节对齐？原则是什么？"></a>什么是字节对齐？原则是什么？</h3><p>​    字节对齐是字节按照一定规则在空间上排列。原则如下：</p>
<ul>
<li>从偏移为0的位置开始存储</li>
<li>基本数据类型对齐：基本数据类型自身占用的存储空间大小</li>
</ul>
<h3 id="结构体字节对齐的问题："><a href="#结构体字节对齐的问题：" class="headerlink" title="结构体字节对齐的问题："></a>结构体字节对齐的问题：</h3><ul>
<li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同</li>
<li>未特殊说明。按结构体中size最大的成员对齐</li>
<li>结构体分配的总空间大小必须是最宽基本类型成员的整数倍</li>
<li>结构体各个成员相对结构体起始地址的偏移量是该成员数据类型大小的整数倍</li>
<li>如果没有定义 <code>#pragma pack(n)</code> ，sizeof的最后结果必然是结构体内部最大成员的整数倍，不够补齐，结构体内各个成员的首地址必然是自身大小的整数倍</li>
<li>如果定义了<code>#pragma pack(n)</code> ，sizeof的结果最后必然是min[n, 结构体内最大成员的整数倍]，不够补齐，结构体内内部各个成员的首地址必然是min[n, 自身大小]的整数倍</li>
</ul>
<h3 id="友元是什么？"><a href="#友元是什么？" class="headerlink" title="友元是什么？"></a>友元是什么？</h3><p>​    某个类需要实现某种功能，但是这个类自身由于某些原因无法自己实现，需要借助外力才能实现，就是友元函数。友元函数friend允许一个类授权其他类访问他的非公有成员，只能出现在类的声明中，他们不受类中public、private和protected的影响，并且友元关系不能够传递，只对类内声明友元的类有效。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>​    c++11引入的语法糖，在调用或作为函数参数传递的位置处定义匿名对象的便捷方式，包括：捕获列表、列表参数、可变规则、返回类型和函数体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(x, x+n, </span><br><span class="line">         [捕获列表] 这里写可变规则 (<span class="type">float</span> a,  <span class="type">float</span> b 参数列表) 这里写返回类型 &#123;</span><br><span class="line">             <span class="built_in">return</span>  (std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b));  函数体</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>

<p>​    捕获列表中可以采用值传递或引用传递。[&#x3D;]表示值传递捕获父作用域所有变量、[&amp;]表示引用传递捕获父作用域所有对象、[this]表示捕获this指针。</p>
<h2 id="STL知识点"><a href="#STL知识点" class="headerlink" title="STL知识点"></a>STL知识点</h2><h3 id="STL序列式容器有哪些？"><a href="#STL序列式容器有哪些？" class="headerlink" title="STL序列式容器有哪些？"></a>STL序列式容器有哪些？</h3><ul>
<li>array：数组，固定大小数组，支持快速随机访问，不能插入删除元素</li>
<li>vector：动态数组，支持快速随机访问，尾部插入删除元素速度快</li>
<li>list：双向链表，只支持双向顺序访问，任何位置插入删除都很快</li>
<li>deque：双向队列，支持快读随机访问，首尾插入和删除的速度很快</li>
<li>forward_list：单向链表，只支持单项顺序访问，任何位置插入删除速度都很快</li>
</ul>
<h3 id="array底层原理"><a href="#array底层原理" class="headerlink" title="array底层原理"></a>array底层原理</h3><p>​    array本质就是一个<strong>大小固定的数组</strong>，无法动态改变，只允许访问或替换数组中的元素。</p>
<h3 id="vector底层原理"><a href="#vector底层原理" class="headerlink" title="vector底层原理"></a>vector底层原理</h3><p>​    vector底层是一个<strong>动态数组</strong>，包含三个迭代器，start, finish, end_of_storage；当数组空间装不下时，会自动申请另一篇更大的空间（1.5倍或2倍），把原来的数据拷贝带新的内存空间，然后释放原来的那片空间。</p>
<p>​    vector调用clear()函数只是清空了里面的数据，其存储空间不释放。</p>
<h3 id="vector中reserver与resize"><a href="#vector中reserver与resize" class="headerlink" title="vector中reserver与resize"></a>vector中reserver与resize</h3><p>​    vector中reverse()是直接扩充到确定的大小下，可以减少多次开辟、释放空间的问题；resize()可以改变有效空间的大小，也有改变默认值的功能。</p>
<h3 id="vector中size与capacity"><a href="#vector中size与capacity" class="headerlink" title="vector中size与capacity"></a>vector中size与capacity</h3><p>​    vector中size表示当前有多少元素，capacity表示当前分配的内存能容纳多少元素。</p>
<h3 id="如何正确释放vector内存"><a href="#如何正确释放vector内存" class="headerlink" title="如何正确释放vector内存"></a>如何正确释放vector内存</h3><ul>
<li>vec.clear(); vec.shrink_to_fit();  清空内容并且释放内存</li>
<li>vector(Vec).swap(Vec); 清除内存</li>
<li>vector().swap(Vec); 清除内存</li>
</ul>
<h3 id="list底层原理"><a href="#list底层原理" class="headerlink" title="list底层原理"></a>list底层原理</h3><p>​    list底层是一个<strong>双向链表</strong>，以节点为单位存储数据，节点的地址在内存中不一定连续，每次插入或者删除一个元素，就配置或释放一个元素空间。</p>
<p>​    list不支持随机存取，适合需要大量的插入和删除，而不关心随机存取的应用场景。</p>
<h3 id="deque底层原理"><a href="#deque底层原理" class="headerlink" title="deque底层原理"></a>deque底层原理</h3><p>​    deque底层是一个<strong>双向开口的线性连续空间（双端队列</strong>），在头部和尾部插入、删除元素有理想的复杂度；并且deque也不保证存储元素所有元素都存储在连续的空间内。</p>
<h3 id="vector、list与deque都适用于什么情况？"><a href="#vector、list与deque都适用于什么情况？" class="headerlink" title="vector、list与deque都适用于什么情况？"></a>vector、list与deque都适用于什么情况？</h3><p>​    vector可以随机存储元素，不需要挨个查找，适合随机存取的场景使用，除非必要情况尽量都使用vecter而非deque；</p>
<p>​    list适用于对象大、对象数量频繁变化，插入和删除频繁的场景；</p>
<p>​    deque适合在头尾两端进行操作的场景。</p>
<h3 id="forwrad-list底层原理"><a href="#forwrad-list底层原理" class="headerlink" title="forwrad_list底层原理"></a>forwrad_list底层原理</h3><p>​    froward_list和list差不多，只不过他是一个<strong>单向链表</strong>，节点的地址在内存中不一定连续。</p>
<h3 id="STL关联容容器是什么？有哪些？"><a href="#STL关联容容器是什么？有哪些？" class="headerlink" title="STL关联容容器是什么？有哪些？"></a>STL关联容容器是什么？有哪些？</h3><p>​    关联式容器是指存储元素是会为元素配备一个键Key，整体以键值对的方式存储在容器中；另外，关联式容器在存储元素时会根据元素的大小进行排序(less&lt;T&gt;, greater&lt;T&gt;)。</p>
<ul>
<li>map：关联数组，key-value</li>
<li>multimap：key可重复出现的map</li>
<li>set：只保存关键字</li>
<li>multiset：key可重复出现的set</li>
</ul>
<h3 id="上述几个关联式容器的的底层原理是什么？"><a href="#上述几个关联式容器的的底层原理是什么？" class="headerlink" title="上述几个关联式容器的的底层原理是什么？"></a>上述几个关联式容器的的底层原理是什么？</h3><p>​    关联式容器的底层都是根据<strong>红黑树</strong>实现的，epoll模型的低层也是红黑树。红黑树具有以下特点：</p>
<ol>
<li>是一个棵平衡二叉树</li>
<li>节点分为两种颜色：红色和黑色</li>
<li>根节点和叶子节点为黑色</li>
<li>红色结点的子节点必须是黑色节点</li>
<li>根节点到任意一个叶子节点的路径上黑色节点个数相同</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>​    map容器存储的都是pair对象（键值对），默认情况下会自定根据键的大小按照升序排序std::less&lt;T&gt;。map中存储的键不能重复也不能被修改（注意是键不能修改！值可以）。</p>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><p>​    multimap与map一样按照键值对存储，不相同的是multimap可以存入多个相同键的键值对。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>​    与两个map容器不同，使用set容器存储的各个键值对的key和value都相等。set还要求存储的键不能重复，并且默认情况下也会根据键的大小按升序排序。</p>
<h3 id="multeset"><a href="#multeset" class="headerlink" title="multeset"></a>multeset</h3><p>​     multiset与set一样按照键值对存储key和value都相等，不同的是multiset可以存入多个相同的键值对。</p>
<h3 id="map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？"><a href="#map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？" class="headerlink" title="map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？"></a>map和set的插入删除速度是多少？为什么每次insert之后以前保存的iterator不会失效？</h3><p>​    map和set的插入删除速度都是logN。</p>
<p>​    由于红黑树存储的是节点，不需要内存拷贝和内存移动，插入和删除操作也只是将节点的指针换来换去，节点内存没有改变。</p>
<h3 id="为何map和set不能像vector一样有个reserve函数来预分配数据"><a href="#为何map和set不能像vector一样有个reserve函数来预分配数据" class="headerlink" title="为何map和set不能像vector一样有个reserve函数来预分配数据?"></a>为何map和set不能像vector一样有个reserve函数来预分配数据?</h3><p>​    因为在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map&lt;Key, Data, Compare, Alloc&gt;声明的时候从参数中传入的Alloc。</p>
<h3 id="map的插入方式有几种？"><a href="#map的插入方式有几种？" class="headerlink" title="map的插入方式有几种？"></a>map的插入方式有几种？</h3><ul>
<li>用insert插入pair数据 <code>mapM.insert(pair&lt;char, int&gt;(&#39;a&#39;, 1));</code></li>
<li>用insert插入value_type数据 <code>mapM.insert(map&lt;char, int&gt;::value_type(&#39;a&#39;, 1));</code></li>
<li>在insert函数中使用make_pair()函数 <code>mapM.insert(make_pair(&#39;a&#39;, 1));</code></li>
<li>用数组下标方式插入 <code>mapM[&#39;a&#39;] = 1;</code></li>
</ul>
<h3 id="STL无序式关联容器有哪些？"><a href="#STL无序式关联容器有哪些？" class="headerlink" title="STL无序式关联容器有哪些？"></a>STL无序式关联容器有哪些？</h3><p>​    无序式关联容器，又称哈希容器，采用的存储结构为哈希表。<strong>哈希表可以根据关键字直接找到数据的存储位置，不需要进行任何比较，大大降低数据查找和存储消耗的时间，但是需要比较多的内存。</strong></p>
<ul>
<li>unordered_map</li>
<li>unordered_set    </li>
<li>unordered_multimap</li>
<li>unordered_multiset</li>
</ul>
<h3 id="unordered-map底层原理、unordered-set底层原理"><a href="#unordered-map底层原理、unordered-set底层原理" class="headerlink" title="unordered_map底层原理、unordered_set底层原理"></a>unordered_map底层原理、unordered_set底层原理</h3><p>​    unordered_map的底层是一个防冗余的哈希表（采用除留余数法），还是采用键值对的方式存储，键值对互不相等并且不会对存储内容进行排序。</p>
<p>   unordered_set底层也是一个防冗余的哈希表，不以键值对存储，直接存储数据的值，元素值互不相同并且不会对内容进行排序。</p>
<p>​    使用一个下标范围较大的数组来存储元素，设计一个哈希函数(散列函数)，使得每一个元素的key都与一个函数值(数组下表，hash值)相对应，用这个数组单元来存储这个元素，这个数组单元也被成为桶。</p>
<p>​    对于不同元素计算出相同哈希值(即发生冲突)的时候，一般采用开链法解决冲突。</p>
<h3 id="STL的容器适配器有哪些？"><a href="#STL的容器适配器有哪些？" class="headerlink" title="STL的容器适配器有哪些？"></a>STL的容器适配器有哪些？</h3><p>​    容器适配器是一个封装了序列容器的模板。</p>
<ul>
<li>stack</li>
<li>queue</li>
<li>priority_queue</li>
</ul>
<h3 id="stack底层原理"><a href="#stack底层原理" class="headerlink" title="stack底层原理"></a>stack底层原理</h3><p>​    stack适配器是一个<strong>单端开口的容器</strong>，模拟栈存储结构，无论存数据还是读数据，都只能从这个一个开口操作。满足后进先出LIFO准则。</p>
<h3 id="queue底层原理"><a href="#queue底层原理" class="headerlink" title="queue底层原理"></a>queue底层原理</h3><p>​    queue适配器有<strong>两个开口的容器，一个专门输入数据，一个专门输出数据</strong>，模拟单向队列存储结构。满足先入先出FIFO准则。</p>
<h3 id="priority-queue底层原理"><a href="#priority-queue底层原理" class="headerlink" title="priority_queue底层原理"></a>priority_queue底层原理</h3><p>​    priority_queue适配器模拟的也是队列这种存储结构，只能一端进，另一段出，且每次访问只能访问队头元素，本质是一个堆，又被称为优先队列(最大堆&#x2F;最小堆)，队头元素永远都是优先级最大的元素。可以在创建优先队列对象时指明是最大堆less&lt;T&gt;还是最小堆greater&lt;T&gt;，这里less与greater与其他容器不同，priority_queue默认最大堆。</p>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><ul>
<li>vector删除当前的iterator会使后面所有元素的iterator都失效，erase会返回下一个有效的iterator，要采用 <code>iter = erase(iter)</code> 的方式删除。vector插入元素时，如果capacity不变（即不需要扩容），只有.end迭代器失效，如扩容则全部失效</li>
<li>deque删除当前的iterator只会使当前的iterator失效，erase会返回下一个有效的iterator，要采用 <code> erase(*iter)</code> 或 <code>erase(iter++)</code> 的方式删除；首尾插入元素不会使迭代器失效</li>
<li>关联式容器和list删除当前的iterator只会使当前的iterator失效，返回值为void，所以要采用 <code>erase(iter++)</code> 的方式来删除；插入元素不会使迭代器失效。</li>
</ul>
<h2 id="MySQL知识点"><a href="#MySQL知识点" class="headerlink" title="MySQL知识点"></a>MySQL知识点</h2><h3 id="MySQL的框架"><a href="#MySQL的框架" class="headerlink" title="MySQL的框架"></a>MySQL的框架</h3><img src="/2023/04/20/knowledge-summarize/image-20230116160003066.png" class="">

<p>​    主要由Server层和存储引擎两部分</p>
<p>​    Server：连接器，查询缓存，分析器，优化器，执行器；涵盖了MySQL的大多数核心服务功能</p>
<p>​    存储引擎负责：数据的存储与提取，支持MyISAM与InnoDB等</p>
<h3 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h3><ol>
<li>第一范式：强调的是原子性，即数据库表的每一列都是不可分割的原子数据项</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性</li>
<li>第三范式：任何非主属性不依赖其他属性</li>
</ol>
<h3 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h3><ul>
<li>char(n)：固定长度类型；效率高，但是占用空间</li>
<li>varchar(n)：可变长度，存储的值是每个值占的字节再加上一个用来记录其他长度的字节的长度</li>
</ul>
<h3 id="索引的理解"><a href="#索引的理解" class="headerlink" title="索引的理解"></a>索引的理解</h3><p>​    索引的出现是为了提高数据的查询效率，同样索引也会带来很多负担，创建索引和维护索引需要消耗时间，并且占据物理空间；同时会降低更新表的速度，因为更新表的时候不仅要保存数据，还需要保存索引文件。</p>
<p>​    建立索引的原则：</p>
<ul>
<li>在最频繁使用的、用以缩小查询范围的字段上建立索引</li>
<li>在频繁使用的、需要排序的字段上建立索引</li>
</ul>
<h3 id="B-树的理解"><a href="#B-树的理解" class="headerlink" title="B+树的理解"></a>B+树的理解</h3><ul>
<li>B+树是基于B树和叶子节点顺序访问指针实现的，具有B树的平衡性，并且通过顺序访问指针提高区间查询的性能</li>
<li>在B+树中，一个节点的key从左到右非递减排列</li>
<li>进行查找操作，首先在根节点二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点查找，直到找到叶子节点，然后再叶子节点上二分查找，找出key对应的data</li>
<li>插入、删除会破坏树的平衡性，因此插入删除之后需要对树进行操作维护平衡性</li>
</ul>
<h3 id="B树与B-树的区别"><a href="#B树与B-树的区别" class="headerlink" title="B树与B+树的区别"></a>B树与B+树的区别</h3><ul>
<li>B+树叶子节点保存了完整的索引与数据，而非叶子节点只保留索引值，因此查询时间为O(logN)；而B树每个节点都保留索引和数据</li>
<li>B+范围查找只需要遍历叶子节点链表，而B树却需要重复的中序遍历</li>
<li>B+适合外部存储，因为非叶子节点不存储数据，只保存索引</li>
</ul>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul>
<li>从数据结构角度分析<ol>
<li>树索引</li>
<li>Hash索引</li>
</ol>
</li>
<li>从物理存储角度看<ol>
<li>聚簇索引</li>
<li>非聚簇索引</li>
</ol>
</li>
<li>从逻辑角度看<ol>
<li>普通索引</li>
<li>唯一索引</li>
<li>主键索引</li>
<li>联合索引</li>
<li>全文索引</li>
</ol>
</li>
</ul>
<h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>​    聚簇索引是磁盘上实际数据重新组织按照一个或多个列的值排序的算法，特点是存储数据的顺序和索引顺序一样。一般主键会默认创建聚簇索引，且一张表只能有一个聚簇索引。</p>
<p>​    非聚簇索引与聚簇索引的区别就是：聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍是索引节点，指向对应数据块的指针(指向聚簇索引)</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>​    哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效，可以O(1)的速度进行查找，但是失去了有序性，无法用于分组、排序，只能支持精确查找，无法用于部分和范围查找。</p>
<p>​    InnoDB有一种自适应哈希索引，当某个索引值被频繁使用时，在B+树的索引基础上会再创建一个哈希索引，这样就让B+树具有哈希索引的优点</p>
<h3 id="逻辑角度的五个索引："><a href="#逻辑角度的五个索引：" class="headerlink" title="逻辑角度的五个索引："></a>逻辑角度的五个索引：</h3><ul>
<li>单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。主要为以下三个：<ul>
<li>普通索引：MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值</li>
<li>唯一索引：索引列的值必须唯一，但是允许为空值</li>
<li>主键索引：是一种特殊的唯一索引，不允许有空值（主键约束，就是只能有一个主键索引）</li>
</ul>
</li>
<li>联合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则</li>
<li>全文索引：只能在char\varvchar\text类型字段上使用的索引，在一堆文字中通过某个关键字就能找到该字段所属的行</li>
</ul>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>​    MySQL使用联合索引时需要满足最左前缀原则，即最左优先，以最左边的为起点任何连续的索引都能匹配上：</p>
<ul>
<li>如果第一个字段是范围查询需要单独建一个索引；</li>
<li>在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
</ul>
<p>​    最左前缀原则会一直向右匹配直到遇到查找范围(&lt;，&gt;，BETWEEN，LIKE)就停止匹配；并且&#x3D;和IN可以乱序</p>
<h3 id="什么情况不用索引"><a href="#什么情况不用索引" class="headerlink" title="什么情况不用索引"></a>什么情况不用索引</h3><ol>
<li>索引列参与表达式计算</li>
<li>函数运算</li>
<li>%语句%这种模糊查询</li>
<li>字符串与数字比较</li>
<li>查询条件中有OR</li>
<li>正则表达式</li>
<li>如果MySQL内部优化器估计扫描全表速度比索引快，就不会用索引</li>
</ol>
<h3 id="InnoDB与MyISAM比较"><a href="#InnoDB与MyISAM比较" class="headerlink" title="InnoDB与MyISAM比较"></a>InnoDB与MyISAM比较</h3><ul>
<li>事务：InnoDB支持，MyISAM不支持</li>
<li>全文索引：InnoDB5.6之前不支持，MyISAM支持</li>
<li>关于count()：MyISAM会直接存储总行数，InnoDB不会，需要按行扫描。对于 <code>SELECT count() FROM table;</code> 如果数据量较大，MyISAM会瞬间返回，而InnoDB会一行一行扫描</li>
<li>外键：InnoDB支持外键，MyISAM不支持</li>
<li>锁：InnoDB支持全局锁、表锁、行锁，MyISAM只支持全局锁和表锁</li>
</ul>
<h3 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h3><p>​    事务是一个最小的不可再分的工作单元，通常一个事务对应一个完整的义务。他有着四个特性：ACID：</p>
<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>​    ACID，即原子性、一致性、隔离性、持久性：</p>
<ul>
<li>原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保要么动作全部做完，要么完全不起作用</li>
<li>一致性（Consistency）：执行事务前后，数据库从一个一致性状态转移到另一个一致性状态</li>
<li>隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</li>
<li>持久性（Durability）：一个事务被提交后，他对数据库中的数据的改变是永久的，即使数据库发生了故障也不应该对其有任何影响</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ol>
<li>未提交读：最低的隔离级别，允许读取尚未提交的数据变更，可导致脏读、幻读、不可重复读</li>
<li>提交读：允许读取并发事务已经提交的数据，可以防止脏读，但是幻读、不可重复读仍能发生</li>
<li>可重复读：对同一字段的多次读取结果都是一致的，可以阻止脏读和不可重复读，但是幻读仍有可能发生</li>
<li>串行化：最高隔离级别，完全符合ACID。可以防止脏读、幻读、不可重复读，但是执行效率有太低，影响程序性能，一般都不用。</li>
</ol>
<h3 id="什么是脏读、幻读、不可重复读"><a href="#什么是脏读、幻读、不可重复读" class="headerlink" title="什么是脏读、幻读、不可重复读"></a>什么是脏读、幻读、不可重复读</h3><ul>
<li>脏读：表示一个事务还未提交的数据能够被另一个事务获取。</li>
<li>不可重复读：一个事务内，多次读同一个数据，由于这个事务还没有结束，另外一个事务也访问这个数据，在第一个事务两次读取数据之间，第二个事务修改了数据，导致两次读取结果不一致，这就是不可重复读。（不可重复读在于修改：同样的条件，你读取过的数据再读出来就不一样了）</li>
<li>幻读：指同一事务内多次查询返回结果集不一样，比如事务A第一次查询有4条数据，第二次一样的查询却有2条，两次结果不一致，好像产生了幻觉，这就是幻读。（幻读在于新增或删除：同样的条件，第一次和第二次读出来的结果不一样）</li>
</ul>
<h3 id="全局锁、表锁、行锁"><a href="#全局锁、表锁、行锁" class="headerlink" title="全局锁、表锁、行锁"></a>全局锁、表锁、行锁</h3><p>​    这个三个是按照锁粒度区分的：</p>
<ul>
<li>全局锁：使用FTWRL <code>Flush tables with read lock</code> 对整个数据库实例进行加锁，是整个数据库处于只可读状态。</li>
<li>表锁： <code>lock tables ... read/write</code> <code>unlock tables</code>，除了限制别的线程的读写外，也限定了本线程接下来的操作对象</li>
<li>行锁每次锁定的是一行数据，行级锁定不是MySQL自己实现锁定的方式，是由存储引擎实现的(InnoDB)自己实现的：行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</li>
</ul>
<h3 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h3><p>​    这两个是按照mysql的加锁机制区分的：</p>
<ul>
<li>悲观锁：指的是对数据被外界修改时持保守态度，因此在整个数据处理中将数据处于锁定状态。</li>
<li>乐观锁：乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检查，如果发生了冲突，则返回给用户让用户去决定如何去做。</li>
</ul>
<h3 id="共享锁、排他锁"><a href="#共享锁、排他锁" class="headerlink" title="共享锁、排他锁"></a>共享锁、排他锁</h3><p>   这两个是按照兼容性区分的：</p>
<ul>
<li>共享锁：允许持有锁，读取行的事务 <code>SELECT ... LOCK IN SHARE MODE</code></li>
<li>排他锁：允许持有锁，更新或删除行的事务 <code>SELECT ... FOR UPDATE</code></li>
</ul>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>​    所有执行时间超过 <code>long_query_time</code>秒的查询或不适用于索引的查询，默认为10s。</p>
<p>​    慢查询日子默认名称：<code>主机名-slow.log</code></p>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><ul>
<li>开启慢查询日志，定位到执行较慢的SQL语句</li>
<li>利用explain关键字可以模拟优化执行SQL查询语句，来分析SQL查询语句</li>
<li>通过查询的结果进行优化</li>
<li>优化方式：<ul>
<li>分析语句，是否包含了额外的数据</li>
<li>分析优化器中索引的使用情况</li>
<li>如果对语句的优化已经无法执行，可以考虑表中数据是否太大</li>
</ul>
</li>
</ul>
<h2 id="网络编程知识点"><a href="#网络编程知识点" class="headerlink" title="网络编程知识点"></a>网络编程知识点</h2><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul>
<li>TCP是面向连接的安全传输协议；UDP是面向无连接的不安全传输协议</li>
<li>TCP尽最大努力交付，提供可靠传输服务；UDP不确保数据会按原来的顺序到达，提供不可靠的创数服务</li>
<li>TCP首部开销大，为20字节；而UDP首部开销小，只占据8个字节</li>
<li>TCP只支持点对点通信；而UDP支持一对一、一对多、多对多等场景</li>
<li>TCP有三次握手四次挥手；UDP没有</li>
</ul>
<h3 id="TCP报文内容"><a href="#TCP报文内容" class="headerlink" title="TCP报文内容"></a>TCP报文内容</h3><img src="/2023/04/20/knowledge-summarize/image-20230111191843876.png" class="">

<p>​    六个控制位：</p>
<ul>
<li>紧急URG：为1时表示有紧急数据需要传送</li>
<li>确认ACK：为1时有效，建立连接后ACK都需要置为1</li>
<li>推送PSH：为1时立即创建一个报文段发送，当接收方接收到就尽快交付接受应用进程，而不是等到缓存满了在向上交付</li>
<li>复位RST：为1时说明传输过程出现了严重错误，需要立刻释放连接然后再重新建立连接</li>
<li>同步SYN：同步序号用，当SYN&#x3D;1而ACK&#x3D;0时说明是一个请求连接报文，如果同意链接则返回一个SYN&#x3D;1且ACK&#x3D;1的报文</li>
<li>终止FIN：为1时表示要求释放连接</li>
</ul>
<h3 id="HTTP1-0、1-1、2-0的区别"><a href="#HTTP1-0、1-1、2-0的区别" class="headerlink" title="HTTP1.0、1.1、2.0的区别"></a>HTTP1.0、1.1、2.0的区别</h3><p>​    HTTP协议是互联网最广泛的一种网络协议：</p>
<ul>
<li>HTTP&#x2F;1.0规定服务器与客户端只能保持<strong>短暂的连接</strong>，客户端请求建立连接，服务器完成请求释放连接，连接无法复用。TCP连接的建立需要三次握手，是很耗费时间的一个过程。（虽然可以强制开启强链接，但是也不是根本解决办法）</li>
<li>HTTP&#x2F;1.1最重要的就是引入了<strong>持久连接</strong>，TCP连接默认不关闭，<strong>可以被多个请求复用</strong>；并且引入了<strong>管道机制</strong>，在同一个TCP中可以客户端可以同时发送多个请求。但是服务端还是顺序执行的，效率还有提升的空间。</li>
<li>HTTP&#x2F;2.0进行了<strong>二进制分帧</strong>，即 HTTP&#x2F;2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码，所以可以进行<strong>多路复用</strong>，一个连接里，客户端和服务器可以同时发送多个请求和回应，而且不用按顺序一一对应。</li>
</ul>
<h3 id="HTTPS是什么？工作流程？"><a href="#HTTPS是什么？工作流程？" class="headerlink" title="HTTPS是什么？工作流程？"></a>HTTPS是什么？工作流程？</h3><img src="/2023/04/20/knowledge-summarize/20190915102903278.png" class="">

<p>​    是以安全为目标的HTTP通道，升级版的HTTP协议，即HTTP下加入SSL层(TLS&#x2F;SSL协议2)进行加密：</p>
<ul>
<li>客户端发送自己支持的加密规则给服务器，代表要建立连接</li>
<li>服务器从中选出一套加密算法和hash算法以及自己的身份信息以证书的形式发送给浏览器</li>
<li>客户端收到证书后要进行以下操作：<ul>
<li>验证证书合法性</li>
<li>如果通过，浏览器会产生一串随机数，并用证书中的公钥进行加密会话密钥</li>
<li>用约定好的hash算法计算握手信息，然后用会话密钥密钥进行加密，一起发送给服务器</li>
</ul>
</li>
<li>服务器接收客户端传来的信息，同时做下面的操作：<ul>
<li>用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致</li>
<li>使用密钥加密消息</li>
</ul>
</li>
<li>如果计算的hash值一致，返回会话密钥加密后的密文，握手成功</li>
<li>之后的发送内容都使用会话密钥加密解密</li>
</ul>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>​    http报文分为请求报文和响应报文两个，每种报文必选特定的格式生成，才能被浏览器端识别，客户端向服务器发送的为请求报文，服务器响应客户端的请求报文发送响应报文。</p>
<h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>​    HTTP请求报文由<strong>请求行、请求头部、空行和请求数据</strong>四个部分组成，其中，<strong>请求分为两中：GET和POST：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET</span><br><span class="line"> 1    GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line"> 2    Host:img.mukewang.com</span><br><span class="line"> 3    User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)</span><br><span class="line"> 4    AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line"> 5    Accept:image/webp,image/*,*/*;q=0.8</span><br><span class="line"> 6    Referer:http://www.imooc.com/</span><br><span class="line"> 7    Accept-Encoding:gzip, deflate, sdch</span><br><span class="line"> 8    Accept-Language:zh-CN,zh;q=0.8</span><br><span class="line"> 9    空行</span><br><span class="line">10    请求数据为空</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST:</span><br><span class="line">1    POST / HTTP1.1</span><br><span class="line">2    Host:www.wrox.com</span><br><span class="line">3    User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR          2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">4    Content-Type:application/x-www-form-urlencoded</span><br><span class="line">5    Content-Length:40</span><br><span class="line">6    Connection: Keep-Alive</span><br><span class="line">7    空行</span><br><span class="line">8    name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>

<ul>
<li>请求行：用来说明请求类型，要访问的资源以及使用的HTTP版本</li>
<li>请求头部：紧接着请求行之后的部分，用来说明服务器的附加信息：<ul>
<li>HOST，给出请求资源所在服务器的域名</li>
<li>User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器定义</li>
<li>Accept，说明用户代理可处理的媒体类型</li>
<li>Accept-Encoding，说明用户代理支持的内容编码</li>
<li>Accept-Language，说明用户代理能够处理的自然语言集</li>
<li>Content-Type，说明实现主体的媒体类型</li>
<li>Content-Length，说明实现主体的大小</li>
<li>Connection，连接管理，可以是Keep-Alive或close</li>
</ul>
</li>
<li>空行：请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须由空行</li>
<li>请求数据：也叫主体，可以添加任意的其他数据</li>
</ul>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>​    HTTP响应报文由四个部分组成，分别是<strong>状态行、消息报头、空行和响应正文</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1HTTP/1.1 200 OK</span><br><span class="line"> 2Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line"> 3Content-Type: text/html; charset=UTF-8</span><br><span class="line"> 4空行</span><br><span class="line"> 5&lt;html&gt;</span><br><span class="line"> 6      &lt;head&gt;&lt;/head&gt;</span><br><span class="line"> 7      &lt;body&gt;</span><br><span class="line"> 8            &lt;!--body goes here--&gt;</span><br><span class="line"> 9      &lt;/body&gt;</span><br><span class="line">10&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>状态行：由HTTP协议 状态码 状态消息 三部分组成</li>
<li>消息报头：用来说明客户端要使用的一些附加信息</li>
<li>空行：消息报头后面的空行是必须的</li>
<li>响应正文：服务器返回给客户端的文本信息，空行后面的html部分为响应正文</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>​    分为五类状态码：</p>
<ul>
<li>1xx：表示消息已接受，继续处理</li>
<li>2xx：成功，表示消息正常处理完毕<ul>
<li>200 OK：客户端请求被正常处理</li>
<li>206 Partial content：客户端进行了范围请求</li>
</ul>
</li>
<li>3xx：重定向<ul>
<li>301 Moved Permanently：永久重定向，资源已被永久转移到了新的位置，将来任何对资源的访问都要从本响应返回的URL中获得</li>
<li>302 Found：临时重定向，请求的资源现在临时从不同的URL中获得</li>
</ul>
</li>
<li>4xx：客户端错误<ul>
<li>400 Bad Request：请求报文存在语法错误</li>
<li>403 Forbidden：请求被服务器拒绝</li>
<li>404 Not Found：请求不存在，服务器上找不到请求资源</li>
</ul>
</li>
<li>5xx：服务端错误<ul>
<li>500 Internal Server Error：服务器在执行请求时出现错误</li>
</ul>
</li>
</ul>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul>
<li>GET主要用向服务器请求数据（查询&#x2F;获取数据）；POST主要用来向服务器上传数据（提交&#x2F;修改数据）</li>
<li>GET方法是显式传参，可以直接在URL上看到参数，以&#x2F;分割URL和传输的数据；POST是隐式传参，无法直接看到参数</li>
<li>GET请求会保留在浏览器历史记录中，会被浏览器主动缓存；而POST不会</li>
<li>GET有长度限制为2KB；POST没有</li>
<li>GET只支持ASCII字符，而POST没有限制</li>
<li>GET产生一个TCP数据包：浏览器会把http头部和数据一起发送过去，服务器响应200。POST产生两个TCP数据包：浏览器先发送http头部，告诉服务器我要传数据了，服务器响应100，然后浏览器再发送数据，服务器响应200。网络环境好的情况发送一次TCP包和两次TCP包的时间基本无差。</li>
</ul>
<h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><ul>
<li>cookie数据存放在浏览器上，session存放在服务器上</li>
<li>cookie不如session安全</li>
<li>单个cookie的限制是3K</li>
<li>session需要cookie的传递才有意义</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>​    死锁是两个或两个以上进程之间争夺共享资源而互相等待，如果没有外力则无法产生推进。产生的必要条件有四个：</p>
<ul>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ul>
<p>​    预防死锁的方法有：</p>
<ul>
<li>有序资源分配法</li>
<li>银行家算法：再分配资源前，判断系统是否是安全的；若是安全的才分配。每 分配一次资源就测试一次是否安全，而不是资源全部就位后才测试。</li>
</ul>
<h3 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h3><ul>
<li>管道pipe：数据只能一个方向流动，有固定的读写端，只能父子或兄弟进程间通信</li>
<li>命名管道fifo：和上面差不多，只是可以在非血缘关系进程间通信</li>
<li>信号：是一种异步通信的方式，开销小</li>
<li>消息队列：一个消息的列表，可以把消息看作一个记录，也分读写权限，随着内核持续</li>
<li>共享内存mmap：允许两个或多个进程共享物理内存中的同一块区域</li>
<li>内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就可以修改磁盘文件</li>
<li>信号量：主要解决进程和线程并发执行时的同步问题，对信号量进行P、V操作</li>
<li>socket套接字：完成不同网络中不同主机进程之间的通信</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li>进程是资源分配的最小单位；线程是程序执行的最小单元</li>
<li>因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</li>
<li>体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便</li>
<li>属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同的进程相互独立。</li>
<li>线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程</li>
</ul>
<h3 id="进程与线程选择的方法："><a href="#进程与线程选择的方法：" class="headerlink" title="进程与线程选择的方法："></a>进程与线程选择的方法：</h3><ul>
<li>频繁创建和销毁的优先使用线程，因为创建一个进程的代价比较大</li>
<li>线程的切换快，所以在需要大量计算、频繁切换时使用线程</li>
<li>并行操作时使用线程，并发响应客户的请求</li>
<li>需要安全稳定选择进程，需要速度选择线程</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>​     守护进程是一种特殊的进程(孤儿进程)，不受终端控制，守护进程的父进程为init进程。</p>
<h3 id="五种I-x2F-O模型是什么"><a href="#五种I-x2F-O模型是什么" class="headerlink" title="五种I&#x2F;O模型是什么"></a>五种I&#x2F;O模型是什么</h3><ul>
<li>阻塞I&#x2F;O：阻塞等待，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，直到数据就绪后才会继续执行</li>
<li>非阻塞I&#x2F;O：非阻塞等待，每隔一段时间去检查I&#x2F;O是否就绪，没有就继续做自己的事情。</li>
<li>信号驱动I&#x2F;O：内核建立信号的关联并设置回调，当内核有FD就绪时，会发出SIG信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待</li>
<li>I&#x2F;O复用：使用select&#x2F;poll&#x2F;epoll实现I&#x2F;O复用，这几个函数会使进程阻塞，这三个函数可以同时阻塞多个I&#x2F;O操作，而且可以同时对多个写、读I&#x2F;O事件进行检测，直到数据可读或可写时才进行I&#x2F;O操作</li>
<li>异步I&#x2F;O</li>
</ul>
<p>​    上述前四个都是同步I&#x2F;O。同步I&#x2F;O是指内核向应用程序通知的是就绪事件，要求用户代码自己执行I&#x2F;O操作；而异步指内核向应用程序通知的是完成事件，由内核完成I&#x2F;O操作</p>
<h3 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h3><ul>
<li>Reactor模式：主线程（I&#x2F;O单元）只负责监听文件描述符上是否有事件，有的话就通知工作线程（逻辑单元），读写数据、接受新连接及处理客户请求均在逻辑单元完成。通常由同步I&#x2F;O实现</li>
<li>Proactor模式：主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责逻辑处理，如处理客户请求。通常由异步I&#x2F;O实现</li>
</ul>
<h3 id="I-x2F-O处理与逻辑单元并发编程模式有哪几种？"><a href="#I-x2F-O处理与逻辑单元并发编程模式有哪几种？" class="headerlink" title="I&#x2F;O处理与逻辑单元并发编程模式有哪几种？"></a>I&#x2F;O处理与逻辑单元并发编程模式有哪几种？</h3><ul>
<li>半同步&#x2F;半异步模式<strong>：同步线程用来处理客户逻辑、异步线程用来处理I&#x2F;O事件</strong>异步线程监听到客户请求后，就将其封装成请求对象插入请求队列，请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象。他有一种变体：半同步&#x2F;半反应堆：<ul>
<li>半同步&#x2F;半反应堆：主线程充当异步线程，负责监听socket上的事件；若有新的请求来，主线程接受，得到新连接的socket，然后往epoll内核事件表中注册该socket的读写事件；如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装为请求对象插入到请求队列</li>
<li>所有工作线程睡眠在请求队列上，当有任务来了，通过竞争（如互斥锁）获得任务的接管权</li>
</ul>
</li>
<li>领导者&#x2F;追随者模式：多个工作线程轮流获得时间源集合，轮流监听、分发并处理事件的一种模式，在任意一个时间点，程序都只有一个领导者</li>
</ul>
<h3 id="池的相关概念"><a href="#池的相关概念" class="headerlink" title="池的相关概念"></a>池的相关概念</h3><ul>
<li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li>
<li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li>
<li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li>
<li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li>
</ul>
<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a>select、poll、epoll的区别</h3><table>
<thead>
<tr>
<th>系统调用</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td><strong>使用的方法</strong></td>
<td>一个1024大小的数组</td>
<td>一个自定义大小的集</td>
<td>红黑树</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>最大支持文件描述符数</strong></td>
<td>一般为1024</td>
<td>65355</td>
<td>65355</td>
</tr>
<tr>
<td><strong>工作模式</strong></td>
<td>LT</td>
<td>LT</td>
<td>LT&#x2F;ET</td>
</tr>
<tr>
<td><strong>内核实现和工作效率</strong></td>
<td>采用轮询方法检测就绪事件O(n)</td>
<td>采用轮询方法检测就绪事件O(n)</td>
<td>O(n)采用回调方法检测就绪事件O(1)</td>
</tr>
</tbody></table>
<ul>
<li>调用函数</li>
<li><ul>
<li>select和poll都是一个函数，epoll是一组函数</li>
</ul>
</li>
<li>文件描述符数量</li>
<li><ul>
<li>select通过线性表描述文件描述符集合，文件描述符有上限，一般是24，但可以修改源码，重新编译内核，不推荐<br>    - poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目<br>        - epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效</li>
</ul>
</li>
<li>将文件描述符从用户传给内核</li>
<li><ul>
<li>select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝<br>    - epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</li>
</ul>
</li>
<li>内核判断就绪的文件描述符</li>
<li>select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生<ul>
<li>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。</li>
<li>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</li>
</ul>
</li>
<li>应用程序索引就绪文件描述符</li>
<li>select&#x2F;poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历<br>  - epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</li>
<li>工作模式</li>
<li>select和poll都只能工作在相对低效的LT模式下<br>  - epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </li>
<li>应用场景</li>
<li>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll<ul>
<li>当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll</li>
<li>当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</li>
</ul>
</li>
</ul>
<h3 id="LT与ET的区别"><a href="#LT与ET的区别" class="headerlink" title="LT与ET的区别"></a>LT与ET的区别</h3><ul>
<li>LT：水平触发，效率低于ET。只要没有数据被获取，内核就会不断通知你，不用担心事件丢失问题</li>
<li>ET：边缘触发，在高并发、大流量下会少很多系统调用。一次事件只会触发一次，有变化才会被触发。</li>
<li>EPOLLONESHOT：一个线程读取某个socket开始处理数据，在处理过程中该socket上又有新的数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket；我们期望一个socket连接在任意一个时刻只被一个线程处理，通过epoll_ctl对该文件描述符注册EPOLLONESHOT事件，一个线程在处理这个socket时独占，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</li>
</ul>
<h3 id="为什么静态局部变量方法不用加锁？"><a href="#为什么静态局部变量方法不用加锁？" class="headerlink" title="为什么静态局部变量方法不用加锁？"></a>为什么静态局部变量方法不用加锁？</h3><p>​    因为static的特性，如果变量在初始化时，并发线程同时进入到static声明语句，并发线程会阻塞等待初始化结束，这样就可以保证在获取静态局部变量的过程一定是初始化后的，所以具有线程安全性，同时避免了new对象时指令重排序造成对象初始化不完全的现象。</p>
<h3 id="浏览器从输入URL开始到显示内容中间发生了什么"><a href="#浏览器从输入URL开始到显示内容中间发生了什么" class="headerlink" title="浏览器从输入URL开始到显示内容中间发生了什么"></a>浏览器从输入URL开始到显示内容中间发生了什么</h3><ol>
<li>输入url，按下enter</li>
<li>查看浏览器缓存中是否存在匹配的url，若有则直接显示内容，没有则下一步</li>
<li>进行域名解析，获得相应的ip地址</li>
<li>TCP三次握手建立连接</li>
<li>客户端发送HTTP请求报文获取服务器静态资源</li>
<li>服务器发送HTTP响应报文给客户端，客户端获得HTML代码</li>
<li>客户端解析HTML代码并请求HTML代码中的资源</li>
<li>浏览器渲染页面</li>
<li>TCP四次挥手关闭连接</li>
</ol>
<h3 id="网络编程的一般步骤"><a href="#网络编程的一般步骤" class="headerlink" title="网络编程的一般步骤"></a>网络编程的一般步骤</h3><p>​    TCP</p>
<ul>
<li>服务端：创建socket套接字-&gt;绑定端口bind-&gt;设置监听上限-&gt;接受连接请求accept，返回新的套接字-&gt;用返回的套接字进行recv&#x2F;send-&gt;关闭套接字</li>
<li>客户端：创建socket套接字-&gt;发起建立连接请求connect-&gt;recv&#x2F;send-&gt;关闭套接字</li>
</ul>
<p>​    UDP</p>
<ul>
<li>服务端：创建socket套接字-&gt;绑定端口bind-&gt;进行recvfrom&#x2F;sendto-&gt;关闭套接字</li>
<li>客户端：创建socket套接字-&gt;recvfrom&#x2F;sendto-&gt;关闭套接字</li>
</ul>
<h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><ul>
<li>孤儿进程一般是由于父进程退出后，他的子进程还在运行，那么这些子进程会成为孤儿进程，被1号进程init进程收养。</li>
<li>僵尸进程是由于子进程退出后父进程并没有及时回收它，那么子进程的描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。由于子进程结束后会向父进程发送SIGCHLD信号，所以要防止僵尸进程最好的办法就是让父进程建立一个捕获SIGCHLD的信号处理函数，在函数中调用wait或waitpid函数来回收它。</li>
</ul>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><ul>
<li>互斥锁</li>
<li>信号量：控制同时访问公共资源的线程数量，可以加一减一</li>
<li>条件变量</li>
</ul>
<h3 id="线程中的都有哪几种锁？"><a href="#线程中的都有哪几种锁？" class="headerlink" title="线程中的都有哪几种锁？"></a>线程中的都有哪几种锁？</h3><ul>
<li>互斥锁：避免多个线程在同一时刻同时操作一个共享资源</li>
<li>条件锁(条件变量)：未满足条件时，某个线程会阻塞，当满足时唤醒一个因该条件阻塞的线程，为了防止虚假唤醒，一般放在while循环中，并且通常搭配互斥锁使用</li>
<li>自旋锁：如果一个线程想要获得一个被使用的自旋锁，那么他会一直占用CPU请求这个自旋锁使得CPU不能去处理别的事情，直到获取这个锁为止</li>
<li>读写锁：读写锁在内部维护了一对相关的锁，一个用于只读的读锁，一个用于只写的写锁</li>
</ul>
<h3 id="什么是惊群效应？"><a href="#什么是惊群效应？" class="headerlink" title="什么是惊群效应？"></a>什么是惊群效应？</h3><p>​    惊群效应也有人叫做雷鸣群体效应，简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。</p>
<p>​    可以使用SO_REUSEPORT特性来解决惊群效应。该特性支持多个线程或进程绑定到同一个端口，提高服务区程序的性能，允许多个套接字bind()及listen()同一个TCP或UDP端口</p>
<h3 id="Webbench是什么，介绍一下原理？"><a href="#Webbench是什么，介绍一下原理？" class="headerlink" title="Webbench是什么，介绍一下原理？"></a>Webbench是什么，介绍一下原理？</h3><p>​    父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>​    线程分为用户态线程和内核态线程两种，协程的本质是处理自身挂起和恢复的用户态线程。协程的切换比线程的切换速度更快，在IO密集的情况下更适合。相比于函数，协程最大的特点就是支持挂起&#x2F;恢复。</p>
<p>​    按照是否开辟相应的调用栈，协程分为以下两类：</p>
<ul>
<li>有栈协程：每个协程都有自己的调用栈，类似于线程的调用栈</li>
<li>无栈协程：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法实现</li>
</ul>
<h4 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h4><p>​    有栈协程会改变函数调用栈，在内存中给每一个协程开辟一个栈空间（存放在堆中），当协程挂起时将他的运行时上下文（即栈空间）从系统栈保存至所分派的栈内存中，当携程恢复时将其运行时上下文从栈内存恢复到系统栈中；他可以在任意函数调用层级的位置进行挂起，并转移调度权。</p>
<h4 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h4><p>​    基于状态机的无栈协程解决方案一般是通过状态机记录上次挂起时的位置，并基于此决定恢复时开始执行的位置，这个状态必须存储在栈以外的地方，从而避免状态和栈一同销毁。</p>
<p>​    相比有栈协程，无栈协程不需要修改调用栈，也无需额外内存保存调用栈，开销更小，但是无栈协程的限制比较多，最大的问题就是他无法在任意函数调用层级的位置进行挂起。</p>
<h3 id="Linux提供的定时方法"><a href="#Linux提供的定时方法" class="headerlink" title="Linux提供的定时方法"></a>Linux提供的定时方法</h3><ul>
<li>socket的选项SO_RECVTIMEO和SO_SNDTIMEO</li>
<li>SIGALRM信号</li>
<li>I&#x2F;O复用系统调用超时参数</li>
</ul>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>​    TCP&#x2F;TP规定数据流采用大端字节序，即低地址高字节，但是很多设备都是采用小端字节序存储，二者之间通信时需要对数据进行转换，可以调用一下库函数进行网络字节序和主机字节序的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><img src="/2023/04/20/knowledge-summarize/image-20230115205049489.png" class="">

<p>​    刚开始都是关闭，客户端主动打开，服务器被动打开进入LISTEN状态</p>
<ul>
<li>第一次握手：客户端打开连接，向服务器发送SYN&#x3D;1的请求报文，seq&#x3D;x，此后客户端处于SYN_SENT状态</li>
<li>第二次握手：服务器返回一个SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1的应答报文，此后服务器后处于SYN-RCVD状态，TCP处于半连接状态</li>
<li>第三次握手：客户端返回一个ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1的报文，此时处于established状态，客户端接收到报文后也处于established状态</li>
</ul>
<h3 id="为什么要三次握手？两次握手行不行？"><a href="#为什么要三次握手？两次握手行不行？" class="headerlink" title="为什么要三次握手？两次握手行不行？"></a>为什么要三次握手？两次握手行不行？</h3><ul>
<li>需要让服务端得知客户端的接受、发送能力正常，服务端自己的接受发送能力正常</li>
<li>如果没有第三次握手告诉服务端：客户端已经收到数据，那么服务端的端口会一直开着，等到客户端因超时重新发送请求时，服务端会再开一个端口连接，久而久之就会造成服务端资源的浪费；三次握手会避免服务端资源的浪费</li>
<li>三次握手还会避免历史连接问题，在服务端建立连接前阻止掉历史连接</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="/2023/04/20/knowledge-summarize/image-20230116151620627.png" class="">

<ul>
<li>客户端想要关闭连接，向服务器发送一个FIN&#x3D;1报文，seq&#x3D;u，然后进入FIN-WAIT1状态</li>
<li>服务器收到客户端发来的FIN报文后，向客户端发送ACK确认报文，此后服务端处于CLOSE-WAIT状态，TCP处在半关闭状态，客户端到服务器的连接释放，客户端进行FIN-WIAT2状态，等待服务器的连接释放报文</li>
<li>服务器向客户端发送FIN&#x3D;1，ACK&#x3D;1的报文，服务器进入LAST-ACK状态</li>
<li>客户端收到服务器的FIN报文，向服务器发送一个ACK报文，此时客户端处于TIME-WAIT状态，需要过2MSL时间后，以保证客户端接收到了自己发送的ACK报文再进入CLOSED状态；服务器接收到客户端发的ACK后彻底CLOSED状态</li>
</ul>
<h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h3><p>​    因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h3 id="为什么要TIME-WAIT？"><a href="#为什么要TIME-WAIT？" class="headerlink" title="为什么要TIME-WAIT？"></a>为什么要TIME-WAIT？</h3><p>​    客户端需要让服务器确保收到自己的ACK报文后再关闭，没有收到的话，服务器会重新发送FIN报文给客户端，然后客户端就知道之前的没有送到，重新发送一个ACK报文。TIME-WAIT的时间至少是一个报文来回的时间。</p>
<h3 id="TCP保持有效传输拥塞避免的方法"><a href="#TCP保持有效传输拥塞避免的方法" class="headerlink" title="TCP保持有效传输拥塞避免的方法"></a>TCP保持有效传输拥塞避免的方法</h3><p>​    采用拥塞控制：</p>
<ul>
<li>慢开始：开始传输先设施一个较低的窗口值cwnd，并且设置一个慢启动阈值，每过一轮RTT（收发时延），就将窗口扩大一倍，直到达到阈值，改为拥塞避免算法</li>
<li>拥塞避免：让拥塞窗口cwnd缓慢增大，一个往返时间就把发送方的窗口+1</li>
<li>快重传：发送端收到了3个重复的ACK报文，说明发生了丢包，接收端就会立刻发送对方尚未接收的报文段</li>
<li>快恢复：发送端收到了3个重复的ACK报文，说明发生了丢包，就进入快恢复阶段：将拥塞窗口阈值降到现在的一半，然后大小变为当前的阈值，然后再线性增加适应</li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>​    TCP 利用滑动窗口实现流量控制的机制。滑动窗口的大小意味着接收方还有多大的缓冲区可以用来接收数据，发送方可以通过滑动窗口大小确定发多少数据，当窗口为0时，发送方一般不发送数据；除非是紧急数据或是发送一个1字节的数据报来通知接收方重新声明它希望接受的下一字节及滑动窗口大小。</p>
<h3 id="DNS解析的过程"><a href="#DNS解析的过程" class="headerlink" title="DNS解析的过程"></a>DNS解析的过程</h3><ul>
<li>主机向本地域名服务器的查询一般采用递归查询：如果主机所询问的本地域名服务器不知道被查寻的域名IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器发出请求查询报文（替主机查询），而不是让主机进行下一步查询。因此递归查询的结果要么就是查寻得IP地址，要么就报错。</li>
<li>本地域名服务器向根域名服务器的查询为迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所查询的IP地址，要么就告诉本地服务器你应该下一步去哪个域名服务器查询，让本地自己去查。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</li>
</ul>
<h3 id="OSI七层协议与四层-x2F-五层模型"><a href="#OSI七层协议与四层-x2F-五层模型" class="headerlink" title="OSI七层协议与四层&#x2F;五层模型"></a>OSI七层协议与四层&#x2F;五层模型</h3><img src="/2023/04/20/knowledge-summarize/tcpip.png" class="">

<ul>
<li>应用层：负责给应用程序统一的接口，为应用程序提供交互服务</li>
<li>表示层：负责把数据转换成兼容另一个系统能识别的格式</li>
<li>会话层：负责建立、管理、终止表示层实体之间的通信会话</li>
<li>传输层：负责端到端的数据传输，主要有TCP和UDP两种协议</li>
<li>网络层：定义IP地址，定义路由基本功能（包），负责数据的路由、转发、分片</li>
<li>数据链路层：负责封装成帧、差错检测</li>
<li>物理层：负责底层数据的透明传输（比特流）</li>
</ul>
<p>​    <strong>四层&#x2F;五层模型是一个实现的应用模型，由7层简化而来</strong></p>
<ul>
<li>应用层：负责向用户提供一组应用程序，如HTTP、DNS、FTP等</li>
<li>传输层：负责端到端的通信，比如TCP、UDP等</li>
<li>网络层：负责网络包的封装、分片、路由，比如IP，ICMP等</li>
<li>(四层)网络接口层：负责物理网络中的传输，封装成帧、差错寻址以及网卡传输网络<ul>
<li>(五层)数据链路层：封装成帧、差错检测</li>
<li>(五层)物理层：传输比特流</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>stl</tag>
        <tag>数据库</tag>
        <tag>网络编程</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>BlendMask代码详解</title>
    <url>/2023/04/24/BlendMask%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="BlendMask代码详解"><a href="#BlendMask代码详解" class="headerlink" title="BlendMask代码详解"></a>BlendMask代码详解</h1><p>​    以下代码出自官方AdelaiDet，添加了注释方便阅读理解，BlendMask代码主要包含以下三个文件：</p>
<ul>
<li>blendmask.py</li>
<li>blender.py</li>
<li>basis_module.py</li>
</ul>
<h2 id="AdelaiDet-x2F-adet-x2F-modeling-x2F-blendmask-x2F-blendmask-py"><a href="#AdelaiDet-x2F-adet-x2F-modeling-x2F-blendmask-x2F-blendmask-py" class="headerlink" title="AdelaiDet&#x2F;adet&#x2F;modeling&#x2F;blendmask&#x2F;blendmask.py"></a>AdelaiDet&#x2F;adet&#x2F;modeling&#x2F;blendmask&#x2F;blendmask.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron2.structures <span class="keyword">import</span> ImageList</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.postprocessing <span class="keyword">import</span> detector_postprocess, sem_seg_postprocess</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.proposal_generator <span class="keyword">import</span> build_proposal_generator</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.backbone <span class="keyword">import</span> build_backbone</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.meta_arch.panoptic_fpn <span class="keyword">import</span> combine_semantic_and_instance_outputs</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.meta_arch.build <span class="keyword">import</span> META_ARCH_REGISTRY</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.meta_arch.semantic_seg <span class="keyword">import</span> build_sem_seg_head</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .blender <span class="keyword">import</span> build_blender</span><br><span class="line"><span class="keyword">from</span> .basis_module <span class="keyword">import</span> build_basis_module</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&quot;BlendMask&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试用</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@META_ARCH_REGISTRY.register()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlendMask</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Main class for BlendMask architectures (see https://arxiv.org/abd/1901.02446).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cfg</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.device = torch.device(cfg.MODEL.DEVICE)</span><br><span class="line">        self.instance_loss_weight = cfg.MODEL.BLENDMASK.INSTANCE_LOSS_WEIGHT</span><br><span class="line"></span><br><span class="line">        self.backbone = build_backbone(cfg)  <span class="comment"># 骨干网络</span></span><br><span class="line">        self.proposal_generator = build_proposal_generator(cfg, self.backbone.output_shape())</span><br><span class="line">        self.blender = build_blender(cfg)</span><br><span class="line">        self.basis_module = build_basis_module(cfg, self.backbone.output_shape())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># options when combining instance &amp; semantic outputs</span></span><br><span class="line">        self.combine_on = cfg.MODEL.PANOPTIC_FPN.COMBINE.ENABLED</span><br><span class="line">        <span class="keyword">if</span> self.combine_on:</span><br><span class="line">            self.panoptic_module = build_sem_seg_head(cfg, self.backbone.output_shape())</span><br><span class="line">            self.combine_overlap_threshold = cfg.MODEL.PANOPTIC_FPN.COMBINE.OVERLAP_THRESH</span><br><span class="line">            self.combine_stuff_area_limit = cfg.MODEL.PANOPTIC_FPN.COMBINE.STUFF_AREA_LIMIT</span><br><span class="line">            self.combine_instances_confidence_threshold = (</span><br><span class="line">                cfg.MODEL.PANOPTIC_FPN.COMBINE.INSTANCES_CONFIDENCE_THRESH)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># build top module</span></span><br><span class="line">        <span class="comment"># 下面的内容在你训练输出的文件夹中的log.txt都能查到</span></span><br><span class="line">        in_channels = cfg.MODEL.FPN.OUT_CHANNELS  <span class="comment"># FPN为256</span></span><br><span class="line">        num_bases = cfg.MODEL.BASIS_MODULE.NUM_BASES  <span class="comment"># 26</span></span><br><span class="line">        attn_size = cfg.MODEL.BLENDMASK.ATTN_SIZE  <span class="comment"># 14</span></span><br><span class="line">        attn_len = num_bases * attn_size * attn_size  <span class="comment"># K*M*M</span></span><br><span class="line">        self.top_layer = nn.Conv2d(</span><br><span class="line">            in_channels, attn_len,</span><br><span class="line">            kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">        torch.nn.init.normal_(self.top_layer.weight, std=<span class="number">0.01</span>)</span><br><span class="line">        torch.nn.init.constant_(self.top_layer.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        pixel_mean = torch.Tensor(cfg.MODEL.PIXEL_MEAN).to(self.device).view(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        pixel_std = torch.Tensor(cfg.MODEL.PIXEL_STD).to(self.device).view(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.normalizer = <span class="keyword">lambda</span> x: (x - pixel_mean) / pixel_std</span><br><span class="line">        self.to(self.device)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, batched_inputs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            batched_inputs: a list, batched outputs of :class:`DatasetMapper`.</span></span><br><span class="line"><span class="string">                Each item in the list contains the inputs for one image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        For now, each item in the list is a dict that contains:</span></span><br><span class="line"><span class="string">            image: Tensor, image in (C, H, W) format.</span></span><br><span class="line"><span class="string">            instances: Instances</span></span><br><span class="line"><span class="string">            sem_seg: semantic segmentation ground truth.</span></span><br><span class="line"><span class="string">            Other information that&#x27;s included in the original dicts, such as:</span></span><br><span class="line"><span class="string">                &quot;height&quot;, &quot;width&quot; (int): the output resolution of the model, used in inference.</span></span><br><span class="line"><span class="string">                    See :meth:`postprocess` for details.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            list[dict]: each dict is the results for one image. The dict</span></span><br><span class="line"><span class="string">                contains the following keys:</span></span><br><span class="line"><span class="string">                &quot;instances&quot;: see :meth:`GeneralizedRCNN.forward` for its format.</span></span><br><span class="line"><span class="string">                &quot;sem_seg&quot;: see :meth:`SemanticSegmentor.forward` for its format.</span></span><br><span class="line"><span class="string">                &quot;panoptic_seg&quot;: available when `PANOPTIC_FPN.COMBINE.ENABLED`.</span></span><br><span class="line"><span class="string">                    See the return value of</span></span><br><span class="line"><span class="string">                    :func:`combine_semantic_and_instance_outputs` for its format.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        images = [x[<span class="string">&quot;image&quot;</span>].to(self.device) <span class="keyword">for</span> x <span class="keyword">in</span> batched_inputs]</span><br><span class="line">        images = [self.normalizer(x) <span class="keyword">for</span> x <span class="keyword">in</span> images]  <span class="comment"># 正则化</span></span><br><span class="line">        images = ImageList.from_tensors(images, self.backbone.size_divisibility)</span><br><span class="line">        features = self.backbone(images.tensor)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        (Pbd) features.keys()</span></span><br><span class="line"><span class="string">        dict_keys([&#x27;p3&#x27;, &#x27;p4&#x27;, &#x27;p5&#x27;, &#x27;p6&#x27;, &#x27;p7&#x27;])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.combine_on:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;sem_seg&quot;</span> <span class="keyword">in</span> batched_inputs[<span class="number">0</span>]:</span><br><span class="line">                gt_sem = [x[<span class="string">&quot;sem_seg&quot;</span>].to(self.device) <span class="keyword">for</span> x <span class="keyword">in</span> batched_inputs]</span><br><span class="line">                gt_sem = ImageList.from_tensors(</span><br><span class="line">                    gt_sem, self.backbone.size_divisibility, self.panoptic_module.ignore_value</span><br><span class="line">                ).tensor</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                gt_sem = <span class="literal">None</span></span><br><span class="line">            sem_seg_results, sem_seg_losses = self.panoptic_module(features, gt_sem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;basis_sem&quot;</span> <span class="keyword">in</span> batched_inputs[<span class="number">0</span>]:</span><br><span class="line">            basis_sem = [x[<span class="string">&quot;basis_sem&quot;</span>].to(self.device) <span class="keyword">for</span> x <span class="keyword">in</span> batched_inputs]</span><br><span class="line">            basis_sem = ImageList.from_tensors(</span><br><span class="line">                basis_sem, self.backbone.size_divisibility, <span class="number">0</span>).tensor</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            basis_sem = <span class="literal">None</span></span><br><span class="line">        basis_out, basis_losses = self.basis_module(features, basis_sem)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        (Pdb) basis_losses</span></span><br><span class="line"><span class="string">        &#123;&#x27;loss_basis_sem&#x27;: tensor(1.3870, device=&#x27;cuda:0&#x27;, grad_fn=&lt;MulBackward0&gt;)&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;instances&quot;</span> <span class="keyword">in</span> batched_inputs[<span class="number">0</span>]:</span><br><span class="line">            gt_instances = [x[<span class="string">&quot;instances&quot;</span>].to(self.device) <span class="keyword">for</span> x <span class="keyword">in</span> batched_inputs]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gt_instances = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 对应fcos_outputs.py 的444行 self.top_layer不参与fcos原本的分支以及loss计算，只是多加了一个维度的变换。 256 --&gt; 784</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        (Pdb) proposal_losses</span></span><br><span class="line"><span class="string">        &#123;&#x27;loss_fcos_cls&#x27;: tensor(1.2077, device=&#x27;cuda:0&#x27;, grad_fn=&lt;MulBackward0&gt;), </span></span><br><span class="line"><span class="string">         &#x27;loss_fcos_loc&#x27;: tensor(0.9512, device=&#x27;cuda:0&#x27;, grad_fn=&lt;DivBackward0&gt;), </span></span><br><span class="line"><span class="string">         &#x27;loss_fcos_ctr&#x27;: tensor(0.7081, device=&#x27;cuda:0&#x27;, grad_fn=&lt;DivBackward0&gt;)&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        proposals, proposal_losses = self.proposal_generator(</span><br><span class="line">            images, features, gt_instances, self.top_layer)</span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        (Pdb) detector_losses</span></span><br><span class="line"><span class="string">        &#123;&#x27;loss_mask&#x27;: tensor(0.6993, device=&#x27;cuda:0&#x27;, grad_fn=&lt;DivBackward0&gt;)&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        detector_results, detector_losses = self.blender(  <span class="comment"># 调用了__call__方法</span></span><br><span class="line">            basis_out[<span class="string">&quot;bases&quot;</span>], proposals, gt_instances)</span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.training:</span><br><span class="line">            losses = &#123;&#125;</span><br><span class="line">            losses.update(basis_losses)</span><br><span class="line">            losses.update(&#123;k: v * self.instance_loss_weight <span class="keyword">for</span> k, v <span class="keyword">in</span> detector_losses.items()&#125;)</span><br><span class="line">            losses.update(proposal_losses)</span><br><span class="line">            <span class="keyword">if</span> self.combine_on:</span><br><span class="line">                losses.update(sem_seg_losses)</span><br><span class="line">            <span class="keyword">return</span> losses</span><br><span class="line"></span><br><span class="line">        processed_results = []</span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line">        <span class="keyword">for</span> i, (detector_result, input_per_image, image_size) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(</span><br><span class="line">                detector_results, batched_inputs, images.image_sizes)):</span><br><span class="line">            height = input_per_image.get(<span class="string">&quot;height&quot;</span>, image_size[<span class="number">0</span>])</span><br><span class="line">            width = input_per_image.get(<span class="string">&quot;width&quot;</span>, image_size[<span class="number">1</span>])</span><br><span class="line">            detector_r = detector_postprocess(detector_result, height, width)</span><br><span class="line">            processed_result = &#123;<span class="string">&quot;instances&quot;</span>: detector_r&#125;</span><br><span class="line">            <span class="keyword">if</span> self.combine_on:</span><br><span class="line">                sem_seg_r = sem_seg_postprocess(</span><br><span class="line">                    sem_seg_results[i], image_size, height, width)</span><br><span class="line">                processed_result[<span class="string">&quot;sem_seg&quot;</span>] = sem_seg_r</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;seg_thing_out&quot;</span> <span class="keyword">in</span> basis_out:</span><br><span class="line">                seg_thing_r = sem_seg_postprocess(</span><br><span class="line">                    basis_out[<span class="string">&quot;seg_thing_out&quot;</span>], image_size, height, width)</span><br><span class="line">                processed_result[<span class="string">&quot;sem_thing_seg&quot;</span>] = seg_thing_r</span><br><span class="line">            <span class="keyword">if</span> self.basis_module.visualize:</span><br><span class="line">                processed_result[<span class="string">&quot;bases&quot;</span>] = basis_out[<span class="string">&quot;bases&quot;</span>]</span><br><span class="line">            processed_results.append(processed_result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.combine_on:</span><br><span class="line">                panoptic_r = combine_semantic_and_instance_outputs(</span><br><span class="line">                    detector_r,</span><br><span class="line">                    sem_seg_r.argmax(dim=<span class="number">0</span>),</span><br><span class="line">                    self.combine_overlap_threshold,</span><br><span class="line">                    self.combine_stuff_area_limit,</span><br><span class="line">                    self.combine_instances_confidence_threshold)</span><br><span class="line">                processed_results[-<span class="number">1</span>][<span class="string">&quot;panoptic_seg&quot;</span>] = panoptic_r</span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line">        <span class="keyword">return</span> processed_results</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">(Pdb) batched_inputs[0]</span></span><br><span class="line"><span class="string">&#123;&#x27;file_name&#x27;: &#x27;/mnt/big_disk/big_disk_1/zhuzhibo/download/AdelaiDet/datasets/handwritten_chinese_stroke_2021/train2021/HandwrittenChineseStroke_train_0000028734.jpg&#x27;, &#x27;height&#x27;: 77, &#x27;width&#x27;: 47, &#x27;image_id&#x27;: 6569, &#x27;image&#x27;: tensor(</span></span><br><span class="line"><span class="string">       [[[252, 253, 254,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [252, 253, 254,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [252, 253, 255,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         ...,</span></span><br><span class="line"><span class="string">         [255, 235, 199,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [255, 247, 234,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [255, 254, 253,  ..., 255, 255, 255]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[252, 253, 254,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [252, 253, 254,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [252, 253, 255,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         ...,</span></span><br><span class="line"><span class="string">         [255, 235, 199,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [255, 247, 234,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [255, 254, 253,  ..., 255, 255, 255]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[252, 253, 254,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [252, 253, 254,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [252, 253, 255,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         ...,</span></span><br><span class="line"><span class="string">         [255, 235, 199,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [255, 247, 234,  ..., 255, 255, 255],</span></span><br><span class="line"><span class="string">         [255, 254, 253,  ..., 255, 255, 255]]], dtype=torch.uint8), &#x27;instances&#x27;: Instances(num_instances=9, image_height=144, image_width=88, fields=[gt_boxes: Boxes(tensor(</span></span><br><span class="line"><span class="string">       [[ 41.0402,   0.0000,  88.0000,  52.9219],</span></span><br><span class="line"><span class="string">        [ 48.8080,  26.3713,  75.8560,  82.4046],</span></span><br><span class="line"><span class="string">        [ 36.6902,  28.8540,  57.2133,  70.4563],</span></span><br><span class="line"><span class="string">        [  0.0000,   5.1126,  44.1634,  66.7322],</span></span><br><span class="line"><span class="string">        [ 15.7172,  20.0092,  34.6867,  64.0943],</span></span><br><span class="line"><span class="string">        [ 56.4204,  80.8368,  76.4774, 127.8701],</span></span><br><span class="line"><span class="string">        [  8.2601,  61.4402,  59.2329, 126.1632],</span></span><br><span class="line"><span class="string">        [ 29.2331,  80.9919,  52.5526, 129.2667],</span></span><br><span class="line"><span class="string">        [  0.0000, 105.6644,  39.9688, 144.0000]])), gt_classes: tensor([ 3, 23, 17, 14,  3, 18,  8,  3, 17]), gt_masks: PolygonMasks(num_instances=9)]), &#x27;basis_sem&#x27;: tensor(</span></span><br><span class="line"><span class="string">       [[ 0,  0,  0,  ...,  0,  0,  0],</span></span><br><span class="line"><span class="string">        [ 0,  0,  0,  ...,  0,  0,  0],</span></span><br><span class="line"><span class="string">        [ 0,  0,  0,  ...,  0,  0,  0],</span></span><br><span class="line"><span class="string">        ...,</span></span><br><span class="line"><span class="string">        [ 0,  0, 18,  ...,  0,  0,  0],</span></span><br><span class="line"><span class="string">        [ 0,  0, 18,  ...,  0,  0,  0],</span></span><br><span class="line"><span class="string">        [ 0,  0, 18,  ...,  0,  0,  0]])&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="AdelaiDet-x2F-adet-x2F-modeling-x2F-blendmask-x2F-blender-py"><a href="#AdelaiDet-x2F-adet-x2F-modeling-x2F-blendmask-x2F-blender-py" class="headerlink" title="AdelaiDet&#x2F;adet&#x2F;modeling&#x2F;blendmask&#x2F;blender.py"></a>AdelaiDet&#x2F;adet&#x2F;modeling&#x2F;blendmask&#x2F;blender.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron2.layers <span class="keyword">import</span> cat</span><br><span class="line"><span class="keyword">from</span> detectron2.modeling.poolers <span class="keyword">import</span> ROIPooler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_blender</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">return</span> Blender(cfg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试用</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blender</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cfg</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># fmt: off</span></span><br><span class="line">        <span class="comment"># 以下内容在训练输出的文件夹中的log.txt都能找到</span></span><br><span class="line">        self.pooler_resolution = cfg.MODEL.BLENDMASK.BOTTOM_RESOLUTION     <span class="comment"># 56</span></span><br><span class="line">        sampling_ratio         = cfg.MODEL.BLENDMASK.POOLER_SAMPLING_RATIO <span class="comment"># 1</span></span><br><span class="line">        pooler_type            = cfg.MODEL.BLENDMASK.POOLER_TYPE           <span class="comment"># &#x27;ROIAlignV2&#x27;</span></span><br><span class="line">        pooler_scales          = cfg.MODEL.BLENDMASK.POOLER_SCALES         <span class="comment"># (0.25,)</span></span><br><span class="line">        self.attn_size         = cfg.MODEL.BLENDMASK.ATTN_SIZE             <span class="comment"># 14</span></span><br><span class="line">        self.top_interp        = cfg.MODEL.BLENDMASK.TOP_INTERP            <span class="comment"># &#x27;bililnear&#x27;</span></span><br><span class="line">        num_bases              = cfg.MODEL.BASIS_MODULE.NUM_BASES          <span class="comment"># 4</span></span><br><span class="line">        <span class="comment"># fmt: on</span></span><br><span class="line"></span><br><span class="line">        self.attn_len = num_bases * self.attn_size * self.attn_size  <span class="comment"># 14*14*4 = 784</span></span><br><span class="line"></span><br><span class="line">        self.pooler = ROIPooler(</span><br><span class="line">            output_size=self.pooler_resolution,</span><br><span class="line">            scales=pooler_scales,</span><br><span class="line">            sampling_ratio=sampling_ratio,</span><br><span class="line">            pooler_type=pooler_type,</span><br><span class="line">            canonical_level=<span class="number">2</span>)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        (Pdb) self.pooler</span></span><br><span class="line"><span class="string">        ROIPooler(</span></span><br><span class="line"><span class="string">            (level_poolers): ModuleList(</span></span><br><span class="line"><span class="string">                (0): ROIAlign(output_size=(56, 56), spatial_scale=0.25, sampling_ratio=1, aligned=True)</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, bases, proposals, gt_instances</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        gt_instances表示batch_size上的gt实例</span></span><br><span class="line"><span class="string">        len(gt_instances) = 64 (因为我的batchsize为64)</span></span><br><span class="line"><span class="string">        gt_instances[0]就表示第0个batch上的图片的gt实例信息</span></span><br><span class="line"><span class="string">        (Pdb) gt_instances[0]</span></span><br><span class="line"><span class="string">        Instances(num_instances=5, image_height=144, image_width=112, fields=[gt_boxes: Boxes(tensor([[  0.0000,   0.0000,  38.6394,  55.8094],</span></span><br><span class="line"><span class="string">            [ 14.5582,   6.7498,  86.0460,  82.6530],</span></span><br><span class="line"><span class="string">            [ 19.5723,  46.5602, 112.0000,  69.2312],</span></span><br><span class="line"><span class="string">            [ 34.3869,  64.0956, 108.8377, 144.0000],</span></span><br><span class="line"><span class="string">            [ 23.9028,  59.5271,  84.4506, 135.4303]], device=&#x27;cuda:0&#x27;)), gt_classes: tensor([ 3, 15,  1, 14,  3], device=&#x27;cuda:0&#x27;), gt_masks: PolygonMasks(num_instances=5)])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> gt_instances <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># training</span></span><br><span class="line">            <span class="comment"># reshape attns</span></span><br><span class="line">            dense_info = proposals[<span class="string">&quot;instances&quot;</span>]  <span class="comment"># 我这里是3473个instance</span></span><br><span class="line">            attns = dense_info.top_feats  <span class="comment"># attns.shape = [instances, 784]</span></span><br><span class="line">            pos_inds = dense_info.pos_inds  <span class="comment"># pos_inds.shape = [instances] :正样本的数量 pos_ind表示所有FPN层的像素点加起来的某些正样本的点</span></span><br><span class="line">            <span class="keyword">if</span> pos_inds.numel() == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>, &#123;<span class="string">&quot;loss_mask&quot;</span>: <span class="built_in">sum</span>([x.<span class="built_in">sum</span>() * <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> attns]) + bases[<span class="number">0</span>].<span class="built_in">sum</span>() * <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">            gt_inds = dense_info.gt_inds  <span class="comment"># gt_inds.shape = [instances] :对应pos_inds位置上的类别</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 1.这里表示 RoIPool r_d = RoIPool(B, p_d)</span></span><br><span class="line">            rois = self.pooler(bases, [x.gt_boxes <span class="keyword">for</span> x <span class="keyword">in</span> gt_instances])</span><br><span class="line">            rois = rois[gt_inds]   <span class="comment"># rois.shape = [instances, num_bases, 56, 56],根据gt_inds上的值进行复制</span></span><br><span class="line">            pred_mask_logits = self.merge_bases(rois, attns)  <span class="comment"># pred_mask_logits.shape = [instances, 56*56]</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># gen targets</span></span><br><span class="line">            gt_masks = []</span><br><span class="line">            <span class="comment"># 遍历每个图片的实例信息</span></span><br><span class="line">            <span class="keyword">for</span> instances_per_image <span class="keyword">in</span> gt_instances:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(instances_per_image.gt_boxes.tensor) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># crop到56*56 gt_mask_per_image.shape = [7(这张图包含的实例个数), 56, 56]</span></span><br><span class="line">                gt_mask_per_image = instances_per_image.gt_masks.crop_and_resize(</span><br><span class="line">                    instances_per_image.gt_boxes.tensor, self.pooler_resolution</span><br><span class="line">                ).to(device=pred_mask_logits.device)</span><br><span class="line">                gt_masks.append(gt_mask_per_image)</span><br><span class="line">            gt_masks = cat(gt_masks, dim=<span class="number">0</span>) <span class="comment"># gt_masks.shape = [484, 56, 56]</span></span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line">            gt_masks = gt_masks[gt_inds]  <span class="comment"># gt_masks.shape = [3473, 56, 56] 3473为总共的实例数</span></span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line">            N = gt_masks.size(<span class="number">0</span>)</span><br><span class="line">            gt_masks = gt_masks.view(N, -<span class="number">1</span>)  <span class="comment"># gt_masks.shape = [3473, 56*56]</span></span><br><span class="line"></span><br><span class="line">            gt_ctr = dense_info.gt_ctrs  <span class="comment"># gt_ctr.shape = [3473]</span></span><br><span class="line">            loss_denorm = proposals[<span class="string">&quot;loss_denorm&quot;</span>]  <span class="comment"># loss_denorm = ctrness_targets.sum()</span></span><br><span class="line">            <span class="comment"># mask BCE loss [3473, 56*56]</span></span><br><span class="line">            <span class="comment"># F.binary_cross_entropy_with_logits等价于torch.nn.BCEWithLogitsLoss,reduction=&quot;none&quot;表示逐个元素相加、reduction=&quot;sum&quot;为所有元素求和</span></span><br><span class="line">            mask_losses = F.binary_cross_entropy_with_logits(</span><br><span class="line">                pred_mask_logits, gt_masks.to(dtype=torch.float32), reduction=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">            mask_loss = ((mask_losses.mean(dim=-<span class="number">1</span>) * gt_ctr).<span class="built_in">sum</span>()</span><br><span class="line">                         / loss_denorm)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, &#123;<span class="string">&quot;loss_mask&quot;</span>: mask_loss&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># no proposals</span></span><br><span class="line">            total_instances = <span class="built_in">sum</span>([<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> proposals])</span><br><span class="line">            <span class="keyword">if</span> total_instances == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># add empty pred_masks results</span></span><br><span class="line">                <span class="keyword">for</span> box <span class="keyword">in</span> proposals:</span><br><span class="line">                    box.pred_masks = box.pred_classes.view(</span><br><span class="line">                        -<span class="number">1</span>, <span class="number">1</span>, self.pooler_resolution, self.pooler_resolution)</span><br><span class="line">                <span class="keyword">return</span> proposals, &#123;&#125;</span><br><span class="line">            rois = self.pooler(bases, [x.pred_boxes <span class="keyword">for</span> x <span class="keyword">in</span> proposals])</span><br><span class="line">            attns = cat([x.top_feat <span class="keyword">for</span> x <span class="keyword">in</span> proposals], dim=<span class="number">0</span>)</span><br><span class="line">            pred_mask_logits = self.merge_bases(rois, attns).sigmoid()</span><br><span class="line">            pred_mask_logits = pred_mask_logits.view(</span><br><span class="line">                -<span class="number">1</span>, <span class="number">1</span>, self.pooler_resolution, self.pooler_resolution)</span><br><span class="line">            start_ind = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> box <span class="keyword">in</span> proposals:</span><br><span class="line">                end_ind = start_ind + <span class="built_in">len</span>(box)</span><br><span class="line">                box.pred_masks = pred_mask_logits[start_ind:end_ind]</span><br><span class="line">                start_ind = end_ind</span><br><span class="line">            <span class="keyword">return</span> proposals, &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 融合部分    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_bases</span>(<span class="params">self, rois, coeffs, location_to_inds=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># merge predictions</span></span><br><span class="line">        <span class="comment"># 输入的coeffss = [instances=3473, attn_len=784]</span></span><br><span class="line">        N = coeffs.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> location_to_inds <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            rois = rois[location_to_inds]</span><br><span class="line">        N, B, H, W = rois.size()</span><br><span class="line"></span><br><span class="line">        coeffs = coeffs.view(N, -<span class="number">1</span>, self.attn_size, self.attn_size)  <span class="comment"># [instances, -1, M, M] --&gt; [instances, nums_bases, 14, 14]</span></span><br><span class="line">        <span class="comment"># 2. 对应 a&#x27;d = interpolate_(M x M) --&gt; (R x R)(a_d)  Sd = softmax(a&#x27;d)</span></span><br><span class="line">        <span class="comment"># S_d = softmax(a&#x27;_d) 在通道上对每一个元素做softmax。此处也就是对于4个元素。  # [instances, 4, 14, 14] --&gt; [instances, 4, 56, 56]</span></span><br><span class="line">        coeffs = F.interpolate(coeffs, (H, W),</span><br><span class="line">                               mode=self.top_interp).softmax(dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 3.对应 m_d = sum(s^k_d * r^k_d)</span></span><br><span class="line">        masks_preds = (rois * coeffs).<span class="built_in">sum</span>(dim=<span class="number">1</span>)  <span class="comment"># [instances, 56, 56]</span></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line">        <span class="keyword">return</span> masks_preds.view(N, -<span class="number">1</span>)  <span class="comment"># [instances, 56*56]</span></span><br></pre></td></tr></table></figure>

<h2 id="AdelaiDet-x2F-adet-x2F-modeling-x2F-blendmask-x2F-basis-modules-py"><a href="#AdelaiDet-x2F-adet-x2F-modeling-x2F-blendmask-x2F-basis-modules-py" class="headerlink" title="AdelaiDet&#x2F;adet&#x2F;modeling&#x2F;blendmask&#x2F;basis_modules.py"></a>AdelaiDet&#x2F;adet&#x2F;modeling&#x2F;blendmask&#x2F;basis_modules.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> detectron2.utils.registry <span class="keyword">import</span> Registry</span><br><span class="line"><span class="keyword">from</span> detectron2.layers <span class="keyword">import</span> ShapeSpec</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> adet.layers <span class="keyword">import</span> conv_with_kaiming_uniform</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BASIS_MODULE_REGISTRY = Registry(<span class="string">&quot;BASIS_MODULE&quot;</span>)</span><br><span class="line">BASIS_MODULE_REGISTRY.__doc__ = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Registry for basis module, which produces global bases from feature maps.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The registered object will be called with `obj(cfg, input_shape)`.</span></span><br><span class="line"><span class="string">The call should return a `nn.Module` object.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试用</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_basis_module</span>(<span class="params">cfg, input_shape</span>):</span><br><span class="line">    name = cfg.MODEL.BASIS_MODULE.NAME  <span class="comment"># ProtoNet，具体内容见adet/config/defaults</span></span><br><span class="line">    <span class="keyword">return</span> BASIS_MODULE_REGISTRY.get(name)(cfg, input_shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@BASIS_MODULE_REGISTRY.register()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtoNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cfg, input_shape: <span class="type">Dict</span>[<span class="built_in">str</span>, ShapeSpec]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        (Pdb) input_shape</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &#x27;p3&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=8),</span></span><br><span class="line"><span class="string">            &#x27;p4&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=16),</span></span><br><span class="line"><span class="string">            &#x27;p5&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=32),</span></span><br><span class="line"><span class="string">            &#x27;p6&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=64),</span></span><br><span class="line"><span class="string">            &#x27;p7&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=128)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        TODO: support deconv and variable channel width</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># official protonet has a relu after each conv</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># fmt: off</span></span><br><span class="line">        mask_dim          = cfg.MODEL.BASIS_MODULE.NUM_BASES    <span class="comment"># 4</span></span><br><span class="line">        planes            = cfg.MODEL.BASIS_MODULE.CONVS_DIM    <span class="comment"># 128</span></span><br><span class="line">        self.in_features  = cfg.MODEL.BASIS_MODULE.IN_FEATURES  <span class="comment"># [&#x27;p3&#x27;, &#x27;p4&#x27;, &#x27;p5&#x27;]</span></span><br><span class="line">        self.loss_on      = cfg.MODEL.BASIS_MODULE.LOSS_ON      <span class="comment"># True</span></span><br><span class="line">        norm              = cfg.MODEL.BASIS_MODULE.NORM         <span class="comment"># BN</span></span><br><span class="line">        num_convs         = cfg.MODEL.BASIS_MODULE.NUM_CONVS    <span class="comment"># 3</span></span><br><span class="line">        self.visualize    = cfg.MODEL.BLENDMASK.VISUALIZE       <span class="comment"># False</span></span><br><span class="line">        <span class="comment"># fmt: on</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># &#123;&#x27;p3&#x27;:256, ... , &#x27;p6&#x27;:256&#125;</span></span><br><span class="line">        feature_channels = &#123;k: v.channels <span class="keyword">for</span> k, v <span class="keyword">in</span> input_shape.items()&#125;</span><br><span class="line"></span><br><span class="line">        conv_block = conv_with_kaiming_uniform(norm, <span class="literal">True</span>)  <span class="comment"># conv relu bn</span></span><br><span class="line">        self.refine = nn.ModuleList()</span><br><span class="line">        <span class="keyword">for</span> in_feature <span class="keyword">in</span> self.in_features:</span><br><span class="line">            self.refine.append(conv_block(</span><br><span class="line">                feature_channels[in_feature], planes, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">        tower = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">            tower.append(</span><br><span class="line">                conv_block(planes, planes, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">        tower.append(</span><br><span class="line">            nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">False</span>))</span><br><span class="line">        tower.append(</span><br><span class="line">            conv_block(planes, planes, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">        tower.append(</span><br><span class="line">            nn.Conv2d(planes, mask_dim, <span class="number">1</span>))</span><br><span class="line">        self.add_module(<span class="string">&#x27;tower&#x27;</span>, nn.Sequential(*tower))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.loss_on:</span><br><span class="line">            <span class="comment"># fmt: off</span></span><br><span class="line">            self.common_stride   = cfg.MODEL.BASIS_MODULE.COMMON_STRIDE    <span class="comment"># 8</span></span><br><span class="line">            num_classes          = cfg.MODEL.BASIS_MODULE.NUM_CLASSES + <span class="number">1</span>  <span class="comment"># 26</span></span><br><span class="line">            self.sem_loss_weight = cfg.MODEL.BASIS_MODULE.LOSS_WEIGHT      <span class="comment"># 0.3</span></span><br><span class="line">            <span class="comment"># fmt: on</span></span><br><span class="line"></span><br><span class="line">            inplanes = feature_channels[self.in_features[<span class="number">0</span>]]  <span class="comment"># 256</span></span><br><span class="line">            self.seg_head = nn.Sequential(nn.Conv2d(inplanes, planes, kernel_size=<span class="number">3</span>,</span><br><span class="line">                                                    stride=<span class="number">1</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                                          nn.BatchNorm2d(planes),</span><br><span class="line">                                          nn.ReLU(),</span><br><span class="line">                                          nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>,</span><br><span class="line">                                                    stride=<span class="number">1</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                                          nn.BatchNorm2d(planes),</span><br><span class="line">                                          nn.ReLU(),</span><br><span class="line">                                          nn.Conv2d(planes, num_classes, kernel_size=<span class="number">1</span>,</span><br><span class="line">                                                    stride=<span class="number">1</span>))</span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, features, targets=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param features: len(features)=5</span></span><br><span class="line"><span class="string">        :param targets:[N, h, w]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i, f <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.in_features):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                x = self.refine[i](features[f])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x_p = self.refine[i](features[f])</span><br><span class="line">                x_p = F.interpolate(x_p, x.size()[<span class="number">2</span>:], mode=<span class="string">&quot;bilinear&quot;</span>, align_corners=<span class="literal">False</span>)</span><br><span class="line">                <span class="comment"># x_p = aligned_bilinear(x_p, x.size(3) // x_p.size(3))</span></span><br><span class="line">                x = x + x_p  <span class="comment"># [N, 128, h, w]</span></span><br><span class="line">                pdb.set_trace()</span><br><span class="line">        outputs = &#123;<span class="string">&quot;bases&quot;</span>: [self.tower(x)]&#125;</span><br><span class="line">        losses = &#123;&#125;</span><br><span class="line">        <span class="comment"># auxiliary thing semantic loss 辅助语义损失</span></span><br><span class="line">        <span class="keyword">if</span> self.training <span class="keyword">and</span> self.loss_on:</span><br><span class="line">            sem_out = self.seg_head(features[self.in_features[<span class="number">0</span>]])</span><br><span class="line">            <span class="comment"># resize target to reduce memory</span></span><br><span class="line">            gt_sem = targets.unsqueeze(<span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">            gt_sem = F.interpolate(</span><br><span class="line">                gt_sem, scale_factor=<span class="number">1</span> / self.common_stride)</span><br><span class="line">            seg_loss = F.cross_entropy(</span><br><span class="line">                sem_out, gt_sem.squeeze(<span class="number">1</span>).long())</span><br><span class="line">            losses[<span class="string">&#x27;loss_basis_sem&#x27;</span>] = seg_loss * self.sem_loss_weight</span><br><span class="line">        <span class="keyword">elif</span> self.visualize <span class="keyword">and</span> <span class="built_in">hasattr</span>(self, <span class="string">&quot;seg_head&quot;</span>):</span><br><span class="line">            outputs[<span class="string">&quot;seg_thing_out&quot;</span>] = self.seg_head(features[self.in_features[<span class="number">0</span>]])</span><br><span class="line">        pdb.set_trace()</span><br><span class="line">        <span class="keyword">return</span> outputs, losses</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.freesion.com/article/58821475331/">https://www.freesion.com/article/58821475331/</a></p>
<p><a href="https://github.com/aim-uofa/AdelaiDet">https://github.com/aim-uofa/AdelaiDet</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>实例分割</tag>
      </tags>
  </entry>
  <entry>
    <title>BiFPN代码详解</title>
    <url>/2023/04/25/BiFPN%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="AdelaiDet中的BiFPN代码详解-更新中"><a href="#AdelaiDet中的BiFPN代码详解-更新中" class="headerlink" title="AdelaiDet中的BiFPN代码详解(更新中)"></a>AdelaiDet中的BiFPN代码详解(更新中)</h1><p>AdelaiDet中的bifpn模块代码位于adet&#x2F;modeling&#x2F;backbone&#x2F;bifpn.py中，主要的为三个部分：</p>
<ul>
<li>BiFPN模块</li>
<li>构建backbone网络结构的BackboneWithTopLevels模块</li>
<li>单层的FPN结构SignleBiFPN模块</li>
</ul>
<p>​    <strong>通过注册为框架可使用的backbone：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在yaml中使用 </span></span><br><span class="line"><span class="comment">#MODEL:</span></span><br><span class="line"><span class="comment">#  BACKBONE:</span></span><br><span class="line"><span class="comment">#    NAME: &quot;build_fcos_resnet_bifpn_backbone&quot;</span></span><br><span class="line"><span class="meta">@BACKBONE_REGISTRY.register()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fcos_resnet_bifpn_backbone</span>(<span class="params">cfg, input_shape: ShapeSpec</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        cfg: a detectron2 CfgNode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> cfg.MODEL.MOBILENET:</span><br><span class="line">        bottom_up = build_mnv2_backbone(cfg, input_shape)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># resnet</span></span><br><span class="line">        bottom_up = build_resnet_backbone(cfg, input_shape)</span><br><span class="line">    in_features = cfg.MODEL.BiFPN.IN_FEATURES</span><br><span class="line">    out_channels = cfg.MODEL.BiFPN.OUT_CHANNELS</span><br><span class="line">    num_repeats = cfg.MODEL.BiFPN.NUM_REPEATS</span><br><span class="line">    top_levels = cfg.MODEL.FCOS.TOP_LEVELS</span><br><span class="line">    <span class="comment"># 下面的注释为我自己训练的参数，参数具体解释间后面的BiFPN模块</span></span><br><span class="line">    backbone = BiFPN(</span><br><span class="line">        bottom_up=bottom_up,  </span><br><span class="line">        in_features=in_features,    <span class="comment"># [res3,res4,res5]/[res2,res3,res4,res5]</span></span><br><span class="line">        out_channels=out_channels,  <span class="comment"># 256</span></span><br><span class="line">        num_top_levels=top_levels,  <span class="comment"># 2/1</span></span><br><span class="line">        num_repeats=num_repeats,    <span class="comment"># 6</span></span><br><span class="line">        norm=cfg.MODEL.BiFPN.NORM   <span class="comment"># 为空</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> backbone</span><br></pre></td></tr></table></figure>

<p>​    <strong>下面的内容除非有 ‘&#x2F;‘ 分开表示的，其他默认为 in_features&#x3D;[res2,res3,res4,res5]的情况！！！</strong></p>
<h2 id="BiFPN模块"><a href="#BiFPN模块" class="headerlink" title="BiFPN模块"></a>BiFPN模块</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分割字母和后面的数字，比如将&#x27;res3&#x27;分为&#x27;res&#x27;与&#x27;3&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_name</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(name):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> c.isalpha():</span><br><span class="line">            <span class="keyword">return</span> name[:i], <span class="built_in">int</span>(name[i:])</span><br><span class="line">    <span class="keyword">raise</span> ValueError()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BiFPN</span>(<span class="title class_ inherited__">Backbone</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This module implements Feature Pyramid Network.</span></span><br><span class="line"><span class="string">    It creates pyramid features built on top of some input feature maps.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, bottom_up, in_features, out_channels, num_top_levels, num_repeats, norm=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            bottom_up (Backbone): module representing the bottom up subnetwork.</span></span><br><span class="line"><span class="string">                Must be a subclass of :class:`Backbone`. The multi-scale feature</span></span><br><span class="line"><span class="string">                maps generated by the bottom up network, and listed in `in_features`,</span></span><br><span class="line"><span class="string">                are used to generate FPN levels.</span></span><br><span class="line"><span class="string">            in_features (list[str]): names of the input feature maps coming</span></span><br><span class="line"><span class="string">                from the backbone to which FPN is attached. For example, if the</span></span><br><span class="line"><span class="string">                backbone produces [&quot;res2&quot;, &quot;res3&quot;, &quot;res4&quot;], any *contiguous* sublist</span></span><br><span class="line"><span class="string">                of these may be used; order must be from high to low resolution.</span></span><br><span class="line"><span class="string">            out_channels (int): number of channels in the output feature maps.</span></span><br><span class="line"><span class="string">            num_top_levels (int): the number of the top levels (p6 or p7).</span></span><br><span class="line"><span class="string">            num_repeats (int): the number of repeats of BiFPN.</span></span><br><span class="line"><span class="string">            norm (str): the normalization to use.</span></span><br><span class="line"><span class="string">            ---------------------------------------</span></span><br><span class="line"><span class="string">            bottom_up (Backbone): 必须是Backbone的子类，多尺度特侦图列在in_features中，用于生成FPN levels</span></span><br><span class="line"><span class="string">            in_features (list[str]): 输入特征图的名称，顺序必须为高分辨率到低分辨率，例如如果骨干网路输出到BiFPN的为[res2,res3,res4]，则可使用其中任意连续的子序列</span></span><br><span class="line"><span class="string">            out_channels (int): 输出特征图的channels</span></span><br><span class="line"><span class="string">            num_top_levels (int): 顶层的数量（p6或p7）1时为p6，2时为p7</span></span><br><span class="line"><span class="string">            num_repeats (int): BiFPN的重复次数</span></span><br><span class="line"><span class="string">            norm (str): the normalization to use.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(BiFPN, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(bottom_up, Backbone)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建backbone网络结构，要注意self.bottom_up与bottom_up区别</span></span><br><span class="line">        <span class="comment"># add extra feature levels (i.e., 6 and 7)</span></span><br><span class="line">        self.bottom_up = BackboneWithTopLevels(</span><br><span class="line">            bottom_up, out_channels,</span><br><span class="line">            num_top_levels, norm</span><br><span class="line">        )</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        BackboneWithTopLevels处理后的bottom_up：</span></span><br><span class="line"><span class="string">        &#123;   [res3,res4,res5] 2</span></span><br><span class="line"><span class="string">            &#x27;res3&#x27;: ShapeSpec(channels=512, height=None, width=None, stride=8),  </span></span><br><span class="line"><span class="string">            &#x27;res4&#x27;: ShapeSpec(channels=1024, height=None, width=None, stride=16), </span></span><br><span class="line"><span class="string">            &#x27;res5&#x27;: ShapeSpec(channels=2048, height=None, width=None, stride=32), </span></span><br><span class="line"><span class="string">            &#x27;res6&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=64), </span></span><br><span class="line"><span class="string">            &#x27;res7&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=128)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        &#123;   [res2,res3,res4,res5] 1</span></span><br><span class="line"><span class="string">            &#x27;res2&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=4), </span></span><br><span class="line"><span class="string">            &#x27;res3&#x27;: ShapeSpec(channels=512, height=None, width=None, stride=8), </span></span><br><span class="line"><span class="string">            &#x27;res4&#x27;: ShapeSpec(channels=1024, height=None, width=None, stride=16), </span></span><br><span class="line"><span class="string">            &#x27;res5&#x27;: ShapeSpec(channels=2048, height=None, width=None, stride=32), </span></span><br><span class="line"><span class="string">            &#x27;res6&#x27;: ShapeSpec(channels=256, height=None, width=None, stride=64)&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        bottom_up_output_shapes = self.bottom_up.output_shape()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># in_features [res3, res4, res5, res6, res7]/[&#x27;res2&#x27;, &#x27;res3&#x27;, &#x27;res4&#x27;, &#x27;res5&#x27;, &#x27;res6&#x27;]</span></span><br><span class="line">        in_features = <span class="built_in">sorted</span>(in_features, key=<span class="keyword">lambda</span> x: split_name(x)[<span class="number">1</span>])</span><br><span class="line">        self._size_divisibility = bottom_up_output_shapes[in_features[-<span class="number">1</span>]].stride  <span class="comment"># 最后一个in_features（res6/res5）的stride</span></span><br><span class="line">        self.out_channels = out_channels</span><br><span class="line">        self.min_level = split_name(in_features[<span class="number">0</span>])[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add the names for top blocks</span></span><br><span class="line">        prefix, last_suffix = split_name(in_features[-<span class="number">1</span>])  <span class="comment"># split_name分割为字母与数字</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_top_levels):</span><br><span class="line">            in_features.append(prefix + <span class="built_in">str</span>(last_suffix + i + <span class="number">1</span>))</span><br><span class="line">        self.in_features = in_features</span><br><span class="line"></span><br><span class="line">        <span class="comment"># generate output features</span></span><br><span class="line">        self._out_features = [<span class="string">&quot;p&#123;&#125;&quot;</span>.<span class="built_in">format</span>(split_name(name)[<span class="number">1</span>]) <span class="keyword">for</span> name <span class="keyword">in</span> in_features]  <span class="comment">#[&#x27;p2&#x27;,&#x27;p3&#x27;,&#x27;p4&#x27;,&#x27;p5&#x27;,&#x27;p6&#x27;]</span></span><br><span class="line">        <span class="comment"># 和输入特征的步长对应&#123;&#x27;p2&#x27;: 4, &#x27;p3&#x27;: 8, &#x27;p4&#x27;: 16, &#x27;p5&#x27;: 32, &#x27;p6&#x27;: 64&#125;</span></span><br><span class="line">        self._out_feature_strides = &#123;</span><br><span class="line">            out_name: bottom_up_output_shapes[in_name].stride</span><br><span class="line">            <span class="keyword">for</span> out_name, in_name <span class="keyword">in</span> <span class="built_in">zip</span>(self._out_features, in_features)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 都为输出的channels&#123;&#x27;p2&#x27;: 256, &#x27;p3&#x27;: 256, &#x27;p4&#x27;: 256, &#x27;p5&#x27;: 256, &#x27;p6&#x27;: 256&#125;</span></span><br><span class="line">        self._out_feature_channels = &#123;k: out_channels <span class="keyword">for</span> k <span class="keyword">in</span> self._out_features&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># build bifpn</span></span><br><span class="line">        <span class="comment"># 构建多级的FPN结构，其中SingleBiFPM实现了单层的FPN结构</span></span><br><span class="line">        self.repeated_bifpn = nn.ModuleList()</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            i = 0时   in_channels_list = [256, 512, 1024, 2048, 256]</span></span><br><span class="line"><span class="string">            i = 其他时 in_channels_list = [256, 256, 256, 256, 256]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_repeats):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                in_channels_list = [</span><br><span class="line">                    bottom_up_output_shapes[name].channels <span class="keyword">for</span> name <span class="keyword">in</span> in_features</span><br><span class="line">                ]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                in_channels_list = [</span><br><span class="line">                    self._out_feature_channels[name] <span class="keyword">for</span> name <span class="keyword">in</span> self._out_features</span><br><span class="line">                ]</span><br><span class="line">            self.repeated_bifpn.append(SingleBiFPN(</span><br><span class="line">                in_channels_list, out_channels, norm</span><br><span class="line">            ))</span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size_divisibility</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._size_divisibility</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            input (dict[str-&gt;Tensor]): mapping feature map name (e.g., &quot;p5&quot;) to</span></span><br><span class="line"><span class="string">                feature map tensor for each feature level in high to low resolution order.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            dict[str-&gt;Tensor]:</span></span><br><span class="line"><span class="string">                mapping from feature map name to FPN feature map tensor</span></span><br><span class="line"><span class="string">                in high to low resolution order. Returned feature names follow the FPN</span></span><br><span class="line"><span class="string">                paper convention: &quot;p&lt;stage&gt;&quot;, where stage has stride = 2 ** stage e.g.,</span></span><br><span class="line"><span class="string">                [&quot;n2&quot;, &quot;n3&quot;, ..., &quot;n6&quot;].</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        bottom_up_features = self.bottom_up(x)  <span class="comment"># resnet</span></span><br><span class="line">        feats = [bottom_up_features[f] <span class="keyword">for</span> f <span class="keyword">in</span> self.in_features]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里体现联级，将第一层的FPN输出到feats，再次送入第二层FPN</span></span><br><span class="line">        <span class="keyword">for</span> bifpn <span class="keyword">in</span> self.repeated_bifpn:</span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line">            feats = bifpn(feats)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>(<span class="built_in">zip</span>(self._out_features, feats))</span><br></pre></td></tr></table></figure>



<h2 id="BackboneWithTopLevels"><a href="#BackboneWithTopLevels" class="headerlink" title="BackboneWithTopLevels"></a>BackboneWithTopLevels</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BackboneWithTopLevels</span>(<span class="title class_ inherited__">Backbone</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, backbone, out_channels, num_top_levels, norm=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(BackboneWithTopLevels, self).__init__()</span><br><span class="line">        <span class="comment"># 下面的参数很好理解，都是backbone中的一些参数</span></span><br><span class="line">        self.backbone = backbone</span><br><span class="line">        backbone_output_shape = backbone.output_shape()</span><br><span class="line"></span><br><span class="line">        self._out_feature_channels = &#123;name: shape.channels <span class="keyword">for</span> name, shape <span class="keyword">in</span> backbone_output_shape.items()&#125;</span><br><span class="line">        self._out_feature_strides = &#123;name: shape.stride <span class="keyword">for</span> name, shape <span class="keyword">in</span> backbone_output_shape.items()&#125;</span><br><span class="line">        self._out_features = <span class="built_in">list</span>(self._out_feature_strides.keys())</span><br><span class="line"></span><br><span class="line">        last_feature_name = <span class="built_in">max</span>(self._out_feature_strides.keys(), key=<span class="keyword">lambda</span> x: split_name(x)[<span class="number">1</span>])</span><br><span class="line">        self.last_feature_name = last_feature_name</span><br><span class="line">        self.num_top_levels = num_top_levels</span><br><span class="line"></span><br><span class="line">        last_channels = self._out_feature_channels[last_feature_name]</span><br><span class="line">        last_stride = self._out_feature_strides[last_feature_name]</span><br><span class="line"></span><br><span class="line">        prefix, suffix = split_name(last_feature_name)</span><br><span class="line">        prev_channels = last_channels</span><br><span class="line"></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_top_levels):</span><br><span class="line">            name = prefix + <span class="built_in">str</span>(suffix + i + <span class="number">1</span>)</span><br><span class="line">            self.add_module(name, FeatureMapResampler(</span><br><span class="line">                prev_channels, out_channels, <span class="number">2</span>, norm</span><br><span class="line">            ))</span><br><span class="line">            prev_channels = out_channels</span><br><span class="line"></span><br><span class="line">            self._out_feature_channels[name] = out_channels</span><br><span class="line">            self._out_feature_strides[name] = last_stride * <span class="number">2</span> ** (i + <span class="number">1</span>)</span><br><span class="line">            self._out_features.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        outputs = self.backbone(x)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            outputs[&#x27;res2&#x27;].shape = [8, 256, 40, 32]</span></span><br><span class="line"><span class="string">            outputs[&#x27;res3&#x27;].shape = [8, 512, 20, 16]</span></span><br><span class="line"><span class="string">            outputs[&#x27;res4&#x27;].shape = [8, 1024, 10, 8]</span></span><br><span class="line"><span class="string">            outputs[&#x27;res5&#x27;].shape = [8, 2048, 5, 4]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        last_features = outputs[self.last_feature_name]</span><br><span class="line">        prefix, suffix = split_name(self.last_feature_name)</span><br><span class="line"></span><br><span class="line">        x = last_features</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_top_levels):</span><br><span class="line">            name = prefix + <span class="built_in">str</span>(suffix + i + <span class="number">1</span>)</span><br><span class="line">            x = self.__getattr__(name)(x)</span><br><span class="line">            outputs[name] = x</span><br><span class="line">        <span class="string">&quot;&quot;&quot;  通过上面outputs新增了一个outputs[&#x27;res6&#x27;] shape=[8, 256, 3, 2];  &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure>

<h2 id="SingleBiFPN"><a href="#SingleBiFPN" class="headerlink" title="SingleBiFPN"></a>SingleBiFPN</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>实例分割</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt知识点</title>
    <url>/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Qt笔记"><a href="#Qt笔记" class="headerlink" title="Qt笔记"></a>Qt笔记</h2><h3 id="Qt的几个基类"><a href="#Qt的几个基类" class="headerlink" title="Qt的几个基类"></a>Qt的几个基类</h3><ul>
<li><p>QObject：所有能够处理signal、slot和事件的Qt对象的基类</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QObject::<span class="built_in">Qobject</span>(Qobject* parent=<span class="number">0</span>, <span class="type">const</span> <span class="type">char</span>* name=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>QApplication：负责GUI应用程序的控制流和主要设置，包括主事件循环体，负责处理和调度来自窗口系统和其他资源的事件，并且处理应用程序的开始、结束及会话管理</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Qt Creator提供的三个默认基类：</p>
<ul>
<li>QWidget：是所有用户接口对象的基类，继承了QObject的属性，窗口部件是用户界面的一个基本单元，从窗口系统接收鼠标、键盘和其他消息</li>
<li>QMainWIndow：提供一个带有菜单栏，工具栏和一个状态条的主应用程序窗口。</li>
<li>QDialog：是对话框窗口的基类，对话框窗口主要用于短期任务和用户进行短期通讯的顶级窗口，可以是模态对话框或非模态对话框，支持扩展并带有返回值</li>
</ul>
<h3 id="最简单的Qt应用程序"><a href="#最简单的Qt应用程序" class="headerlink" title="最简单的Qt应用程序"></a>最简单的Qt应用程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Qt系统提供的类头文件没有.h后缀</li>
<li>Qt一个类对应一个头文件，类名和头文件名一致</li>
<li>在Qt生命中，包括Qt主消息循环，在其中完成来自窗口系统和其他资源的所有事件处理和销毁</li>
<li>对于任何一个Qt应用程序，都正好只存在一个QApplication对象</li>
</ul>
<h3 id="pro文件"><a href="#pro文件" class="headerlink" title=".pro文件"></a>.pro文件</h3><p>​    .pro文件就是工程文件，是qmake自动生成用于生成makeflie的配置文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line"></span><br><span class="line">CONFIG += c++<span class="number">11</span></span><br><span class="line"></span><br><span class="line"># The following define makes your compiler emit warnings <span class="keyword">if</span> you use</span><br><span class="line"><span class="meta"># any Qt feature that has been marked deprecated (the exact warnings</span></span><br><span class="line"><span class="meta"># depend on your compiler). Please consult the documentation of the</span></span><br><span class="line"><span class="meta"># deprecated API in order to know how to port your code away from it.</span></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"># You can also make your code fail to compile <span class="keyword">if</span> it uses deprecated APIs.</span><br><span class="line"># In order to <span class="keyword">do</span> so, uncomment the following line.</span><br><span class="line"># You can also select to disable deprecated APIs only up to a certain version of Qt.</span><br><span class="line">#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=<span class="number">0x060000</span>    <span class="meta"># disables all the APIs deprecated before Qt 6.0.0</span></span><br><span class="line"></span><br><span class="line">SOURCES += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    newwindow.cpp \</span><br><span class="line">    widget.cpp</span><br><span class="line"></span><br><span class="line">HEADERS += \</span><br><span class="line">    newwindow.h \</span><br><span class="line">    widget.h</span><br><span class="line"></span><br><span class="line"># Default rules <span class="keyword">for</span> deployment.</span><br><span class="line">qnx: target.path = /tmp/$$&#123;TARGET&#125;/bin</span><br><span class="line"><span class="keyword">else</span>: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin</span><br><span class="line">!<span class="built_in">isEmpty</span>(target.path): INSTALLS += target</span><br></pre></td></tr></table></figure>

<h3 id="QPushButton按钮"><a href="#QPushButton按钮" class="headerlink" title="QPushButton按钮"></a>QPushButton按钮</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 第一种创建</span></span><br><span class="line">    QPushButton *btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;button1&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 第二种创建</span></span><br><span class="line">    QPushButton *btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn2-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setTitle</span>(<span class="string">&quot;button2&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​    创建按钮对象需要给他绑定一个父窗口（父亲对象），创建时绑定或者利用setParent绑定后就存在了父子关系，在有父窗口的情况下，窗口调用show会显示在父窗口中。</p>
<p>​    <strong>Qt的坐标是以左上角为(0,0)，以右为x轴正方向，以下为y轴正方向。</strong></p>
<h3 id="对象树模型"><a href="#对象树模型" class="headerlink" title="对象树模型"></a>对象树模型</h3><p>​    QObject是Qt中绝大部分类的根类，对象之间是以对象树的形式组织起来的：</p>
<ul>
<li>对象树能够自动、有效的组织和管理继承来组QObject的Qt对象</li>
<li>当两个对象建立父子关系时，子对象加入父对象的一个成员变量children的list中</li>
<li>当父对象析构时，这个列表中的所有对象也会被析构</li>
<li>当然也可由手动删除子对象，当子对象析构时会发出一个destroyed信号给父对象，父对象收到后会从children的list中删除这个子对象</li>
<li><strong>这种对象树保证了如果有孩子就自动delete每个孩子，并且保证没有任何QObject对象会被析构两次</strong></li>
<li><strong>在Qt中尽量在构造时就指定parent对象，并且大胆在堆上创建</strong></li>
</ul>
<h3 id="信号和槽机制"><a href="#信号和槽机制" class="headerlink" title="信号和槽机制"></a>信号和槽机制</h3><p>​    信号就是各类事件，槽（槽函数）为响应信号的动作。当某个事件发生后，会发送一个信号，某个对象接收到了这个信号，就会做一些相关的处理动作，也就是槽SLOT，但是这种关系是需要手动建立链接connect：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sender:信号发送者</span></span><br><span class="line"><span class="comment">	singal:信号（函数指针）</span></span><br><span class="line"><span class="comment">	recevier:信号接收者</span></span><br><span class="line"><span class="comment">	slot:接收对象调用的槽函数（函数指针）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">connect</span>(sender, signal, recevier, slot);</span><br><span class="line">QObject::<span class="built_in">connecnt</span>(sender, <span class="built_in">SIGNAL</span>(signal), recevier, <span class="built_in">SLOT</span>(slot));</span><br><span class="line"><span class="comment">//Qt5中connect可以有第五个参数type，指明槽和信号的关联方式，决定了信号是立刻传送到一个槽还是稍后时间排队等待传送</span></span><br><span class="line"><span class="built_in">connect</span>(sender, signal, recevier, slot, Qt::ConnectionType type=Qt::AutoConnection);</span><br></pre></td></tr></table></figure>

<ul>
<li>一个信号可以连接多个槽，但是槽的调用顺序是不确定的</li>
<li>一个信号可以连接另一个信号</li>
<li>一个槽可以接收多个信号</li>
</ul>
<p>​    可以使用系统自带的信号和槽，也可以自定义信号和槽：</p>
<p>​    <strong>自定义信号的使用条件</strong>：</p>
<ul>
<li><p>声明在类的signals域下</p>
</li>
<li><p>没有返回值，void类型的函数</p>
</li>
<li><p>只有声明，没有定义</p>
</li>
<li><p>可以有参数，可以有重载</p>
</li>
<li><p>可以在成员函数中通过emit关键字来触发信号</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">testcall</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testcall</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 可以通过QObject::sender()获取发送信号者</span></span><br><span class="line">QSpinBox *spinBox = qobject_cast&lt;QSpinBox*&gt;)(<span class="built_in">sender</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    <strong>自定义槽的使用条件：</strong></p>
<ul>
<li>qt4必须声明在public&#x2F;private&#x2F;protected slots域下面，qt5后可以声明在public下，同时可以是静态的成员函数，全局函数，lambda表达式</li>
<li>没有返回值，void类型的函数</li>
<li>不仅有声名，还需要定义实现</li>
<li>可以有参数，可以重载</li>
<li>自定义槽的类需要在类声明最开始处使用 <code>Q_OBJECT</code></li>
</ul>
<p>​    <strong>ps：信号函数的参数个数必须大于等于槽函数的参数个数；并且信号函数的参数类型和槽函数的参数类型必须一一对应。并且可以使用 <code>disconnect</code>函数取消链接</strong></p>
<h4 id="Qt中的槽函数与信号量五种连接方式"><a href="#Qt中的槽函数与信号量五种连接方式" class="headerlink" title="Qt中的槽函数与信号量五种连接方式"></a>Qt中的槽函数与信号量五种连接方式</h4><p>​    即Qt::ConnectionType的五种：</p>
<ul>
<li>Qt::DirectConnection直连方式（信号与槽函数关系类似于函数调用，同步执行）</li>
<li>Qt::QueuedConnection队列方式（此时信号被阻塞在消息队列中，信号与槽函数的关系类似于消息通信，异步执行）</li>
<li>Qt::AutoConnection自动方式（Qt默认的连接方式，如果信号发出与接受的对象处于同一线程则与直连方式相同，否则与队列方式相同）</li>
<li>Qt::BlockQueuedConnection阻塞队列方式（信号和槽必须在不同的线程中，否则会产生死锁）</li>
<li>Qt::UniqueConnection唯一方式（与默认工作方式相同，只是不能重复连接相同的信号和槽）</li>
</ul>
<h3 id="QMainWindow类"><a href="#QMainWindow类" class="headerlink" title="QMainWindow类"></a>QMainWindow类</h3><img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230329092549068.png" class="">

<p>​    QMainWindow为用户提供主窗口程序，包含：</p>
<ul>
<li>一个菜单栏</li>
<li>多个工具栏</li>
<li>多个停靠部件</li>
<li>一个状态栏</li>
<li>一个中心部件</li>
</ul>
<h4 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h4><p>​    一个主窗口最多只有一个菜单栏，位于主窗口顶部、主窗口标题栏下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMenuBar *mb = <span class="keyword">this</span>-&gt;<span class="built_in">menuBar</span>();                       <span class="comment">// 获取主窗口的菜单栏</span></span><br><span class="line">QMenu *menuFile = mb-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);                <span class="comment">// addMenu添加菜单</span></span><br><span class="line">QAction *actionCreate = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);  <span class="comment">// 向菜单中添加菜单项</span></span><br><span class="line">menuFile-&gt;<span class="built_in">addSeparator</span>();                             <span class="comment">// 添加分隔符</span></span><br><span class="line"><span class="comment">// 添加二级菜单</span></span><br><span class="line">QMenu *menuRecent = menuFile-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;最近打开的文件&quot;</span>);</span><br><span class="line">QAction *recentone = menuRecent-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    Qt没有专门的菜单项类，只是用QAction类抽象出公共的动作。</p>
<h4 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h4><p>​    主窗口的工具栏上可以有很多个工具条，通常采用一个菜单对应一个工具条的方式，也可以根据需要对工具条进行划分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QToolBar *toolBar = <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(<span class="string">&quot;工具栏&quot;</span>);  <span class="comment">// 创建一个新的工具栏</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(actionCreate);                <span class="comment">// addAction插入属于工具栏的项</span></span><br><span class="line"><span class="comment">// 工具条是一个可以移动的窗口，由Qt::xxxToolBarAreas决定</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(Qt::LeftToolBarAreas, toolBar); </span><br><span class="line"><span class="comment">// 可以使用setAllowAreas来限制工具条的位置范围</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setAllowedAreas</span>(Qt::LeftToolBarArea | Qt::RightToolBarArea);</span><br><span class="line">toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);                    <span class="comment">// 设置工具栏不可以浮动</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setMoveable</span>(<span class="literal">false</span>);                     <span class="comment">// 设置工具栏不可以拖动</span></span><br></pre></td></tr></table></figure>

<h4 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h4><p>​    一个QMainWindow最多只有一个状态栏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QStatusBar *sb = <span class="keyword">this</span>-&gt;<span class="built_in">statucBar</span>();               <span class="comment">// 获取状态栏</span></span><br><span class="line">QLabel *labelLeft = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;左侧信息&quot;</span>,<span class="keyword">this</span>);  <span class="comment">// 创建信息</span></span><br><span class="line">sb-&gt;<span class="built_in">addWidget</span>(labelLeft);                         <span class="comment">// 左侧添加小部件</span></span><br><span class="line">QLabel *labelRight = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">sb-&gt;<span class="built_in">addPermanentWidget</span>(labelRight);               <span class="comment">// 右侧添加小部件</span></span><br></pre></td></tr></table></figure>

<h4 id="停靠部件（浮动窗口）"><a href="#停靠部件（浮动窗口）" class="headerlink" title="停靠部件（浮动窗口）"></a>停靠部件（浮动窗口）</h4><p>​    停靠部件QDockWidget可以有很多个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QDockWidget *dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;停靠部件&quot;</span>, <span class="keyword">this</span>);  <span class="comment">// 创建停靠部件</span></span><br><span class="line"><span class="comment">// 添加到mainWindow中，设置默认在下</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea, dockWidghet);  </span><br><span class="line"><span class="comment">// 设置允许停靠的范围</span></span><br><span class="line">dickWidget-&gt;<span class="built_in">setAllowedAreas</span>(Qt::BottomDockWidgetArea | Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);</span><br></pre></td></tr></table></figure>

<h4 id="核心部件（中心部件）"><a href="#核心部件（中心部件）" class="headerlink" title="核心部件（中心部件）"></a>核心部件（中心部件）</h4><p>​    除了以上几个部件，中间显示的都可以称为核心部件，例如一个编辑框控件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextEdit *textEdte = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(textEdit);           <span class="comment">// 设置核心部件</span></span><br></pre></td></tr></table></figure>

<h3 id="Qt容器组件"><a href="#Qt容器组件" class="headerlink" title="Qt容器组件"></a>Qt容器组件</h3><p>​    Qt中有九种容器组件：</p>
<ul>
<li>组合框QGroupBox</li>
<li>滚动区QScrollArea</li>
<li>工具箱QToolBox</li>
<li>选项卡QTabWidget</li>
<li>控件栈QWidgetStack</li>
<li>框架QFrame</li>
<li>组件QWidget</li>
<li>MDI窗口显示区QMdiArea</li>
<li>停靠窗口QDockWidget</li>
</ul>
<h4 id="1-组合框QGroupBox"><a href="#1-组合框QGroupBox" class="headerlink" title="1.组合框QGroupBox"></a>1.组合框QGroupBox</h4><p>   构建分组框，通常带有一个边框和一个标题栏</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QDialog dialog;</span><br><span class="line">QGroupBox *group = <span class="keyword">new</span> <span class="built_in">QGroupBox</span>(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">group-&gt;<span class="built_in">setCheckable</span>(<span class="literal">true</span>);</span><br><span class="line">group-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">QRadioButton *radio1 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">QRadioButton *radio2 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">QRadioButton *radio3 = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">radio1-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">QCheckBox *check = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;rice&quot;</span>);</span><br><span class="line">check-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">QVBoxLayout *vbox = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">vbox-&gt;<span class="built_in">addWidget</span>(radio1);</span><br><span class="line">vbox-&gt;<span class="built_in">addWidget</span>(radio2);</span><br><span class="line">vbox-&gt;<span class="built_in">addWidget</span>(radio3);</span><br><span class="line">vbox-&gt;<span class="built_in">addWidget</span>(check);</span><br><span class="line">group-&gt;<span class="built_in">setLayout</span>(vbox);</span><br><span class="line">dialog.<span class="built_in">setLayout</span>(vbox);</span><br><span class="line">dialog.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404081346416.png" class="">

<h4 id="2-QScrollArea滚动区"><a href="#2-QScrollArea滚动区" class="headerlink" title="2.QScrollArea滚动区"></a>2.QScrollArea滚动区</h4><p>​    用来显示子控件的内容的框架，如果子控件的尺寸超过了框架的大小，可以使用滚动条，方便查看整个子控件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QScrollArea::<span class="built_in">QScrollArea</span>(QWidget *parent=<span class="number">0</span>);   <span class="comment">// 构造滚动区，父对象为parent</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QScrollArea::setWidget</span><span class="params">(QWidget *widget)</span></span>;  <span class="comment">// 设置widget为滚动区的子控件</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QSrollArea::takeWidget</span><span class="params">()</span></span>;             <span class="comment">// 删除子控件</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QScrollArea::widget</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 返回子空间</span></span><br><span class="line">...</span><br><span class="line">    Widget w;</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(&amp;w);</span><br><span class="line">    <span class="function">QImage <span class="title">image</span><span class="params">(<span class="string">&quot;C:\\Users\\zhuzhibo\\Pictures\\tupian2.jpg&quot;</span>)</span></span>;</span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(&amp;w);</span><br><span class="line">    label-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br><span class="line">    QScrollArea *scrollarea = <span class="keyword">new</span> <span class="built_in">QScrollArea</span>(&amp;w);</span><br><span class="line">    scrollarea-&gt;<span class="built_in">setWidget</span>(label);       <span class="comment">// 加入滚动区</span></span><br><span class="line">    scrollarea-&gt;<span class="built_in">setWidgetResizable</span>(<span class="number">1</span>);  <span class="comment">// 自动改变滚动区大小</span></span><br><span class="line">    scrollarea-&gt;<span class="built_in">setBackgroundRole</span>(QPalette::Dark);  <span class="comment">// 设置滚动区背景颜色</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(scrollarea);</span><br><span class="line">    w.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404081442226.png" class="">

<h4 id="3-QToolBox工具箱"><a href="#3-QToolBox工具箱" class="headerlink" title="3.QToolBox工具箱"></a>3.QToolBox工具箱</h4><p>​    提供了一系列的页和隔间，类似QToolBar：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QToolBox::<span class="built_in">QToolBox</span>(QWidget *parent=<span class="number">0</span>, <span class="type">const</span> <span class="type">char</span>* name=<span class="number">0</span>, QFlags f=<span class="number">0</span>);<span class="comment">// 创建ToolBox</span></span><br><span class="line"><span class="comment">// 增加一个item到ToolBox的底部，设置新增的itme的icon和label</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ToolBox::addItem</span><span class="params">(QWidget *item, <span class="type">const</span> QIconSet &amp;iconSet, <span class="type">const</span> QString &amp;label)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ToolBox::count</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回工具箱中的数目</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ToolBox::currentIndex</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回当前活动的索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ToolBox::currentItem</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回当前活动的item为空返回0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ToolBox</span> : <span class="keyword">public</span> QToolBox</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ToolBox</span><span class="params">(QWidget *parent=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QToolButton *button1;</span><br><span class="line">    QToolButton *button2;</span><br><span class="line">    QToolButton *button3;</span><br><span class="line">    QToolButton *button11;</span><br><span class="line">    QToolButton *button12;</span><br><span class="line">&#125;;</span><br><span class="line">ToolBox::<span class="built_in">ToolBox</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QToolBox</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;ToolBox&quot;</span>);</span><br><span class="line">    <span class="comment">// 水果</span></span><br><span class="line">    button1 = <span class="keyword">new</span> QToolButton;</span><br><span class="line">    button1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    button1-&gt;<span class="built_in">setAutoRaise</span>(<span class="literal">true</span>);</span><br><span class="line">    button1-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonFollowStyle);</span><br><span class="line">    button2 = <span class="keyword">new</span> QToolButton;</span><br><span class="line">    button2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    button2-&gt;<span class="built_in">setAutoRaise</span>(<span class="literal">true</span>);</span><br><span class="line">    button2-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextBesideIcon);</span><br><span class="line">    button3 = <span class="keyword">new</span> QToolButton;</span><br><span class="line">    button3-&gt;<span class="built_in">setText</span>(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setAutoRaise</span>(<span class="literal">true</span>);</span><br><span class="line">    button3-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextBesideIcon);</span><br><span class="line">    <span class="comment">// 添加水果</span></span><br><span class="line">    QGroupBox *group = <span class="keyword">new</span> QGroupBox;</span><br><span class="line">    QVBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(group);</span><br><span class="line">    layout-&gt;<span class="built_in">setMargin</span>(<span class="number">10</span>);</span><br><span class="line">    layout-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button1);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button2);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(button3);</span><br><span class="line">    layout-&gt;<span class="built_in">addStretch</span>();  <span class="comment">// 增加伸缩量</span></span><br><span class="line">    <span class="comment">// 初始化电脑</span></span><br><span class="line">    button11 = <span class="keyword">new</span> QToolButton;</span><br><span class="line">    button11-&gt;<span class="built_in">setText</span>(<span class="string">&quot;HP&quot;</span>);</span><br><span class="line">    button11-&gt;<span class="built_in">setAutoRaise</span>(<span class="literal">true</span>);</span><br><span class="line">    button11-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextBesideIcon);</span><br><span class="line">    button12 = <span class="keyword">new</span> QToolButton;</span><br><span class="line">    button12-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Lenovo&quot;</span>);</span><br><span class="line">    button12-&gt;<span class="built_in">setAutoRaise</span>(<span class="literal">true</span>);</span><br><span class="line">    button12-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextBesideIcon);</span><br><span class="line">    <span class="comment">// 添加电脑</span></span><br><span class="line">    QGroupBox *group2 = <span class="keyword">new</span> QGroupBox;</span><br><span class="line">    QVBoxLayout *layout2 = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(group2);</span><br><span class="line">    layout2-&gt;<span class="built_in">setMargin</span>(<span class="number">10</span>);</span><br><span class="line">    layout2-&gt;<span class="built_in">setAlignment</span>(Qt::AlignHCenter);</span><br><span class="line">    layout2-&gt;<span class="built_in">addWidget</span>(button11);</span><br><span class="line">    layout2-&gt;<span class="built_in">addWidget</span>(button12);</span><br><span class="line">    layout2-&gt;<span class="built_in">addStretch</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addItem</span>((QWidget*)group, <span class="string">&quot;Fruits&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addItem</span>((QWidget*)group2, <span class="string">&quot;Computer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403105925525.png" class="">

<h4 id="4-QTabWidget选项卡"><a href="#4-QTabWidget选项卡" class="headerlink" title="4.QTabWidget选项卡"></a>4.QTabWidget选项卡</h4><p>​    QTabWidget选项卡组件顶部或底部有一个标签选项栏，每个标签选项都有一个页面，选择那个页面，只需要点击对应的标签即可，或者按指定ALT+字母快捷键组合即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTabWidget::<span class="built_in">QTabWidget</span>(QWdiget *parent=<span class="number">0</span>, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>, WFlags=<span class="number">0</span>);  <span class="comment">// 构造</span></span><br><span class="line"><span class="comment">// 增加子页child到QTabWidget对象中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *child, <span class="type">const</span> QString &amp;label)</span>[<span class="keyword">virtual</span>]</span>;</span><br><span class="line"><span class="comment">// 同上，多一个icon图标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::addTab</span><span class="params">(QWidget *child, <span class="type">const</span> QIconSet &amp;iconset, <span class="type">const</span> QString &amp;label)</span>[<span class="keyword">virtual</span>]</span>;</span><br><span class="line"><span class="comment">// 在index处插入新的子页，要确保新的label与QTabWidget中存在的子页名不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::insertTab</span><span class="params">(QWidget *child, <span class="type">const</span> QString &amp;label, <span class="type">int</span> index=<span class="number">-1</span>)</span>[<span class="keyword">virtual</span>]</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTabWidget::removePage</span><span class="params">(QWidget *w)</span>[<span class="keyword">virtual</span> slot]</span>;  <span class="comment">//删除子页w</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget *w = <span class="keyword">new</span> <span class="built_in">QWidget</span>(tab);</span><br><span class="line">QPushButton *btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Ok&quot;</span>, w);</span><br><span class="line">QPushButton *btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;No&quot;</span>, w);</span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(w);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(btn1);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(btn2);</span><br><span class="line">tab-&gt;<span class="built_in">addTab</span>(w, <span class="string">&quot;option1&quot;</span>);</span><br><span class="line"><span class="comment">// 第二页</span></span><br><span class="line">QLabel* label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Qt&quot;</span>, tab);</span><br><span class="line">tab-&gt;<span class="built_in">addTab</span>(label, <span class="string">&quot;option2&quot;</span>);</span><br><span class="line">tab-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;TabWidget&quot;</span>);</span><br><span class="line">tab-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403110652975.png" class="">

<h4 id="5-QStackedWidget控件栈"><a href="#5-QStackedWidget控件栈" class="headerlink" title="5.QStackedWidget控件栈"></a>5.QStackedWidget控件栈</h4><p>​    QStackedWidget控件栈可以使开发人员使用栈管理控件，控件栈只会显示栈顶的控件，可以使用raiseWidget()把栈中任何其他控件移动到栈顶。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidgetStack::<span class="built_in">QWidgetStack</span>(QWidget *parent=<span class="number">0</span>, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);  <span class="comment">// 构造</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QWidgetStack::addWidget</span><span class="params">(QWidget *w, <span class="type">int</span> id=<span class="number">-1</span>)</span></span>;  <span class="comment">// 把w添加栈中，标识为id</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWdigetStack::id</span><span class="params">(QWidget *w)</span> <span class="type">const</span></span>;  <span class="comment">// 返回w的标识</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidgetStack::raiseWidget</span><span class="params">(<span class="type">int</span> id)</span>[slot]</span>;  <span class="comment">// 把id的控件升到栈顶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidgetStack::raiseWidget</span><span class="params">(QWidget *w)</span>[slot]</span>;  <span class="comment">// 把控件w升到栈顶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidgetStack::removeWidget</span><span class="params">(QWidget *w)</span></span>;  <span class="comment">// 把控件w从栈中删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QWidgetStack::removeWidget</span><span class="params">(<span class="type">int</span> id)</span> <span class="type">const</span></span>;  <span class="comment">// 把id的控件从栈中删除</span></span><br><span class="line"><span class="function">QWidget *<span class="title">QWidgetStack::widget</span><span class="params">(<span class="type">int</span> id)</span> <span class="type">const</span></span>;  <span class="comment">// 返回id的控件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QDialog w;</span><br><span class="line">w.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;StackedWidget&quot;</span>);</span><br><span class="line"><span class="comment">// 设置列表框</span></span><br><span class="line">QListWidget *leftlist = <span class="keyword">new</span> <span class="built_in">QListWidget</span>(&amp;w);</span><br><span class="line">leftlist-&gt;<span class="built_in">insertItem</span>(<span class="number">0</span>, <span class="string">&quot;window1&quot;</span>);</span><br><span class="line">leftlist-&gt;<span class="built_in">insertItem</span>(<span class="number">1</span>, <span class="string">&quot;window2&quot;</span>);</span><br><span class="line">leftlist-&gt;<span class="built_in">insertItem</span>(<span class="number">2</span>, <span class="string">&quot;window3&quot;</span>);</span><br><span class="line"><span class="comment">// 设置堆栈窗体</span></span><br><span class="line">QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;WindowTest1\n\tby liming&quot;</span>);</span><br><span class="line">QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;WindowTest2\n\tby liming&quot;</span>);</span><br><span class="line">QLabel *label3 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;WindowTest3\n\tby liming&quot;</span>);</span><br><span class="line">QStackedWidget *stack = <span class="keyword">new</span> <span class="built_in">QStackedWidget</span>(&amp;w);</span><br><span class="line">stack-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">stack-&gt;<span class="built_in">addWidget</span>(label2);</span><br><span class="line">stack-&gt;<span class="built_in">addWidget</span>(label3);</span><br><span class="line"><span class="comment">// 设置主窗体布局</span></span><br><span class="line">QHBoxLayout *mainLayout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>(&amp;w);</span><br><span class="line">mainLayout-&gt;<span class="built_in">setMargin</span>(<span class="number">50</span>);  <span class="comment">// 相对左上角的偏移</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">setSpacing</span>(<span class="number">5</span>);  <span class="comment">// 设置布局中每个部件的间隔</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">addWidget</span>(leftlist);</span><br><span class="line">mainLayout-&gt;<span class="built_in">addWidget</span>(stack, <span class="number">0</span>, Qt::AlignCenter);</span><br><span class="line">mainLayout-&gt;<span class="built_in">setStretchFactor</span>(leftlist, <span class="number">1</span>);  <span class="comment">// 第二个参数大于0表示部件可伸缩</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">setStretchFactor</span>(stack, <span class="number">3</span>);</span><br><span class="line">w.<span class="built_in">connect</span>(leftlist, &amp;QListWidget::currentRowChanged, stack, &amp;QStackedWidget::setCurrentIndex);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403141935545.png" class="">

<h4 id="6-QFrame框架"><a href="#6-QFrame框架" class="headerlink" title="6.QFrame框架"></a>6.QFrame框架</h4><p>​    QFrame是有框架的窗口部件的基类，用来存放其他控件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建一个框架风格为NoFrame并且1像素框架宽度的框架窗口部件</span></span><br><span class="line">QFrame::<span class="built_in">QFrame</span>(QWidget *parent=<span class="number">0</span>, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>, WFlags f=<span class="number">0</span>); </span><br><span class="line"><span class="comment">// QFrame::Shadow枚举值如下</span></span><br><span class="line">QFrame::Plain 框架和内容看起来和周围一样高</span><br><span class="line">QFrame::Raised 框架和内容看起来突起</span><br><span class="line">QFrame::Sunken 框架和内容看起来凹陷</span><br><span class="line">QFrame::MShadow 内容的，对于阴影的掩码</span><br><span class="line"><span class="comment">// QFrame::Shape枚举值如下</span></span><br><span class="line">QFrame::NoFrame QFrame不画任何东西</span><br><span class="line">QFrame::Box 周围画一个框</span><br><span class="line">QFrame::Panel 画一个平板使内容看起来更凹陷或突起</span><br><span class="line">QFrame::WinPanel 和Panel差不多</span><br><span class="line">QFrame::HLine 绘制一个水平线，但是没有框任何东西</span><br><span class="line">QFrame::VLine 绘制一个竖直线，但是没有任何东西</span><br><span class="line">QFrame::StyledPanel 调用QStyle::<span class="built_in">drawPanel</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget *win = <span class="keyword">new</span> QWidget;</span><br><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Box&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFrameStyle</span>(QFrame::Box | QFrame::Raised);</span><br><span class="line">QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Panel&quot;</span>);</span><br><span class="line">QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Winpanel&quot;</span>);</span><br><span class="line">QLabel *label3 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;H line&quot;</span>);</span><br><span class="line">QLabel *label4 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;V line&quot;</span>);</span><br><span class="line">QLabel *label5 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Styled Panel&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setFrameStyle</span>(QFrame::Box | QFrame::Raised);</span><br><span class="line">label-&gt;<span class="built_in">setLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">label1-&gt;<span class="built_in">setFrameStyle</span>(QFrame::Panel | QFrame::Raised);</span><br><span class="line">label1-&gt;<span class="built_in">setLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">label2-&gt;<span class="built_in">setFrameStyle</span>(QFrame::WinPanel | QFrame::Raised);</span><br><span class="line">label2-&gt;<span class="built_in">setLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">label3-&gt;<span class="built_in">setFrameStyle</span>(QFrame::HLine | QFrame::Raised);</span><br><span class="line">label3-&gt;<span class="built_in">setLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">label4-&gt;<span class="built_in">setFrameStyle</span>(QFrame::VLine | QFrame::Raised);</span><br><span class="line">label4-&gt;<span class="built_in">setLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">label5-&gt;<span class="built_in">setFrameStyle</span>(QFrame::StyledPanel | QFrame::Sunken);</span><br><span class="line">label5-&gt;<span class="built_in">setLineWidth</span>(<span class="number">2</span>);</span><br><span class="line">QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label2);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label3);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label4);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(label5);</span><br><span class="line">win-&gt;<span class="built_in">setLayout</span>(layout);</span><br><span class="line">win-&gt;<span class="built_in">showMaximized</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403143608657.png" class="">

<h4 id="7-QWidget组件"><a href="#7-QWidget组件" class="headerlink" title="7.QWidget组件"></a>7.QWidget组件</h4><p>​    QWidget类是所有用户界面对象的基类。</p>
<h4 id="8-QMdiArea多文档区域组件"><a href="#8-QMdiArea多文档区域组件" class="headerlink" title="8.QMdiArea多文档区域组件"></a>8.QMdiArea多文档区域组件</h4><p>​    又称作MDI窗口显示区（Multiple Document Interface），适用于完成一项工作时需要使用多个文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMdiArea::<span class="built_in">QMdiArea</span>(QWidget *parent=<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMdiArea::activateNextSubWindow</span><span class="params">()</span>[slot]</span>;  <span class="comment">// 激活下一个窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMdiArea::activatePreviousSubWindow</span><span class="params">()</span>[slot]</span>;  <span class="comment">// 激活上一个窗口</span></span><br><span class="line"><span class="function">QMdiAreaWindow *<span class="title">QMdiArea::activateSubWindow</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回当前活动窗口</span></span><br><span class="line"><span class="comment">// 添加一个新的子窗口事件</span></span><br><span class="line"><span class="function">QMdiAreaWindow *<span class="title">QMdiArea::addSubWindow</span><span class="params">(QWidget *widget, Qt::WindwoFlags windowFlags=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMdiArea::closeActiveSubWindow</span><span class="params">()</span>[slot]</span>;  <span class="comment">// 关闭当前活动窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QMdiArea::closeAllSubWindow</span><span class="params">()</span>[slot]</span>;  <span class="comment">// 关闭所有活动窗口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMdiArea *mdi = <span class="keyword">new</span> QMdiArea;</span><br><span class="line">QMdiSubWindow *sub = <span class="keyword">new</span> QMdiSubWindow;</span><br><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;label&quot;</span>);</span><br><span class="line">sub-&gt;<span class="built_in">setWidget</span>(label);</span><br><span class="line">sub-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);  <span class="comment">// 关闭窗口就将他删除</span></span><br><span class="line">mdi-&gt;<span class="built_in">addSubWindow</span>(sub);</span><br><span class="line">mdi-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403145427690.png" class="">

<h4 id="9-QDockWidget停靠窗体"><a href="#9-QDockWidget停靠窗体" class="headerlink" title="9.QDockWidget停靠窗体"></a>9.QDockWidget停靠窗体</h4><p>​    <a href="####停靠部件（浮动窗口）">同这里</a></p>
<h3 id="Qt按钮事件"><a href="#Qt按钮事件" class="headerlink" title="Qt按钮事件"></a>Qt按钮事件</h3><p>​    Qt中一共有六种按钮事件，分别为：</p>
<ul>
<li>按压按钮QPushButton</li>
<li>工具按钮QToolButton</li>
<li>单选按钮QRadioButton</li>
<li>多选按钮QCheckBox</li>
<li>命令链接按钮QCommandLinkButton</li>
<li>按钮盒QButtonBox</li>
</ul>
<h4 id="1-QPushButton组件"><a href="#1-QPushButton组件" class="headerlink" title="1.QPushButton组件"></a>1.QPushButton组件</h4><p>​    <a href="###QPushButton按钮">同这里</a></p>
<h4 id="2-QRadioButton单选按钮组件"><a href="#2-QRadioButton单选按钮组件" class="headerlink" title="2.QRadioButton单选按钮组件"></a>2.QRadioButton单选按钮组件</h4><p>​    提供两个或多个互斥选项，一般配合QButtonGroup使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QRadioButton::<span class="built_in">QRadioButton</span>(<span class="type">const</span> QString &amp;text, QWidget *parent, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QRadioButton::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回是否选中单选按钮</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstracButton::setText</span><span class="params">(<span class="type">const</span> QString&amp;)</span></span>;  <span class="comment">// 设置组件上显示的文本</span></span><br><span class="line"><span class="function">QString <span class="title">QAbstractButton::tect</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回按钮的文本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::stateChanged</span><span class="params">(<span class="type">int</span> state)</span>[signal]</span>;  <span class="comment">// checked被更改时发送信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QRadioButton::setChecked</span><span class="params">(<span class="type">bool</span> check)</span>[<span class="keyword">virtual</span> slot]</span>;  <span class="comment">// 设置单选按钮是否被选中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QButtonGroup *group;</span><br><span class="line">    QRadioButton *appleradio;</span><br><span class="line">    QRadioButton *bananaradio;</span><br><span class="line">    QRadioButton *pearradio;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onRadioClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    group = <span class="keyword">new</span> <span class="built_in">QButtonGroup</span>(<span class="keyword">this</span>);</span><br><span class="line">    appleradio = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;apple&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    appleradio-&gt;<span class="built_in">move</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    bananaradio = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;banana&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    bananaradio-&gt;<span class="built_in">move</span>(<span class="number">5</span>, <span class="number">25</span>);</span><br><span class="line">    pearradio = <span class="keyword">new</span> <span class="built_in">QRadioButton</span>(<span class="string">&quot;pear&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    pearradio-&gt;<span class="built_in">move</span>(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(appleradio, <span class="number">0</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(bananaradio, <span class="number">1</span>);</span><br><span class="line">    group-&gt;<span class="built_in">addButton</span>(pearradio, <span class="number">2</span>);</span><br><span class="line">    appleradio-&gt;<span class="built_in">setChecked</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//多个QRadioButton连接到onRadioClick()</span></span><br><span class="line">    <span class="built_in">connect</span>(appleradio, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onRadioClick</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(bananaradio, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onRadioClick</span>()));</span><br><span class="line">    <span class="built_in">connect</span>(pearradio, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">onRadioClick</span>()));</span><br><span class="line">&#125;</span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::onRadioClick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(group-&gt;<span class="built_in">checkedId</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;pear&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403151848357.png" class="">

<h4 id="3-QCheckBox多选按钮组件"><a href="#3-QCheckBox多选按钮组件" class="headerlink" title="3.QCheckBox多选按钮组件"></a>3.QCheckBox多选按钮组件</h4><p>​    复选框可以提供多选多，有三种状态：checked、unchecked和PartiallyChecked。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCheckBox::<span class="built_in">QCheckBox</span>(<span class="type">const</span> QString &amp;text, QWidget *parent, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCheckBox::isChecked</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 是否选中复选框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line"><span class="function">QString <span class="title">QAbstractButton::text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QAbstractButton::stateChanged</span><span class="params">(<span class="type">int</span> state)</span>[signal]</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QCheckBox::setChecked</span><span class="params">(<span class="type">bool</span> check)</span>[<span class="keyword">virtual</span> slot]</span>; <span class="comment">//设置复选框是否选中，状态为check</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QVBoxLayout *vlayout = <span class="keyword">new</span> <span class="built_in">QVBoxLayout</span>(&amp;w);</span><br><span class="line">QCheckBox *check1 = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;check1&quot;</span>, &amp;w);</span><br><span class="line">QCheckBox *check2 = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;check2&quot;</span>, &amp;w);</span><br><span class="line">QCheckBox *check3 = <span class="keyword">new</span> <span class="built_in">QCheckBox</span>(<span class="string">&quot;check3&quot;</span>, &amp;w);</span><br><span class="line">vlayout-&gt;<span class="built_in">addWidget</span>(check1);</span><br><span class="line">vlayout-&gt;<span class="built_in">addWidget</span>(check2);</span><br><span class="line">vlayout-&gt;<span class="built_in">addWidget</span>(check3);</span><br><span class="line">w.<span class="built_in">setLayout</span>(vlayout);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403152533080.png" class="">

<h4 id="4-QToolButton工具按钮组件"><a href="#4-QToolButton工具按钮组件" class="headerlink" title="4.QToolButton工具按钮组件"></a>4.QToolButton工具按钮组件</h4><p>​    一种用于命令或者选项的可以快速访问的按钮，通常用在Toolbar里面，工具按钮通常显示的是图标，而不是文本标签，ToolButton支持自动浮起，在自动浮起模式中，按钮只有在鼠标指向它的时候才绘制三维的框架。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPoolButton::<span class="built_in">QToolButton</span>(QWidget *parent, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">构造一个名为name，父对象为parent(必须为QToolbar)的工具按钮</span></span><br><span class="line"><span class="comment">工具按钮显示iconSet，工具提示为textLabel</span></span><br><span class="line"><span class="comment">状态条信息为grouptext，同时将工具按钮连接到receiver对象的槽函数上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">QToolButton::<span class="built_in">QToolButton</span>(<span class="type">const</span> QIconset &amp;iconSet, <span class="type">const</span> QString &amp;textLabel, <span class="type">const</span> QString &amp;grouptext, QObject *reciver, <span class="type">const</span> <span class="type">char</span> *slot, QToolBar *parent, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 把工具按钮构造成箭头按钮，type为箭头方向:LeftArrow\RightArrow\UpArrow\DownArrow</span></span><br><span class="line">QToolButton::<span class="built_in">QToolButton</span>(ArrowType type, QWidget *parent, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolButton::setAutoRaise</span><span class="params">(<span class="type">bool</span> enable)</span></span>;  <span class="comment">// 设置是否自动浮起</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">设置ToolButton的样式，style有以下样式</span></span><br><span class="line"><span class="comment">Qt::ToolButtonIconOnly 只显示图标</span></span><br><span class="line"><span class="comment">Qt::ToolButtonTextOnly 只显示文本</span></span><br><span class="line"><span class="comment">Qt::ToolButtonTextBesideIcon 文本在图标旁边</span></span><br><span class="line"><span class="comment">Qt::ToolButtonTextUnderIcon 文本显示在图标下面</span></span><br><span class="line"><span class="comment">Qt::ToolButtonFollowStyle 根据QStyle::StyleHint进行设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QToolButton::setToolButtonStyle</span><span class="params">(Qt::ToolButtonStyle style)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置ToolButton的菜单淡出方式ToolButtonPopupMode，有以下方式：</span></span><br><span class="line"><span class="comment">QToolButton::DelayedPopup 延迟弹出</span></span><br><span class="line"><span class="comment">QToolButton::MenuButtonPopup 菜单弹出</span></span><br><span class="line"><span class="comment">QToolButton::InstantPopup 点击立刻弹出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPopupMode</span><span class="params">(ToolButtonPopupMode mode)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QToolButton *btn = <span class="keyword">new</span> <span class="built_in">QToolButton</span>(<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;ToolButton&quot;</span>);</span><br><span class="line">QMenu *menu = <span class="keyword">new</span> <span class="built_in">QMenu</span>();</span><br><span class="line">menu-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">menu-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">btn-&gt;<span class="built_in">setToolButtonStyle</span>(Qt::ToolButtonTextOnly);</span><br><span class="line">btn-&gt;<span class="built_in">setPopupMode</span>(QToolButton::InstantPopup);</span><br><span class="line">btn-&gt;<span class="built_in">setMenu</span>(menu);</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403155309303.png" class="">

<h4 id="5-QCommandLinkButton命令链接按钮组件"><a href="#5-QCommandLinkButton命令链接按钮组件" class="headerlink" title="5.QCommandLinkButton命令链接按钮组件"></a>5.QCommandLinkButton命令链接按钮组件</h4><p>​    继承自QPushButton，用于在互斥选项中选择一项，QCommandLinkButton除带有正常的按钮上的文字描述文本外，默认情况下，将携带一个箭头图标，表明按下按钮将打开另一个窗口或页面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QCommandLinkButton::<span class="built_in">QCommandLinkButton</span>(<span class="type">const</span> QString &amp;text, QWidget *parenr=<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 构造一个描述文本为description的命令链接按钮</span></span><br><span class="line">QCommandLinkButton::<span class="built_in">QCommandLinkButton</span>(<span class="type">const</span> QString &amp;text, <span class="type">const</span> QString &amp;description, QWidget *parent=<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QButton::clicked</span><span class="params">()</span>[signal]</span>;  <span class="comment">// 点击发送信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QButton::pressed</span><span class="params">()</span>[signal]  <span class="comment">// 按下发送信号</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QButton::released</span><span class="params">()</span>[signal]</span>;  <span class="comment">// 松开发送信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QButton::setText</span><span class="params">(<span class="type">const</span> QString&amp;)</span></span>;  <span class="comment">// 设置显示文本</span></span><br><span class="line"><span class="function">QString <span class="title">QButton::text</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-QDialogButtonBox按钮盒组件"><a href="#6-QDialogButtonBox按钮盒组件" class="headerlink" title="6.QDialogButtonBox按钮盒组件"></a>6.QDialogButtonBox按钮盒组件</h4><p>​    可以快速地布置一组按钮，有水平和垂直样式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个按钮盒，排列方向为orinatation</span></span><br><span class="line">QDialogButtonBox::<span class="built_in">QDialogButtonBox</span>(Qt::Orientation orientation, QWidget *parent=<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDialogButtonBox::accepted</span><span class="params">()</span>[signal]</span>;  <span class="comment">// 点击发送信号</span></span><br><span class="line"><span class="comment">// 向按钮盒中添加按钮，定义按钮的角色为role</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDialogButtonBox::addButton</span><span class="params">(QAbstracButton *button, ButtonRole role)</span></span>;</span><br><span class="line"><span class="function">QPushButton *<span class="title">QDialogButtonBox::addButton</span><span class="params">(StandarButton button)</span></span>;  <span class="comment">// 添加标准按钮</span></span><br><span class="line"><span class="comment">// 创建一个文本为text的的按钮，以指定角色添加到按钮盒，如果role无效则不创建</span></span><br><span class="line"><span class="function">QPushButton *<span class="title">QDialogButtonBox::addButton</span><span class="params">(<span class="type">const</span> QString &amp;text, ButtonRole role)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDialogButtonBox::clear</span><span class="params">()</span></span>;  <span class="comment">// 清空按钮盒</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QDialogButtonBox *button = <span class="keyword">new</span> <span class="built_in">QDialogButtonBox</span>(&amp;w);</span><br><span class="line">button-&gt;<span class="built_in">setStandardButtons</span>(QDialogButtonBox::Apply|QDialogButtonBox::Cancel|QDialogButtonBox::Ok);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230403165714930.png" class="">

<h3 id="Model-x2F-View框架"><a href="#Model-x2F-View框架" class="headerlink" title="Model&#x2F;View框架"></a>Model&#x2F;View框架</h3><img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230418110843184.png" class="">

<p>​    model&#x2F;view是一种从视图中分离数据的技术。可以允许使用不同界面显示同一数据，也能够在不改变数据的情况下添加新的显示界面，引入了委托，可以为编辑渲染数据提供编辑器。视图是显示和编辑数据的界面组件，模型是视图与原始数据之间的接口，代理为编辑数据提供编辑器。</p>
<h3 id="Qt模型"><a href="#Qt模型" class="headerlink" title="Qt模型"></a>Qt模型</h3><img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230418110721945.png" class="">

<p>​    所有的模型都是QAbstractItemModel的子类QAbstractItemModel类定义了供视图和委托访问数据的接口，Qt内置了多种标准模型：</p>
<ul>
<li>QStringListModel：继承自QAbstractListModel，存储简单的字符串列表</li>
<li>QStandardItemModel：可以用于树结构的存储，提供了层次数据</li>
<li>QFileSystemModel：本地系统的文件与目录信息</li>
<li>QSqlQueryModel、QSqlTableModel、QSqlRelationalTableModel：存取数据库数据</li>
</ul>
<p>​    为了使数据的显示同存储分离，引入了索引模型，通过索引模型可以访问模型的特定元素的特定部分，视图和委托使用模型索引来请求所需要的数据；索引又分为持久索引(QPersistentModeIndex)与临时索引(QModelIndex)为了定位模型中的数据，需要三个属性：行号、列号、父索引。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QModelIndex index = model-&gt;<span class="built_in">index</span>(row, column, parent);</span><br></pre></td></tr></table></figure>

<h4 id="1-QFileSystemModel"><a href="#1-QFileSystemModel" class="headerlink" title="1.QFileSystemModel"></a>1.QFileSystemModel</h4><p>​    提供一个可用于访问本机系统的数据模型</p>
<h4 id="2-QStringListModel"><a href="#2-QStringListModel" class="headerlink" title="2.QStringListModel"></a>2.QStringListModel</h4><p>​    用于处理字符串列表的数据模型</p>
<h4 id="3-QStandardItemModel"><a href="#3-QStandardItemModel" class="headerlink" title="3.QStandardItemModel"></a>3.QStandardItemModel</h4><p>​    标准的以项数据为基础的标准数据模型类</p>
<h3 id="Delegate代理类"><a href="#Delegate代理类" class="headerlink" title="Delegate代理类"></a>Delegate代理类</h3><p>​    代理一般实现标准模型做不到的事情，将需要的控件委托给模型代理，然后再在视图上显示出来。代理类通常都要继承 <code>QItemDelegate</code> 或 <code>QStyledItemDelegate</code>，二者之间的差距就是后者可以使用当前的样式表来绘制组件。自定义的代理类必须重写父类中的以下四个函数：</p>
<ul>
<li><pre><code class="c++">  // 创建需要的编辑组件并返回
  QWidget *createEditor(QWidget *parent, 
                        const QStyleOptionViewItem &amp;option,
                        const QModelIndex &amp;index) const Q_DECL_OVERRIDE;
  // 从数据模型中获取数值，显示到代理组件中
  void setEditorData(QWidget *editor,
                     const QModelIndex &amp;index) const Q_DECL_OVERRIDE;
  // 将代理编辑器上的值更新给数据模型
  void setModelData(QWidget *editor,
                    QAbstractItemModel *model,
                    const QModelIndex &amp;index) const Q_DECL_OVERRIDE;
  // 为代理组件设置一个合适的大小
  void updateEditorGometry(QWdiget *editor,
                           const QStyleOptionViewItem &amp;option,
                           const ModelIndex &amp;index) const Q_DECL_OVERRIDE;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### Qt单元视图组件</span><br><span class="line"></span><br><span class="line">​    Qt中有五种单元视图组件：</span><br><span class="line"></span><br><span class="line">- 列表视图QListView</span><br><span class="line">- 树状视图QTreeView</span><br><span class="line">- 表格视图QTableView</span><br><span class="line">- 列视图QColumnView</span><br><span class="line">- 表头视图QHeaderView</span><br><span class="line"></span><br><span class="line">#### 1.QListView列表视图</span><br><span class="line"></span><br><span class="line">​    基于模型的列表/图标视图，不显示表头和表框：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Widget(const QStringList &amp;leaders, QWidget *parent = nullptr);</span><br><span class="line">    ~Widget();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    QStringListModel *model;</span><br><span class="line">    QListView *listView;</span><br><span class="line">    QDialogButtonBox *buttonBox;</span><br><span class="line"></span><br><span class="line">private slots:</span><br><span class="line">    void onDelete();</span><br><span class="line">    void onInsert();</span><br><span class="line">&#125;;</span><br><span class="line">Widget::Widget(const QStringList &amp;leaders, QWidget *parent)</span><br><span class="line">    : QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    model = new QStringListModel(this);</span><br><span class="line">    model-&gt;setStringList(leaders);</span><br><span class="line">    listView = new QListView;</span><br><span class="line">    listView-&gt;setModel(model);</span><br><span class="line">    // 设置触发编辑的条件</span><br><span class="line">    listView-&gt;setEditTriggers(QAbstractItemView::AnyKeyPressed</span><br><span class="line">                              | QAbstractItemView::DoubleClicked);</span><br><span class="line">    buttonBox = new QDialogButtonBox;</span><br><span class="line">    QPushButton *insertButton = buttonBox-&gt;addButton(</span><br><span class="line">                tr(&quot;&amp;Insert&quot;),QDialogButtonBox::ActionRole);</span><br><span class="line">    QPushButton *deleteButton = buttonBox-&gt;addButton(</span><br><span class="line">                tr(&quot;&amp;Delete&quot;), QDialogButtonBox::ActionRole);</span><br><span class="line">    connect(insertButton, SIGNAL(clicked()), this, SLOT(onInsert()));</span><br><span class="line">    connect(deleteButton, SIGNAL(clicked()), this, SLOT(onDelete()));</span><br><span class="line">    QVBoxLayout *layout = new QVBoxLayout;</span><br><span class="line">    layout-&gt;addWidget(listView);</span><br><span class="line">    layout-&gt;addWidget(buttonBox);</span><br><span class="line">    setLayout(layout);</span><br><span class="line">    setWindowTitle(tr(&quot;QStringListModel&quot;));</span><br><span class="line">&#125;</span><br><span class="line">void Widget::onDelete()</span><br><span class="line">&#123;</span><br><span class="line">    // 删除当前行</span><br><span class="line">    model-&gt;removeRows(listView-&gt;currentIndex().row(), 1);</span><br><span class="line">&#125;</span><br><span class="line">void Widget::onInsert()</span><br><span class="line">&#123;</span><br><span class="line">    int row = listView-&gt;currentIndex().row();</span><br><span class="line">    model-&gt;insertRows(row, 1);</span><br><span class="line">    QModelIndex index = model-&gt;index(row);</span><br><span class="line">    listView-&gt;setCurrentIndex(index);</span><br><span class="line">    listView-&gt;edit(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404083756051.png" class="">

<h4 id="2-QTreeView树形视图"><a href="#2-QTreeView树形视图" class="headerlink" title="2.QTreeView树形视图"></a>2.QTreeView树形视图</h4><p>​    也是基于模型的列表&#x2F;视图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSplitter *spliter = <span class="keyword">new</span> QSplitter;</span><br><span class="line">QDirModel *model = <span class="keyword">new</span> QDirModel;</span><br><span class="line"><span class="comment">// 从缺省目录创建数据</span></span><br><span class="line">QTreeView *tree = <span class="keyword">new</span> <span class="built_in">QTreeView</span>(spliter);</span><br><span class="line">tree-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">tree-&gt;<span class="built_in">setRootIndex</span>(model-&gt;<span class="built_in">index</span>(<span class="string">&quot;d:\\&quot;</span>));</span><br><span class="line"><span class="comment">// Qt5中采用以下方式解决中文乱码</span></span><br><span class="line">QTextCodec *codec = QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">QString name = codec-&gt;<span class="built_in">toUnicode</span>(<span class="string">&quot;目录&quot;</span>);</span><br><span class="line">spliter-&gt;<span class="built_in">setWindowTitle</span>(name);</span><br><span class="line">spliter-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404085153899.png" class="">

<h4 id="3-QTableView表格视图"><a href="#3-QTableView表格视图" class="headerlink" title="3.QTableView表格视图"></a>3.QTableView表格视图</h4><p>​    是一个模型&#x2F;视图结构的表视图实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QStandardItemModel *model = <span class="keyword">new</span> QStandardItemModel;</span><br><span class="line">model-&gt;<span class="built_in">setColumnCount</span>(<span class="number">2</span>);</span><br><span class="line">model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>)-&gt;<span class="built_in">toUnicode</span>(<span class="string">&quot;卡号&quot;</span>));</span><br><span class="line">model-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>)-&gt;<span class="built_in">toUnicode</span>(<span class="string">&quot;姓名&quot;</span>));</span><br><span class="line">QTableView *tableview = <span class="keyword">new</span> QTableView;</span><br><span class="line">tableview-&gt;<span class="built_in">setModel</span>(model);</span><br><span class="line">tableview-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setDefaultAlignment</span>(Qt::AlignLeft);  <span class="comment">// 靠左</span></span><br><span class="line"><span class="comment">// QHeaderView::Fixed表示用户调节不了大小</span></span><br><span class="line">tableview-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">0</span>,QHeaderView::Fixed);</span><br><span class="line">tableview-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeMode</span>(<span class="number">1</span>, QHeaderView::Fixed);</span><br><span class="line">tableview-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">tableview-&gt;<span class="built_in">setColumnWidth</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 循环插入数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     model-&gt;<span class="built_in">setItem</span>(i,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="string">&quot;20211105238&quot;</span>));</span><br><span class="line">     <span class="comment">//设置字符颜色</span></span><br><span class="line">     model-&gt;<span class="built_in">item</span>(i,<span class="number">0</span>)-&gt;<span class="built_in">setForeground</span>(<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">     <span class="comment">//设置字符位置</span></span><br><span class="line">     model-&gt;<span class="built_in">item</span>(i,<span class="number">0</span>)-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignCenter);</span><br><span class="line">     model-&gt;<span class="built_in">setItem</span>(i,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QStandardItem</span>(QTextCodec::<span class="built_in">codecForName</span>(<span class="string">&quot;utf-8&quot;</span>)-&gt;<span class="built_in">toUnicode</span>(<span class="string">&quot;哈哈&quot;</span>)));</span><br><span class="line"> &#125;</span><br><span class="line">tableview-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404091853455.png" class="">

<h4 id="4-QColumnView列视图"><a href="#4-QColumnView列视图" class="headerlink" title="4.QColumnView列视图"></a>4.QColumnView列视图</h4><p>​    提供了一个模型&#x2F;视图的列视图实现，提供了多级视图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow w;</span><br><span class="line">QColumnView *cview = <span class="keyword">new</span> <span class="built_in">QColumnView</span>(&amp;w);</span><br><span class="line">w.<span class="built_in">setCentralWidget</span>(cview);</span><br><span class="line">QStandardItemModel model;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> groupnum = <span class="number">0</span>; groupnum &lt; <span class="number">3</span>; ++groupnum) &#123;</span><br><span class="line">    QStandardItem *group = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;Group %1&quot;</span>).<span class="built_in">arg</span>(groupnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> personnum = <span class="number">0</span>; personnum &lt; <span class="number">5</span>; ++personnum) &#123;</span><br><span class="line">        QStandardItem *person = <span class="keyword">new</span> <span class="built_in">QStandardItem</span>(<span class="built_in">QString</span>(<span class="string">&quot;Person %1 (group %2)&quot;</span>).<span class="built_in">arg</span>(personnum).<span class="built_in">arg</span>(groupnum));</span><br><span class="line">        group-&gt;<span class="built_in">appendRow</span>(person);</span><br><span class="line">    &#125;</span><br><span class="line">    model.<span class="built_in">appendRow</span>(group);</span><br><span class="line">&#125;</span><br><span class="line">cview-&gt;<span class="built_in">setModel</span>(&amp;model);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404093203445.png" class="">

<h4 id="5-QHeaderView表头视图"><a href="#5-QHeaderView表头视图" class="headerlink" title="5.QHeaderView表头视图"></a>5.QHeaderView表头视图</h4><p>​    提供行表头或列表头视图组件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造，orientation表示为行或列</span></span><br><span class="line">QHeaderView::<span class="built_in">QHeaderView</span>(Qt::Orientation orientation表示为行或列, QWidget *parent=<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// ResizeMode为调整大小模式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">QHeaderView</span>::ResizeMode&#123;</span><br><span class="line">    QHeaderView::Interactive;       <span class="comment">// 用户可以调整大小，也可以使用resizeSection()调整</span></span><br><span class="line">    QHeaderView::Fixed;             <span class="comment">// 用户无法调整，只能以resizeSection()调整</span></span><br><span class="line">    QHeaderView::Stretch;           <span class="comment">// 自动调整大小以填充可用空间，用户无法调整</span></span><br><span class="line">    QHeaderView::ResizeToContents;  <span class="comment">// 自动调节，用户无法调整</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Qt单元组件（便利类）"><a href="#Qt单元组件（便利类）" class="headerlink" title="Qt单元组件（便利类）"></a>Qt单元组件（便利类）</h3><p>​    Qt有三种单元组件：</p>
<ul>
<li>列表单元组件QListWidget</li>
<li>树形单元组件QTreeWidget</li>
<li>表格单元组件QTableWidget</li>
</ul>
<h4 id="1-QListWidget列表单元组件"><a href="#1-QListWidget列表单元组件" class="headerlink" title="1.QListWidget列表单元组件"></a>1.QListWidget列表单元组件</h4><p>​    继承自QListView，是基于单元的列表组件，可以显示一个清单，清单中每个项目是QListWidgetItem的一个实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">QListWidget *listWidget = <span class="keyword">new</span> <span class="built_in">QListWidget</span>(&amp;w);</span><br><span class="line">QVBoxLayout *layout = <span class="keyword">new</span> QVBoxLayout;</span><br><span class="line">QListWidgetItem* lst1 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;data&quot;</span>, listWidget);</span><br><span class="line">QListWidgetItem* lst2 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;decision&quot;</span>, listWidget);</span><br><span class="line">QListWidgetItem* lst3 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;document&quot;</span>, listWidget);</span><br><span class="line">QListWidgetItem* lst4 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;process&quot;</span>, listWidget);</span><br><span class="line">QListWidgetItem* lst5 = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;printer&quot;</span>, listWidget);</span><br><span class="line">listWidget-&gt;<span class="built_in">insertItem</span>(<span class="number">1</span>, lst1);  <span class="comment">// 在第1行插入项目item</span></span><br><span class="line">listWidget-&gt;<span class="built_in">insertItem</span>(<span class="number">2</span>, lst2);</span><br><span class="line">listWidget-&gt;<span class="built_in">insertItem</span>(<span class="number">3</span>, lst3);</span><br><span class="line">listWidget-&gt;<span class="built_in">insertItem</span>(<span class="number">4</span>, lst4);</span><br><span class="line">listWidget-&gt;<span class="built_in">insertItem</span>(<span class="number">5</span>, lst5);</span><br><span class="line">listWidget-&gt;<span class="built_in">show</span>();</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(listWidget);</span><br><span class="line">w.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404094008174.png" class="">

<h4 id="2-QTreeWidget树形单元组件"><a href="#2-QTreeWidget树形单元组件" class="headerlink" title="2.QTreeWidget树形单元组件"></a>2.QTreeWidget树形单元组件</h4><p>​    继承自QTreeView，是树形视图的使用预定义模型，也是基于模型&#x2F;视图结构的组件，通过QTreeWidgetItem添加节点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">QTreeWidget *treeWidget = <span class="keyword">new</span> <span class="built_in">QTreeWidget</span>(&amp;w);</span><br><span class="line">treeWidget-&gt;<span class="built_in">setColumnCount</span>(<span class="number">1</span>);  <span class="comment">// 设置列数</span></span><br><span class="line">treeWidget-&gt;<span class="built_in">setHeaderLabel</span>(<span class="string">&quot;图像选择&quot;</span>);  <span class="comment">// 设置头的标题</span></span><br><span class="line">QTreeWidgetItem *Item1 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(treeWidget, <span class="built_in">QStringList</span>(<span class="string">&quot;图像1&quot;</span>));</span><br><span class="line">QTreeWidgetItem *Item11 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(Item1, <span class="built_in">QStringList</span>(<span class="string">&quot;Band1&quot;</span>));  <span class="comment">// 子节点1</span></span><br><span class="line">Item1-&gt;<span class="built_in">addChild</span>(Item11);</span><br><span class="line">QTreeWidgetItem *Item2 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(treeWidget, <span class="built_in">QStringList</span>(<span class="string">&quot;图像2&quot;</span>));</span><br><span class="line">QTreeWidgetItem *Item21 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(Item2, <span class="built_in">QStringList</span>(<span class="string">&quot;Band1&quot;</span>));  <span class="comment">// 子节点1</span></span><br><span class="line">QTreeWidgetItem *Item22 = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(Item2, <span class="built_in">QStringList</span>(<span class="string">&quot;Band2&quot;</span>));  <span class="comment">// 子节点2 </span></span><br><span class="line">Item2-&gt;<span class="built_in">addChild</span>(Item21);  <span class="comment">// 添加子节点</span></span><br><span class="line">Item2-&gt;<span class="built_in">addChild</span>(Item22);</span><br><span class="line">treeWidget-&gt;<span class="built_in">expandAll</span>();  <span class="comment">// 节点全部展开</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404095429564.png" class="">

<h4 id="3-QTableWidget表格单元组件"><a href="#3-QTableWidget表格单元组件" class="headerlink" title="3.QTableWidget表格单元组件"></a>3.QTableWidget表格单元组件</h4><p>​    继承自QTableView，QTbaleView可以使用自定义的数据来显示内容，而QTableWidget只能使用标准的数据模型，并且其单元数据是QTableWidgetItem对象来实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTableWidget *tablewidget = <span class="keyword">new</span> <span class="built_in">QTableWidget</span>(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">tablewidget-&gt;<span class="built_in">resize</span>(<span class="number">350</span>, <span class="number">200</span>);  <span class="comment">//设置表格</span></span><br><span class="line">QStringList header;</span><br><span class="line">header&lt;&lt;<span class="string">&quot;Month&quot;</span>&lt;&lt;<span class="string">&quot;Description&quot;</span>;</span><br><span class="line">tablewidget-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(header);  <span class="comment">// 设置表头</span></span><br><span class="line">tablewidget-&gt;<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Jan&quot;</span>));  <span class="comment">// 插入数据</span></span><br><span class="line">tablewidget-&gt;<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Feb&quot;</span>));</span><br><span class="line">tablewidget-&gt;<span class="built_in">setItem</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Mar&quot;</span>));</span><br><span class="line">tablewidget-&gt;<span class="built_in">setItem</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Jan&#x27;s month&quot;</span>));</span><br><span class="line">tablewidget-&gt;<span class="built_in">setItem</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Feb&#x27;s month&quot;</span>));</span><br><span class="line">tablewidget-&gt;<span class="built_in">setItem</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(<span class="string">&quot;Mar&#x27;s month&quot;</span>));</span><br><span class="line">tablewidget-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404100058691.png" class="">

<h3 id="Qt输入组件"><a href="#Qt输入组件" class="headerlink" title="Qt输入组件"></a>Qt输入组件</h3><p>​    Qt中一共有13种输入组件：</p>
<ul>
<li>下拉列表框QComboBox</li>
<li>字体组合框QFontComboBox</li>
<li>行编辑框QLineEdit</li>
<li>文版编辑框QTextEdit</li>
<li>无格式文本编辑框QPlainTextEdit</li>
<li>整数计数器QSpinBox</li>
<li>小数计数器QDoubleSpinBox</li>
<li>时间编辑框QTimeEdit</li>
<li>日期编辑框QDateEdit</li>
<li>日期时间编辑框QDateTimeEdit</li>
<li>表盘QDial</li>
<li>滚动条QScrollBar（水平+竖直）</li>
<li>滑动条QSlider（水平+竖直）</li>
</ul>
<h4 id="1-QComboBox下拉列表框"><a href="#1-QComboBox下拉列表框" class="headerlink" title="1.QComboBox下拉列表框"></a>1.QComboBox下拉列表框</h4><p>​    继承自QWidget，用于有多个选项的下拉框：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QComboBox *comboBox = new QComboBox(&amp;w);</span><br><span class="line">comboBox-&gt;addItem(&quot;1&quot;);  // 在下拉框最后添加一项</span><br><span class="line">comboBox-&gt;addItem(&quot;2&quot;);</span><br><span class="line">comboBox-&gt;insertItem(0, &quot;3&quot;);  // 给定索引插入一项，如果索引为0或-1，则在添加到现有项目的列表最前</span><br><span class="line">w.show();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404102831789.png" class="">

<h4 id="2-QFontComboBox字体组合框组件"><a href="#2-QFontComboBox字体组合框组件" class="headerlink" title="2.QFontComboBox字体组合框组件"></a>2.QFontComboBox字体组合框组件</h4><p>​    继承于QComboBox，QFontComboBox字体组合框分为两部分显示：顶部是一个允许输入文本的文本框，下面的列表框则显示字体列表项，但只能单选，专门用于选择字体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QFontComboBox *fontcom = <span class="keyword">new</span> <span class="built_in">QFontComboBox</span>(&amp;w);</span><br><span class="line">QFont font = fontcom-&gt;<span class="built_in">currentFont</span>();  <span class="comment">// 返回当前选择字体</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; font; <span class="comment">//QFont(SimSun,9,-1,5,50,0,0,0,0,0)</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404103515990.png" class="">

<h4 id="3-QLineEdit行编辑组件"><a href="#3-QLineEdit行编辑组件" class="headerlink" title="3.QLineEdit行编辑组件"></a>3.QLineEdit行编辑组件</h4><p>​    主要用它来接受输入文字信息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(&amp;w);</span><br><span class="line">lineEdit-&gt;<span class="built_in">setText</span>(<span class="string">&quot;zhuzhibo&quot;</span>);  <span class="comment">// 设置行编辑文本</span></span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; lineEdit-&gt;<span class="built_in">text</span>();  <span class="comment">// 返回行编辑文本&quot;zhuzhibo&quot;</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404103947645.png" class="">

<h4 id="4-QTextEdit文本编辑组件"><a href="#4-QTextEdit文本编辑组件" class="headerlink" title="4.QTextEdit文本编辑组件"></a>4.QTextEdit文本编辑组件</h4><p>​    主要用于输入文本信息或显示文本信息，支持富文本</p>
<h4 id="5-QPlainTextEdit无格式文本编辑组件"><a href="#5-QPlainTextEdit无格式文本编辑组件" class="headerlink" title="5.QPlainTextEdit无格式文本编辑组件"></a>5.QPlainTextEdit无格式文本编辑组件</h4><p>​    和QTextEdit只是样式不同，可以通过设置属性改变样式。</p>
<h4 id="6-QSPinBox整数计数器组件"><a href="#6-QSPinBox整数计数器组件" class="headerlink" title="6.QSPinBox整数计数器组件"></a>6.QSPinBox整数计数器组件</h4><p>​    继承自QAbstractSpinBox，允许用户通过点击向上&#x2F;向下按钮来增加&#x2F;减少当前显示的值，也可以直接输入选择框的值，如果值是直接输入选择框，一般需要按Enter键确认新值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QSpinBox *spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(&amp;w);</span><br><span class="line">spinBox-&gt;<span class="built_in">setSingleStep</span>(<span class="number">2</span>);</span><br><span class="line">spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>,<span class="number">100</span>);  <span class="comment">// 设置变化范围</span></span><br><span class="line">spinBox-&gt;<span class="built_in">setSuffix</span>(<span class="string">&quot; km&quot;</span>);  <span class="comment">// 设置显示后缀</span></span><br><span class="line">spinBox-&gt;<span class="built_in">setPrefix</span>(<span class="string">&quot;distance &quot;</span>);  <span class="comment">// 设置显示前缀</span></span><br><span class="line">spinBox-&gt;<span class="built_in">resize</span>(<span class="number">200</span>, <span class="number">40</span>);  <span class="comment">// 设置大小</span></span><br><span class="line">spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);  <span class="comment">// 设置初始值</span></span><br><span class="line">spinBox-&gt;<span class="built_in">setSingleStep</span>(<span class="number">1</span>);  <span class="comment">// 设置计数器步长值</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404105743783.png" class="">

<h4 id="7-QDoubleSpinBox"><a href="#7-QDoubleSpinBox" class="headerlink" title="7.QDoubleSpinBox"></a>7.QDoubleSpinBox</h4><p>​    小数计数器组件，继承自QSpinBox，可以表示小数，其他功能与QSpinBox相同</p>
<h4 id="8-QSlider滑动条组件"><a href="#8-QSlider滑动条组件" class="headerlink" title="8.QSlider滑动条组件"></a>8.QSlider滑动条组件</h4><p>​    继承自QAbstractSlider，有Horizontal&#x2F;Vertical Slider两种布局，两种布局样式之间可以相互转换，只需要改变orientation属性即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">QSlider *vslider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(&amp;w);  <span class="comment">// 默认为竖直Vertical</span></span><br><span class="line">vslider-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);  <span class="comment">// 设置最大值</span></span><br><span class="line">vslider-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);  <span class="comment">// 设置最小值</span></span><br><span class="line">vslider-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);  <span class="comment">// 设置默认值</span></span><br><span class="line">QSlider *hslider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal, &amp;w);  <span class="comment">// 创建水平滑动条</span></span><br><span class="line">hslider-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);</span><br><span class="line">hslider-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);</span><br><span class="line">hslider-&gt;<span class="built_in">setValue</span>(<span class="number">50</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(vslider);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(hslider);</span><br><span class="line">w.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404111249348.png" class="">

<h4 id="9-QDial表盘组件"><a href="#9-QDial表盘组件" class="headerlink" title="9.QDial表盘组件"></a>9.QDial表盘组件</h4><p>​    继承自QAbstractSlider，可用来描述各式各样的仪表盘样式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QDial *dial = <span class="keyword">new</span> <span class="built_in">QDial</span>(&amp;w);</span><br><span class="line">dial-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);  <span class="comment">// 设置最小值</span></span><br><span class="line">dial-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);  <span class="comment">// 设置最大值</span></span><br><span class="line">dial-&gt;<span class="built_in">setValue</span>(<span class="number">20</span>);  <span class="comment">// 设置表盘值</span></span><br><span class="line">dial-&gt;<span class="built_in">setNotchesVisible</span>(<span class="literal">true</span>);  <span class="comment">// 设置表盘是否可见</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404111741191.png" class="">

<h4 id="10-QScrollBar滚动条组件"><a href="#10-QScrollBar滚动条组件" class="headerlink" title="10.QScrollBar滚动条组件"></a>10.QScrollBar滚动条组件</h4><p>​    继承自QAbstractSlider，提供垂直和水平布局样式，滚动条可以使用户能够查看比窗口组件显示较多的内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">QScrollBar *vscroll = <span class="keyword">new</span> <span class="built_in">QScrollBar</span>(&amp;w);</span><br><span class="line">vscroll-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);</span><br><span class="line">vscroll-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);</span><br><span class="line">vscroll-&gt;<span class="built_in">setValue</span>(<span class="number">20</span>);</span><br><span class="line">QScrollBar *hscroll = <span class="keyword">new</span> <span class="built_in">QScrollBar</span>(Qt::Horizontal, &amp;w);</span><br><span class="line">hscroll-&gt;<span class="built_in">setMaximum</span>(<span class="number">100</span>);</span><br><span class="line">hscroll-&gt;<span class="built_in">setMinimum</span>(<span class="number">0</span>);</span><br><span class="line">hscroll-&gt;<span class="built_in">setValue</span>(<span class="number">20</span>);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(vscroll);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(hscroll);</span><br><span class="line">w.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404112330194.png" class="">

<h4 id="11-QDateTimeEdit日期事件编辑框组件"><a href="#11-QDateTimeEdit日期事件编辑框组件" class="headerlink" title="11.QDateTimeEdit日期事件编辑框组件"></a>11.QDateTimeEdit日期事件编辑框组件</h4><p>​    用来编辑和显示时间与日期的组件，继承自QAbstractSpinBox：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QDateTimeEdit *datetime = <span class="keyword">new</span> <span class="built_in">QDateTimeEdit</span>(&amp;w);</span><br><span class="line">datetime-&gt;<span class="built_in">setTime</span>(QTime::<span class="built_in">currentTime</span>());  <span class="comment">// 设置时间</span></span><br><span class="line">datetime-&gt;<span class="built_in">setDate</span>(QDate::<span class="built_in">currentDate</span>());  <span class="comment">// 设置日期</span></span><br><span class="line">datetime-&gt;<span class="built_in">setDisplayFormat</span>(<span class="built_in">QString</span>(<span class="string">&quot;yyyy/MM/dd hh:mm&quot;</span>));  <span class="comment">// 设置时间格式</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404113242197.png" class="">

<h4 id="12-QDateEdit日期编辑框组件"><a href="#12-QDateEdit日期编辑框组件" class="headerlink" title="12.QDateEdit日期编辑框组件"></a>12.QDateEdit日期编辑框组件</h4><p>​    继承自QDateTimeEdit，用于编辑和显示日期</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateEdit::setDay</span><span class="params">(<span class="type">int</span> day)</span>[<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span>;  <span class="comment">// 设置Day，确保day为有效值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateEdit::setDMonth</span><span class="params">(<span class="type">int</span> month)</span>[<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span>;  <span class="comment">// 设置Mouth，同上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QDateEdit::setYear</span><span class="params">(<span class="type">int</span> year)</span>[<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span>;  <span class="comment">// 设置Year，同上</span></span><br></pre></td></tr></table></figure>

<h4 id="13-QTimeEdit时间编辑框组件"><a href="#13-QTimeEdit时间编辑框组件" class="headerlink" title="13.QTimeEdit时间编辑框组件"></a>13.QTimeEdit时间编辑框组件</h4><p>​    继承自QTimeEdit，用于编辑和显示时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimeEdit::setHour</span><span class="params">(<span class="type">int</span> h)</span>[<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span>;  <span class="comment">// 设置Hour，确保h为有效值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimeEdit::setMinute</span><span class="params">(<span class="type">int</span> m)</span>[<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span>;  <span class="comment">// 设置Minute，同上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTimeEdit::setSecond</span><span class="params">(<span class="type">int</span> s)</span>[<span class="keyword">virtual</span> <span class="keyword">protected</span>]</span>;  <span class="comment">// 设置Second，同上</span></span><br></pre></td></tr></table></figure>

<h3 id="Qt显示组件"><a href="#Qt显示组件" class="headerlink" title="Qt显示组件"></a>Qt显示组件</h3><p>​    Qt一共有七种显示组件：</p>
<ul>
<li>标签QLabel</li>
<li>文本浏览器QTextBrowser</li>
<li>绘图视图QGraphicsView</li>
<li>日历组件QCalendarWidget</li>
<li>LCD数字显示框QLCDNumber</li>
<li>进度条QProgressBar</li>
<li>线条QLine</li>
</ul>
<h4 id="1-QLabel标签组件"><a href="#1-QLabel标签组件" class="headerlink" title="1.QLabel标签组件"></a>1.QLabel标签组件</h4><p>​    继承自QFrame，用于显示文本或图像，具体见<a href="###常用控件QLabel">这里</a></p>
<h4 id="2-QTextBrowser文本浏览器组件"><a href="#2-QTextBrowser文本浏览器组件" class="headerlink" title="2.QTextBrowser文本浏览器组件"></a>2.QTextBrowser文本浏览器组件</h4><p>​    继承自QTextEdit，是只读的，不允许对内容进行更改，但还具有链接文本的作用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTextBrowser::<span class="built_in">QTextBrowser</span>(QWidget *parent=<span class="number">0</span>, <span class="type">const</span> <span class="type">char</span> *name=<span class="number">0</span>);  <span class="comment">// 构造</span></span><br><span class="line"><span class="comment">// 更改内置导航链接的文件清单为显示当前一个文档，如果没有以前的文档，就什么都不做，可以实现向前翻页的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTextBrowser::backward</span><span class="params">()</span>[<span class="keyword">virtual</span> slot]</span>;</span><br><span class="line"><span class="comment">// 更改内置导航链接的文件清单为显示下一个文档，如果没有以前的文档，就什么都不做，可以实现向后翻页的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTextBrowser::forward</span><span class="params">()</span>[<span class="keyword">virtual</span> slot]</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTextBrowser::home</span><span class="params">()</span>[<span class="keyword">virtual</span> slot]</span>;  <span class="comment">//更改显示的文件浏览器中的链接，显示第一个文件</span></span><br><span class="line"><span class="comment">// 点击链接时发送该信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTextBrowser::linkClicked</span><span class="params">(<span class="type">const</span> QString &amp;name)</span>[<span class="keyword">virtual</span> slot]</span>;</span><br><span class="line"><span class="comment">// 重新载入当前的设置源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QTextBrowser::reload</span><span class="params">()</span>[<span class="keyword">virtual</span> slot]</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-QGraphicsView绘图视图组件"><a href="#3-QGraphicsView绘图视图组件" class="headerlink" title="3.QGraphicsView绘图视图组件"></a>3.QGraphicsView绘图视图组件</h4><p>​    用于显示QGraphicsScene内容的控件，为2D绘图提供一个解决方案，主要由三部分组成：QGraphicsItem用来定义图元、QGraphicsScene定义场景并包含所有需要绘制的图元和QGraphicsView定义观察场景的视窗（视图）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QGraphicsScene scene;  <span class="comment">// 创建场景</span></span><br><span class="line">scene.<span class="built_in">setBackgroundBrush</span>(Qt::red);  <span class="comment">// 设定场景背景</span></span><br><span class="line">QPen pen;  <span class="comment">// 创建画笔</span></span><br><span class="line">pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">230</span>));  <span class="comment">// 画笔颜色</span></span><br><span class="line">pen.<span class="built_in">setWidth</span>(<span class="number">10</span>);  <span class="comment">// 画笔宽度</span></span><br><span class="line">QGraphicsRectItem *item = <span class="keyword">new</span> <span class="built_in">QGraphicsRectItem</span>();  <span class="comment">// 创建矩形图元对象</span></span><br><span class="line">item-&gt;<span class="built_in">setRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);  <span class="comment">// 设置矩形坐标</span></span><br><span class="line">item-&gt;<span class="built_in">setPen</span>(pen);</span><br><span class="line">item-&gt;<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>)));  <span class="comment">// QBrush用颜色填充区域</span></span><br><span class="line">item-&gt;<span class="built_in">setFlag</span>(QGraphicsItem::ItemIsMovable);  <span class="comment">// 设置可拖动</span></span><br><span class="line">scene.<span class="built_in">addItem</span>(item);  <span class="comment">// 添加到场景中</span></span><br><span class="line">QGraphicsView *view = <span class="keyword">new</span> <span class="built_in">QGraphicsView</span>(&amp;scene);  <span class="comment">// 绑定视图</span></span><br><span class="line">view-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404162444280.png" class="">

<h4 id="4-QCalendarWidget日历组件"><a href="#4-QCalendarWidget日历组件" class="headerlink" title="4.QCalendarWidget日历组件"></a>4.QCalendarWidget日历组件</h4><p>​    继承自QWidget，用于提供简易的日历界面，用于选择日期。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QCalendarWidget *calendar = <span class="keyword">new</span> <span class="built_in">QCalendarWidget</span>(&amp;w);</span><br><span class="line">calendar-&gt;<span class="built_in">setSelectedDate</span>(<span class="built_in">QDate</span>(<span class="number">2023</span>, <span class="number">4</span>, <span class="number">4</span>));  <span class="comment">// 设置显示日期</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404163727442.png" class="">

<h4 id="5-QLCDNumber-LAD数字显示框组件"><a href="#5-QLCDNumber-LAD数字显示框组件" class="headerlink" title="5.QLCDNumber LAD数字显示框组件"></a>5.QLCDNumber LAD数字显示框组件</h4><p>​    继承自QFrame，LCD数字显示框可以显示16进制、十进制、八进制或二进制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget w;</span><br><span class="line">QLCDNumber *number = <span class="keyword">new</span> <span class="built_in">QLCDNumber</span>(&amp;w);  <span class="comment">// 创建QLCDNumber对象</span></span><br><span class="line">number-&gt;<span class="built_in">setDigitCount</span>(<span class="number">20</span>);  <span class="comment">// 设置一共可以显示多少位数字</span></span><br><span class="line">number-&gt;<span class="built_in">setSegmentStyle</span>(QLCDNumber::Flat);  <span class="comment">// 设置内容扁平化显示，颜色与窗口颜色相同</span></span><br><span class="line">number-&gt;<span class="built_in">display</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404164621851.png" class="">

<h4 id="6-QProgressBar进度条组件"><a href="#6-QProgressBar进度条组件" class="headerlink" title="6.QProgressBar进度条组件"></a>6.QProgressBar进度条组件</h4><p>​    显示一个水平进度条组件，进度条是用来给用于显示操作进度的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line">QProgressBar *pbar = <span class="keyword">new</span> <span class="built_in">QProgressBar</span>(&amp;w);</span><br><span class="line">pbar-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">1000</span>);  <span class="comment">// 设置范围值</span></span><br><span class="line">pbar-&gt;<span class="built_in">setValue</span>(<span class="number">100</span>);  <span class="comment">// 设置当前值</span></span><br><span class="line">pbar-&gt;<span class="built_in">setFormat</span>(<span class="string">&quot;%p%&quot;</span>);  <span class="comment">// 设置显示内容%p%为显示百分比，为默认方式</span></span><br><span class="line">w.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230404165341816.png" class="">

<h4 id="7-QLine线条组件"><a href="#7-QLine线条组件" class="headerlink" title="7.QLine线条组件"></a>7.QLine线条组件</h4><p>​    表示平面上整数精度得二维向量，用于描述有限长度得直线也就是线段，起点和重点只具有整数精度。有一个特殊类QLineF继承自QLine，可以使用浮点精度。</p>
<h3 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h3><img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230329092940730.png" class="">

<h3 id="QDialog对话框"><a href="#QDialog对话框" class="headerlink" title="QDialog对话框"></a>QDialog对话框</h3><p>​    对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。分为模态对话框和非模态对话框：</p>
<ul>
<li>模态对话框，当对话框打开时，不能操作同一个应用程序的其他窗口，只有当对话框关闭的时候才可以操作</li>
<li>非模态对话框，即可以操作其他窗口。使用 <code>QDialog::show()</code> 实现非模态对话框</li>
</ul>
<p>​    模态对话框又分为两种级别：</p>
<ul>
<li><p>应用程序级别的模态：</p>
<p>  当这种模态的对话框出现时，用户必须先对对话框进行交互，直到关闭对话框，然后才能访问程序中的其他窗口。使用 <code>QDialog::exec()</code> 实现应用程序级别的模态对话框</p>
</li>
<li><p>窗口级别的模态</p>
<p>  该模态仅仅阻塞了与对话框关联的窗口，但是依然允许用户与程序中其他串口的交互，适用于多窗口模式。使用 <code>QDialog::open()</code> 实现窗口级别的模态对话框</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	...</span><br><span class="line">    <span class="comment">// MainWindow声明了dialog成员变量</span></span><br><span class="line">	dialog = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;hello world&quot;</span>));     <span class="comment">// 设置标题</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;dialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);    <span class="comment">// 设置关闭窗口自动析构</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;dialog-&gt;<span class="built_in">setMinimumSize</span>(<span class="built_in">QSize</span>(<span class="number">400</span>,<span class="number">400</span>));        <span class="comment">// 设置最小尺寸</span></span><br><span class="line">    QPushButton *btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;hello world&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::showDialog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::showDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//this-&gt;dialog-&gt;show();</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;dialog-&gt;<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Qt标准对话框"><a href="#Qt标准对话框" class="headerlink" title="Qt标准对话框"></a>Qt标准对话框</h3><p>​    Qt内置了一系列对话框，用于简化开发：</p>
<ul>
<li><p>QMessageBox：模态对话框</p>
</li>
<li><p>QColorDialog：选择颜色</p>
</li>
<li><p>QFontDialog：选择字体</p>
</li>
<li><p>QFileDialog：选择文件或目录</p>
</li>
<li><p>QInputDialog：允许用户输入一个值并将其返回</p>
<p>  …</p>
</li>
</ul>
<h3 id="消息对话框QMessageBox："><a href="#消息对话框QMessageBox：" class="headerlink" title="消息对话框QMessageBox："></a>消息对话框QMessageBox：</h3><p>​    下面是几个static函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于对话框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">about</span><span class="params">(QWidget* parent, <span class="type">const</span> QString&amp; title, <span class="type">const</span> QString&amp; text)</span></span>;</span><br><span class="line"><span class="comment">// 关于Qt对话框，显示Qt有关的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aboutQt</span><span class="params">((QWidget* parent, <span class="type">const</span> QString&amp; title = QString());</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 显示严重错误的对话框，显示一个红色错误符号</span></span></span></span><br><span class="line"><span class="params"><span class="function">StandardButton cirtical(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> QString &amp;title,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> QString &amp;text,</span></span></span><br><span class="line"><span class="params"><span class="function">                       	StandardButtons buttons = OK,</span></span></span><br><span class="line"><span class="params"><span class="function">                        StandardButton defaultButton = NoButton);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 显示一个黄色感叹号信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">StandardButton warning(同上);             </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 显示一个普通信息图标</span></span></span></span><br><span class="line"><span class="params"><span class="function">StandardButton information(同上);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// Question，提供一个问号图标并且显示按钮“是”和“否”</span></span></span></span><br><span class="line"><span class="params"><span class="function">StandardButton question(QWidget *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> QString &amp;title,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> QString &amp;text,</span></span></span><br><span class="line"><span class="params"><span class="function">                       	StandardButtons buttons = StandardButtons(YES|NO),</span></span></span><br><span class="line"><span class="params"><span class="function">                        StandardButton defaultButton = NoButton);</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 比如如下使用：</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (QMessageBox::Yes == QMessageBox::question(</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">this</span>, tr(<span class="string">&quot;QUESTION&quot;</span>), tr(<span class="string">&quot;Yes or NO&quot;</span>), QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        QMessageBox::information(<span class="keyword">this</span>, tr(<span class="string">&quot;Hmmm&quot;</span>), tr(<span class="string">&quot;I am glad to here thar&quot;</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;<span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        QMessageBox::information(<span class="keyword">this</span>, tr(<span class="string">&quot;Hmmm&quot;</span>), tr(<span class="string">&quot;I am sorry&quot;</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;          </span></span></span><br></pre></td></tr></table></figure>

<img src="/2023/05/06/Qt%E7%9F%A5%E8%AF%86%E7%82%B9/image-20230331103410533.png" class="">



<h3 id="标准对话框QFileDialog"><a href="#标准对话框QFileDialog" class="headerlink" title="标准对话框QFileDialog"></a>标准对话框QFileDialog</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;记事本&quot;</span>);</span><br><span class="line">    textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line"></span><br><span class="line">    QMenuBar *menuBar = <span class="keyword">this</span>-&gt;<span class="built_in">menuBar</span>();</span><br><span class="line">    QMenu *menu = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QAction *actionOpen = menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    QAction *actionSave = menu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;保存&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(actionOpen, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::openFile);</span><br><span class="line">    <span class="built_in">connect</span>(actionSave, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::saveFile);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// openFile槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    QString getOpenFileName(QWidget *parent = 0,                // 父窗口</span></span><br><span class="line"><span class="comment">                            const QString &amp;caption=QString(),   // 对话框标题</span></span><br><span class="line"><span class="comment">                            const QString &amp;dir = QString(),     // 对话框打开的默认目录 &quot;.&quot;表示程序运行目录 &quot;/&quot;代表当前盘的根目录</span></span><br><span class="line"><span class="comment">                            const QString &amp;filter = QString(),  // 过滤器，用于过率特定的后缀名，多个用;隔开：&quot;Text File(*.txt);JPEG File(*.jpg)&quot;</span></span><br><span class="line"><span class="comment">                            Options options = 0);               // 对话框的一些参数设定</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;Open File&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;Text File(*.txt)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly|QIODevice::Text)) &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;Read File&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        textEdit-&gt;<span class="built_in">setText</span>(in.<span class="built_in">readAll</span>());</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;Path&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;You did not select any file&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// saveFile槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::saveFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;Save File&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;Text File(*.txt)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly|QIODevice::Text)) &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;Write File&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        out &lt;&lt; textEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;Path&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;You did not select any file&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>​    Qt提供两种布局定位机制：静态布局与动态布局</p>
<ul>
<li><p>静态布局：给出这个组件的坐标和长宽值</p>
</li>
<li><p>动态布局：只要把组件放入某一种布局中，布局由专门的布局管理器进行管理</p>
<ul>
<li><p>QHBoxLayout：按照水平方向从左到右布局</p>
</li>
<li><p>QVBoxLayout：按照竖直方向从上到下布局</p>
</li>
<li><p>QGridLayout：在一个网格中进行布局</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QGridLayout *gLayout = <span class="keyword">new</span> QGridLayout;</span><br><span class="line">QPushButton *button1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;button1&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton *button2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;button2&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton *button3 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;button3&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QPushButton *button4 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;button4&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 设置每个组件的尺寸策略</span></span><br><span class="line">button1-&gt;<span class="built_in">setSizePolicy</span>(QSizePolicy::Expanding, QSizePolicy::Expanding);</span><br><span class="line">button2-&gt;<span class="built_in">setSizePolicy</span>(QSizePolicy::Expanding, QSizePolicy::Expanding);</span><br><span class="line">button3-&gt;<span class="built_in">setSizePolicy</span>(QSizePolicy::Expanding, QSizePolicy::Expanding);</span><br><span class="line">button4-&gt;<span class="built_in">setSizePolicy</span>(QSizePolicy::Expanding, QSizePolicy::Expanding);</span><br><span class="line"><span class="comment">// 设置组件的最小尺寸</span></span><br><span class="line">button1-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">60</span>,<span class="number">60</span>);</span><br><span class="line">button2-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">60</span>,<span class="number">60</span>);</span><br><span class="line">button3-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">60</span>,<span class="number">60</span>);</span><br><span class="line">button4-&gt;<span class="built_in">setMinimumSize</span>(<span class="number">60</span>,<span class="number">60</span>);</span><br><span class="line"><span class="comment">// 添加组件到网格布局管理器</span></span><br><span class="line">gLayout-&gt;<span class="built_in">addWidget</span>(button1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">gLayout-&gt;<span class="built_in">addWidget</span>(button2, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">gLayout-&gt;<span class="built_in">addWidget</span>(button3, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gLayout-&gt;<span class="built_in">addWidget</span>(button4, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置行和列的比例系数</span></span><br><span class="line">gLayout-&gt;<span class="built_in">setColumnStretch</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 第0列占有空间比例1倍</span></span><br><span class="line">gLayout-&gt;<span class="built_in">setColumnStretch</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 第1列占有控件比例2倍，所有0，1列的比例为1：2</span></span><br><span class="line">gLayout-&gt;<span class="built_in">setRowStretch</span>(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 第0行占有空间比例1倍</span></span><br><span class="line">gLayout-&gt;<span class="built_in">setRowStretch</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 第1行占有空间比例3倍，所以0，1行的比例为1：3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="常用控件QLabel"><a href="#常用控件QLabel" class="headerlink" title="常用控件QLabel"></a>常用控件QLabel</h3><h4 id="显示文字"><a href="#显示文字" class="headerlink" title="显示文字"></a>显示文字</h4><ul>
<li><p>显示普通文本字符串</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示HTML格式字符串</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">label-&gt;<span class="built_in">setOpenExternalLinks</span>(<span class="literal">true</span>);  <span class="comment">// 设置点击链接后是否自动打开</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//void setPixmap(const QPixmap&amp;);</span></span><br><span class="line">QPixmap pixmap;                   <span class="comment">// 声明对象</span></span><br><span class="line">pixmap.<span class="built_in">load</span>(<span class="string">&quot;:/image/boat.jpg&quot;</span>);  <span class="comment">// 加载图片</span></span><br><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(pismap);         <span class="comment">// 设置到label中</span></span><br></pre></td></tr></table></figure>

<h4 id="显示动画"><a href="#显示动画" class="headerlink" title="显示动画"></a>显示动画</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//void setMovie(QMovie *movie);</span></span><br><span class="line">QMovie *movie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;:/Mario.gif&quot;</span>);</span><br><span class="line">movie-&gt;<span class="built_in">start</span>();</span><br><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label-&gt;<span class="built_in">setMovie</span>(movie);</span><br></pre></td></tr></table></figure>

<h3 id="单行文本编辑框QLineEdit"><a href="#单行文本编辑框QLineEdit" class="headerlink" title="单行文本编辑框QLineEdit"></a>单行文本编辑框QLineEdit</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">text</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 获取编辑框内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> Qstring&amp;)</span></span>;  <span class="comment">// 设置编辑框内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEchoMode</span><span class="params">(EchoMode mode)</span></span>;  <span class="comment">// 设置文本的显示模式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">EchoMode是一个枚举类型，定义了四种显示模式</span></span><br><span class="line"><span class="comment">    QLineEdit::Normal 模式显示方式</span></span><br><span class="line"><span class="comment">    QLineEdit::NoEcho 不显示任何内容，此模式下无法看到用户的输入</span></span><br><span class="line"><span class="comment">    QLineEdit::Password 密码模式，输入的字符会根据平台转换为特殊字符</span></span><br><span class="line"><span class="comment">    QLineEdit::PasswordEchoOnEdit 编辑时显示字符否则显示字符作为密码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 指定显示文本与输入框上下左右边界间隔的像素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTextMargins</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="Qt消息事件机制"><a href="#Qt消息事件机制" class="headerlink" title="Qt消息事件机制"></a>Qt消息事件机制</h3><p>​    事件是由系统或者Qt程序本身在不同时刻发出的，比如按下鼠标，敲下键盘或者窗口需要重新绘制的时候，都会发出一个相应的事件。</p>
<h4 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h4><p>​    在所有组件的父类QWidget中，有很多事件处理函数：</p>
<ul>
<li>keyPressEvent()：键盘按下事件</li>
<li>keyReleaseEvent()：键盘松开事件</li>
<li>mouseDoubleClickEvent()：鼠标双击事件</li>
<li>mouseMoveEvent()：鼠标移动事件</li>
<li>mousePressEvent()：鼠标按键按下事件</li>
<li>mouseReleaseEvent()：鼠标按键松开事件</li>
<li>…</li>
</ul>
<p>​    这些函数都是protected virtual的，也就是我们可以在子类中重新实现这些函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 鼠标移动事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Move:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(</span><br><span class="line">                      QString::<span class="built_in">number</span>(ev-&gt;<span class="built_in">x</span>()), QString::<span class="built_in">number</span>(ev-&gt;<span class="built_in">y</span>())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鼠标点击事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(</span><br><span class="line">                      QString::<span class="built_in">number</span>(ev-&gt;<span class="built_in">x</span>()), QString::<span class="built_in">number</span>(ev-&gt;<span class="built_in">y</span>())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鼠标释放事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg;</span><br><span class="line">    msg.<span class="built_in">asprintf</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Release:(%d, %d)&lt;/h1&gt;&lt;/center&gt;&quot;</span>, ev-&gt;<span class="built_in">x</span>(), ev-&gt;<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用如下</span></span><br><span class="line">...</span><br><span class="line">    EventLabel *evlabel = <span class="keyword">new</span> EventLabel;</span><br><span class="line">    evlabel-&gt;<span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);  <span class="comment">// 是否直接追踪鼠标，默认为false，表示需要至少点击一次后才会被追踪</span></span><br><span class="line">    evlabel-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;MouseEvent Demo&quot;</span>);</span><br><span class="line">    evlabel-&gt;<span class="built_in">resize</span>(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">    evlabel-&gt;<span class="built_in">show</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="事件分发函数event"><a href="#事件分发函数event" class="headerlink" title="事件分发函数event()"></a>事件分发函数event()</h4><p>​    事件对象创建完毕后，Qt将这个事件对象传递给QObject的event()函数，event()函数并不直接处理事件，而是将这些事件对象按照他们不同的类型，分发给不同得事件处理器(event handler)。</p>
<p>​    如果希望在事件分发之前做一些操作，那么就需要重写这个event函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要调用父类的event()继续转发，否则这个组件只能处理我们定义的事件了</span></span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果传入的事件已被识别并处理，则返回true，否则返回false；如果返回true，那么Qt会认为这个事件已经被处理完毕，不会将这个对象发送给其他对象，而是会继续处理事件队列中的下一个事件</li>
<li>在event()函数中，调用事件对象的accept()和ignore()是没有作用的，不会影响到事件的传播</li>
</ul>
<p>​    QObject::event()本质就是调用switch-case来进行判断和事件处理（调用相应的事件处理器）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//!!! Qt5</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QObject::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::Timer:</span><br><span class="line">        <span class="built_in">timerEvent</span>((QTimerEvent*)e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QEvent::ChildAdded:</span><br><span class="line">    <span class="keyword">case</span> QEvent::ChildPolished:</span><br><span class="line">    <span class="keyword">case</span> QEvent::ChildRemoved:</span><br><span class="line">        <span class="built_in">childEvent</span>((QChildEvent*)e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() &gt;= QEvent::User) &#123;</span><br><span class="line">            <span class="built_in">customEvent</span>(e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h3><p>​    对象需要查看、甚至拦截发送到另外对象的事件，Qt提供了另外一种机制来达到这一目的：事件过滤器：<br>​    事件过滤器主要是解决以下两个问题：</p>
<ul>
<li>由于event()是protected，event()需要继承已经有的类，如果组件很多，就要重写很多个event函数，这很麻烦。并且还有一个问题，就是如果基于第三方的库进行开发，而对方没有提供源码，只有一个链接库，其他都是封装好的，怎么去继承这种库中的组件问题。</li>
<li>有时希望某些组件根部看不见某些事件，event()只能做到阻拦，但是本质也是接受到了对象。使用过滤器可以让它收都收不到。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eventFilter()函数用于建立事件过滤器</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QObject::eventFilter</span><span class="params">(QObject *watched, QEvent *evnet)</span></span>;</span><br><span class="line"><span class="comment">// installEventFilter()用于安装过滤器(类似注册监听红黑树)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::installEventFilter</span><span class="params">(QObject *filter *filterObj)</span></span>;</span><br><span class="line"><span class="comment">// removeEventFilter()用于移除已经存在的过滤器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QObject::removeEventFilter</span><span class="params">(QObject *obj)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QTextEdit *textEdit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line">    textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == textEdit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line">            QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Are key press&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">key</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// pass the event on to the parent class</span></span><br><span class="line">        <span class="keyword">return</span> QMainWindow::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>ps：事件过滤器和被安装过滤器的组件必须在同一线程创建，否则过滤器不起作用。如果在安装过滤器后，这两个组件到了不同的线程，那么只有等二者重新回到同一线程的时候过滤器才有效。</strong></p>
<h3 id="Qt的五种事件处理方式"><a href="#Qt的五种事件处理方式" class="headerlink" title="Qt的五种事件处理方式"></a>Qt的五种事件处理方式</h3><ul>
<li>重写mousePressEvent()等事件处理函数</li>
<li>重写event()函数，记得如果没有触发需要处理的事件需要调用父类的event()来转发</li>
<li>在特定的对象上安装事件过滤器，该过滤器仅过滤该对象接收到的事件</li>
<li>在 <code>QCoreApplication::instance()</code> 上安装事件过滤器，该过滤器会过滤所有事件的所有对象。但是全局过滤器有一个问题，只能用在主线程</li>
<li>重写QCoreApplication::notify()函数，这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程控制。但是在全局范围只能由一个被使用，因为CoreApplication是单例模式的</li>
</ul>
<h3 id="Qt源码事件处理过程调用函数"><a href="#Qt源码事件处理过程调用函数" class="headerlink" title="Qt源码事件处理过程调用函数"></a>Qt源码事件处理过程调用函数</h3><ol>
<li><p>进入QApplication事件循环</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();  <span class="comment">// 进入QApplication事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入QCoreApplication事件循环</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QApplication::exec</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_ACCESSIBILITY</span></span><br><span class="line">    QAccessible::<span class="built_in">setRootObject</span>(qAPP);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 简单的交给QCoreApplication来处理事件循环</span></span><br><span class="line">    <span class="keyword">return</span> QCoreApplication::<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入QEventLoop事件队列循环</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QCoreApplication::exec</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!QCoreApplicationPrivate::<span class="built_in">checkInstance</span>(<span class="string">&quot;exec&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//得到当前Thread数据  </span></span><br><span class="line">    QThreadData *threadData = self-&gt;<span class="built_in">d_func</span>()-&gt;threadData;</span><br><span class="line">    <span class="keyword">if</span> (threadData != QThreadData::<span class="built_in">current</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;%s::exec: Must be called from the main thread&quot;</span>, self-&gt;<span class="built_in">metaObject</span>()-&gt;<span class="built_in">className</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//检查event loop是否已经创建 </span></span><br><span class="line">    <span class="keyword">if</span> (!threadData-&gt;eventLoops.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;QCoreApplication::exec: The event loop is already running&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    threadData-&gt;quitNow = <span class="literal">false</span>;</span><br><span class="line">    QEventLoop eventLoop;</span><br><span class="line">    self-&gt;<span class="built_in">d_func</span>()-&gt;in_exec = <span class="literal">true</span>;</span><br><span class="line">    self-&gt;<span class="built_in">d_func</span>()-&gt;aboutToQuitEmitted = <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">//委任QEventLoop 处理事件队列循环</span></span><br><span class="line">    <span class="type">int</span> returnCode = eventLoop.<span class="built_in">exec</span>();</span><br><span class="line">    threadData-&gt;quitNow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        self-&gt;<span class="built_in">d_func</span>()-&gt;in_exec = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!self-&gt;<span class="built_in">d_func</span>()-&gt;aboutToQuitEmitted)</span><br><span class="line">            emit self-&gt;<span class="built_in">aboutToQuit</span>();</span><br><span class="line">        self-&gt;<span class="built_in">d_func</span>()-&gt;aboutToQuitEmitted = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">sendPostedEvents</span>(<span class="number">0</span>, QEvent::DeferredDelete);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入QEventLoop::processEvents</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QEventLoop::exec</span><span class="params">(ProcessEventsFlags flags)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QEventLoop);  <span class="comment">//访问QEventloop私有类实例d</span></span><br><span class="line">    <span class="comment">//we need to protect from race condition with QThread::exit</span></span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;<span class="keyword">static_cast</span>&lt;QThreadPrivate *&gt;(QObjectPrivate::get(d-&gt;threadData-&gt;thread))-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;threadData-&gt;quitNow)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (d-&gt;inExec) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;QEventLoop::exec: instance %p has already called exec()&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d-&gt;inExec = <span class="literal">true</span>;</span><br><span class="line">    d-&gt;exit = <span class="literal">false</span>;</span><br><span class="line">    ++d-&gt;threadData-&gt;loopLevel;</span><br><span class="line">    d-&gt;threadData-&gt;eventLoops.<span class="built_in">push</span>(<span class="keyword">this</span>);</span><br><span class="line">    locker.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">// remove posted quit events when entering a new event loop</span></span><br><span class="line">    QCoreApplication *app = QCoreApplication::<span class="built_in">instance</span>();</span><br><span class="line">    <span class="keyword">if</span> (app &amp;&amp; app-&gt;<span class="built_in">thread</span>() == <span class="built_in">thread</span>())</span><br><span class="line">        QCoreApplication::<span class="built_in">removePostedEvents</span>(app, QEvent::Quit);</span><br><span class="line">    <span class="comment">//这里的实现代码不少，最为重要的是以下几行 </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(QT_NO_EXCEPTIONS)</span></span><br><span class="line">    <span class="keyword">while</span> (!d-&gt;exit)</span><br><span class="line">        <span class="built_in">processEvents</span>(flags | WaitForMoreEvents | EventLoopExec);<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!d-&gt;exit)  <span class="comment">//只要没有遇见exit，循环派发事件 </span></span><br><span class="line">            <span class="built_in">processEvents</span>(flags | WaitForMoreEvents | EventLoopExec);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;Qt has caught an exception thrown from an event handler. Throwing\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;exceptions from an event handler is not supported in Qt. You must\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;reimplement QApplication::notify() and catch all exceptions there.\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// copied from below        locker.relock();</span></span><br><span class="line">        QEventLoop *eventLoop = d-&gt;threadData-&gt;eventLoops.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">Q_ASSERT_X</span>(eventLoop == <span class="keyword">this</span>, <span class="string">&quot;QEventLoop::exec()&quot;</span>, <span class="string">&quot;internal error&quot;</span>);</span><br><span class="line">        <span class="built_in">Q_UNUSED</span>(eventLoop); <span class="comment">// --release warning</span></span><br><span class="line">        d-&gt;inExec = <span class="literal">false</span>;</span><br><span class="line">        --d-&gt;threadData-&gt;loopLevel;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// copied above    locker.relock();</span></span><br><span class="line">    QEventLoop *eventLoop = d-&gt;threadData-&gt;eventLoops.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">Q_ASSERT_X</span>(eventLoop == <span class="keyword">this</span>, <span class="string">&quot;QEventLoop::exec()&quot;</span>, <span class="string">&quot;internal error&quot;</span>);</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(eventLoop); <span class="comment">// --release warning</span></span><br><span class="line">    d-&gt;inExec = <span class="literal">false</span>;</span><br><span class="line">    --d-&gt;threadData-&gt;loopLevel;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> d-&gt;returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件处理QEventDispatcherWin32::processEvents</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QEventLoop::processEvents</span><span class="params">(ProcessEventsFlags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QEventLoop);</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;threadData-&gt;eventDispatcher)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DeferredDeletion)</span><br><span class="line">        QCoreApplication::<span class="built_in">sendPostedEvents</span>(<span class="number">0</span>, QEvent::DeferredDelete);</span><br><span class="line"><span class="comment">//将事件派发给与平台相关的QAbstractEventDispatcher子类 </span></span><br><span class="line">    <span class="keyword">return</span> d-&gt;threadData-&gt;eventDispatcher-&gt;<span class="built_in">processEvents</span>(flags);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将获取的事件打包为消息，传递给操作系统：AbstractEventDispatcher的子类QEventDispatcherWin32获得用户的输入事件，并将其打包成message后，通过标准的Windows API传递给Windows OS</p>
</li>
<li><p>操作系统将事件发回给Qt平台</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">LRESULT QT_WIN_CALLBACK <span class="title">QtWndProc</span><span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将消息重新封装成QEvent的子类QMouseEvent ==&gt; Section 8</span></span><br><span class="line">         result = widget-&gt;<span class="built_in">translateMouseEvent</span>(msg);</span><br><span class="line">         ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将操作系统打包的事件解包，翻译成QApplication可识别的事件</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QApplicationPrivate::sendMouseEvent</span><span class="params">(QWidget *receiver, QMouseEvent *event,</span></span></span><br><span class="line"><span class="params"><span class="function">  QWidget *alienWidget, QWidget *nativeWidget,QWidget **buttonDown,  QPointer&lt;QWidget&gt; &amp;lastMouseReceiver,<span class="type">bool</span> spontaneous)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (spontaneous)</span><br><span class="line">        result = QApplication::<span class="built_in">sendSpontaneousEvent</span>(receiver, event);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = QApplication::<span class="built_in">sendEvent</span>(receiver, event);</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据事件类型发送事件</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QApplicationPrivate::sendMouseEvent</span><span class="params">(QWidget *receiver, QMouseEvent *event,</span></span></span><br><span class="line"><span class="params"><span class="function">  QWidget *alienWidget, QWidget *nativeWidget,QWidget **buttonDown,  QPointer&lt;QWidget&gt; &amp;lastMouseReceiver,<span class="type">bool</span> spontaneous)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (spontaneous)</span><br><span class="line">        result = QApplication::<span class="built_in">sendSpontaneousEvent</span>(receiver, event);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = QApplication::<span class="built_in">sendEvent</span>(receiver, event);</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送事件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">QCoreApplication::sendSpontaneousEvent</span><span class="params">(QObject *receiver, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">      <span class="comment">//将event标记为自发事件</span></span><br><span class="line">     <span class="comment">//进一步调用 2-5 QCoreApplication::notifyInternal     </span></span><br><span class="line">      <span class="keyword">if</span> (event) </span><br><span class="line">          event-&gt;spont = <span class="literal">true</span>; </span><br><span class="line">      <span class="keyword">return</span> self ? self-&gt;<span class="built_in">notifyInternal</span>(receiver, event) : <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程内事件的处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCoreApplication::notifyInternal</span><span class="params">(QObject *receiver, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// 以下代码主要意图为Qt强制事件只能够发送给当前线程里的对象，也就是说receiver-&gt;d_func()-&gt;threadData应该等于QThreadData::current()。</span></span><br><span class="line">    <span class="comment">//注意，跨线程的事件需要借助Event Loop来派发</span></span><br><span class="line">    QObjectPrivate *d = receiver-&gt;<span class="built_in">d_func</span>();</span><br><span class="line">    QThreadData *threadData = d-&gt;threadData;</span><br><span class="line">    ++threadData-&gt;loopLevel;</span><br><span class="line">    QT_TRY &#123;</span><br><span class="line">        returnValue = <span class="built_in">notify</span>(receiver, event);</span><br><span class="line">    &#125; <span class="built_in">QT_CATCH</span> (...) &#123;</span><br><span class="line">        --threadData-&gt;loopLevel;</span><br><span class="line">        QT_RETHROW;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件的派发：任何线程的任何对象的所有事件在发送时都会调用notify函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCoreApplication::notify</span><span class="params">(QObject *receiver, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_D</span>(QCoreApplication);</span><br><span class="line">    <span class="comment">// no events are delivered after ~QCoreApplication() has started</span></span><br><span class="line">    <span class="keyword">if</span> (QCoreApplicationPrivate::is_app_closing)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="number">0</span>) &#123;                        <span class="comment">// serious error</span></span><br><span class="line">        <span class="built_in">qWarning</span>(<span class="string">&quot;QCoreApplication::notify: Unexpected null receiver&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QT_NO_DEBUG</span></span><br><span class="line">    d-&gt;<span class="built_in">checkReceiverThread</span>(receiver);<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> receiver-&gt;<span class="built_in">isWidgetType</span>() ? <span class="literal">false</span> : d-&gt;<span class="built_in">notify_helper</span>(receiver, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用事件过滤器对发送的对象进行处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QCoreApplicationPrivate::notify_helper</span><span class="params">(QObject *receiver, QEvent * event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// send to all application event filters</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sendThroughApplicationEventFilters</span>(receiver, event))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">// 向事件过滤器发送该事件，这里介绍一下Event Filters. 事件过滤器是一个接受即将发送给目标对象所有事件的对象。 </span></span><br><span class="line">    <span class="comment">//如代码所示它开始处理事件在目标对象行动之前。过滤器的QObject::eventFilter（）实现被调用，能接受或者丢弃过滤</span></span><br><span class="line">    <span class="comment">//允许或者拒绝事件的更进一步的处理。如果所有的事件过滤器允许更进一步的事件处理，事件将被发送到目标对象本身。</span></span><br><span class="line">    <span class="comment">//如果他们中的一个停止处理，目标和任何后来的事件过滤器不能看到任何事件。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sendThroughObjectEventFilters</span>(receiver, event))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> receiver-&gt;<span class="built_in">event</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件派发至QObject的子类QWidget</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QWidget::event</span><span class="params">(QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line">        <span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseButtonPress:</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">        <span class="built_in">resetInputContext</span>();</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">mousePressEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="绘图系统"><a href="#绘图系统" class="headerlink" title="绘图系统"></a>绘图系统</h3><p>​    Qt的绘图系统基于QPatinter、QPaintDevice、QPaintEngine三个类实现，QPainter用来执行绘制操作，QPaintDevice是一个二维空间的抽象，允许QPainter在其上面进行绘制，也就是QPainter工作的空间，QPaintEngine提供了在不同设备上进行绘制的统一的接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaintedWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PaintedWidget</span>(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">PaintedWidget::<span class="built_in">PaintedWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Paint Demo&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PaintedWidget::paintEvent</span><span class="params">(QPaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="number">80</span>, <span class="number">100</span>, <span class="number">650</span>, <span class="number">500</span>);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::red);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">400</span>);</span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QPen</span>(Qt::green, <span class="number">5</span>));</span><br><span class="line">    painter.<span class="built_in">setBrush</span>(Qt::blue);</span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="number">50</span>, <span class="number">150</span>, <span class="number">400</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h3><p>​    绘图设备是指继承QPaintDevice的子类。Qt一共提供四种这样的类，分别为：</p>
<ul>
<li>QPixmap，专门为图像在屏幕上的显示做了优化</li>
<li>QBitmap，是QPixmap的一个子类，他的色深限定为1，可以使用QPismap的isQBitmap()来确定这个QPismap是不是一个QBitmap</li>
<li>QImage，专门为图像的像素级访问做了优化</li>
<li>QPicture，可以记录可重视QPainter的各条命令</li>
</ul>
<h4 id="QPixmap"><a href="#QPixmap" class="headerlink" title="QPixmap"></a>QPixmap</h4><p>​    继承了QPaintDevice，可以使用QPainter直接在上面绘制图形，也可以接受一个文件名来显示这个文件。QPixmap针对屏幕进行特殊优化，因此，它与实际的底层显示设备息息相关，在不同的操作平台下，QPixmap的显示有所不同。</p>
<h4 id="QBitmap"><a href="#QBitmap" class="headerlink" title="QBitmap"></a>QBitmap</h4><p>​    继承自QPixmap，因此具有QPixmap的所有属性，提供单色图像，QBitmap的色深始终为1，表示他所显示的颜色只有黑白两种，所以说Qbitmap实际上是只有黑白两色的图像数据。由于QBitmap色深小，因此只占用很少的空间，所以适合做光标文件和笔刷。</p>
<h4 id="QImage"><a href="#QImage" class="headerlink" title="QImage"></a>QImage</h4><p>​    QImage主要用于图像I&#x2F;O、图片访问和像素修改而设计的，由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程种对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度，与QPixmap可以互相转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QPixmap <span class="title">fromImage</span><span class="params">(<span class="type">const</span> QImage &amp;image, Qt::ImageConversionFlags flags = Qt::AutoColor;</span></span></span><br><span class="line"><span class="params"><span class="function">QImage toImage() <span class="type">const</span>;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="QPicture"><a href="#QPicture" class="headerlink" title="QPicture"></a>QPicture</h4><p>​    这是一个可以记录和重现QPainter命令的绘图设备，QPicture将QPainter的命令序列化到一个I&#x2F;O设备，保存为一个平台独立的文件格式。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>QIODevice：所有I&#x2F;O设备的父类，提供了字节块读写的通用操作以及基本接口</li>
<li>QFileDevice：Qt5新增的类，提供了有关文件操作的通用实现</li>
<li>QFile：访问本地文件或者嵌入资源</li>
<li>QTemporaryFile：创建和访问本地文件系统的临时文件</li>
<li>QBuffer：读写QbyteArray，内存文件</li>
<li>QProcess：运行外部程序，处理进程间通信</li>
<li>QAbstractSocket：所有套接字类的父类</li>
<li>QTcpSocket：Tcp协议网络数据传输</li>
<li>QUdpSocket：Udp协议网络数据传输</li>
<li>QSslSocket：使用SSL&#x2F;TLS传输数据</li>
</ul>
<p>​    文件系统分为以下两类：</p>
<ul>
<li><p>顺序访问设备</p>
<p>  是指他们的数据只能访问一遍，从头走到尾，从第一个字节开始访问，直到最后一个字节，中途不能返回读取上一个字节，QProcess、QTcpSocket、QUdpSocket、QSslSocket是顺序访问设备</p>
</li>
<li><p>随机访问设备</p>
<p>  可以访问任意位置任意次数，还可以使用QIODevice::seek()函数来重新定位文件访问位置指针，QFile、QTemporaryFule和QBuffer是随机访问设备</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    QString s = QDir::<span class="built_in">currentPath</span>();  <span class="comment">// 获得应用程序执行时的当前路径</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; s; </span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;in.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly|QIODevice::Text)) &#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Open file failed.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!file.<span class="built_in">atEnd</span>()) &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; file.<span class="built_in">readLine</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">QFileInfo <span class="title">info</span><span class="params">(file)</span></span>;  <span class="comment">// 使用QFileInfo获取有关该文件的信息</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">isDir</span>();             <span class="comment">// 是否为目录</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">isExecutable</span>();      <span class="comment">// 检查文件是否可执行</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">baseName</span>();          <span class="comment">// 直接获取文件名</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">completeBaseName</span>();  <span class="comment">// 获取完整的文件名</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">suffix</span>();            <span class="comment">// 直接获取文件后缀</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; info.<span class="built_in">completeSuffix</span>();    <span class="comment">// 获取完整的文件后缀</span></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    QFileInfo fi(&quot;/tmp/archive.tar.gz&quot;);</span></span><br><span class="line"><span class="comment">    QString base  = fi.baseName();  // base = &quot;archive&quot;</span></span><br><span class="line"><span class="comment">    QString base  = fi.completeBaseName();  // base = &quot;archive.tar&quot;</span></span><br><span class="line"><span class="comment">    QString ext   = fi.suffix();  // ext = &quot;gz&quot;</span></span><br><span class="line"><span class="comment">    QString ext   = fi.completeSuffix();  // ext = &quot;tar.gz&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h3><p>​    QDataStream提供了基于QIODevice的二进制数据的序列化，数据流是一种二进制流，这种流完全不依赖底层操作系统、CPU或字节顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;file.dat&quot;</span>)</span></span>;</span><br><span class="line">file.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line"><span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">out &lt;&lt; <span class="built_in">QString</span>(<span class="string">&quot;the answer is&quot;</span>);</span><br><span class="line">out &lt;&lt; (qint32)<span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h3 id="文本文件读写"><a href="#文本文件读写" class="headerlink" title="文本文件读写"></a>文本文件读写</h3><p>​    操作文本文件需要使用QTextStream，它会将Unicode编码同操作系统的编码进行转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QFile <span class="title">data</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (data.<span class="built_in">open</span>(QFile::WriteOnly | QIODevice::Truncate)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;data)</span></span>;</span><br><span class="line">    out.<span class="built_in">setCodec</span>(<span class="string">&quot;UTF-8&quot;</span>);  <span class="comment">// 设置编码，默认为Unicode</span></span><br><span class="line">    out &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">QTextStream::<span class="built_in">readline</span>();</span><br><span class="line">QTextStream::<span class="built_in">readAll</span>();</span><br></pre></td></tr></table></figure>

<p>​    open()中有一些打开方式，为枚举值存储的打开方式：</p>
<ul>
<li>QIODevice::ReadOnly：只读方式打开</li>
<li>QIODevice::WriteOnly：只写方式打开</li>
<li>QIODevice::NotOpen：未打开</li>
<li>QIODevice::ReadWrite：读写方式打开</li>
<li>QIODevice::Append：以追加方式打开，新增的内容将被追加到文件末尾</li>
<li>QIODevice::Truncate：以重写方式打开，再写入新的数据时会将原有的数据全部清除，游标设置在文件开头</li>
<li>QIODevice::Text：在读取时，将行结束符转换为\n；在写入时，将结束符转换成本地格式</li>
<li>QIODevice::Unbuffered：忽略缓存</li>
</ul>
<h3 id="Qt多线程"><a href="#Qt多线程" class="headerlink" title="Qt多线程"></a>Qt多线程</h3><p>​    每个程序启动后拥有的第一个线程成为主线程，即GUI线程，Qt中所有的组件类和其他几个相关的类只能工作在GUI线程，不能工作在子线程，子线程主要负责处理GUI卸下的工作。每个线程都有自己的栈空间，因此每个线程都要自己调用历史和本地变量，线程共享相同的地址空间。Qt中的线程类包含如下：</p>
<ul>
<li>QThread：提供了跨平台的多线程解决方案</li>
<li>QThreadStorage：提供了逐线程数据存储</li>
<li>QMutex：提供相互排斥的锁，或互斥量</li>
<li>QMutexLocker：是一个辅助类，自动对QMutex加锁与解锁</li>
<li>QReadWriteLock：提供一个可以同时读操作的锁</li>
<li>QReadLocker，QWriteLocker：自动对QReadWriteLock加锁解锁</li>
<li>QSemaphore：提供了一个整型信号量，是互斥量的泛化</li>
<li>QWaitCondtion：提供了一种方法，使得线程可以被另外线程唤醒前一直休眠</li>
</ul>
<h4 id="1-QThread线程"><a href="#1-QThread线程" class="headerlink" title="1.QThread线程"></a>1.QThread线程</h4><p>​    QThread是Qt线程中的一个公共抽象类，所有的线程类都是从QThread抽象类中派生出来的，需要实现QThread中的虚函数run()，通过start()调用run()：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QThread::<span class="built_in">QThread</span>(QObject *parent=Q_NULLPTR);  <span class="comment">// 构造</span></span><br><span class="line">[<span class="keyword">virtual</span> <span class="keyword">protected</span>] <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;  <span class="comment">// 线程体函数，用于定义线程的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(Priority priority=InheritPriority)</span></span>;  <span class="comment">// 线程启动函数，用于将线程入口地址设置为run函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> returnCode=<span class="number">0</span>)</span></span>;  <span class="comment">// 退出线程的工作函数，一般调用后不会直接退出，因为可能有任务还未完成</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;  <span class="comment">// 一般在exit后调用wait，等待任务完成退出线程，即阻塞线程</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span></span>;  <span class="comment">// 强制结束线程，不保证数据完整性和资源释放</span></span><br><span class="line">[slot] <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;  <span class="comment">// 退出子线程</span></span><br><span class="line">QCoreApplication::<span class="built_in">exec</span>();  <span class="comment">// 总是在主线程中被调用，不能从一个QThread中调用</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">started</span><span class="params">()</span></span>;  <span class="comment">// 线程启动时发送的信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">finished</span><span class="params">()</span></span>;  <span class="comment">// 线程结束时发送的信号</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRunning</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 子线程是否在执行任务</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFinished</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 线程中的任务是否处理完毕</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">int</span> <span class="title">currentThreadId</span><span class="params">()</span></span>;  <span class="comment">// 返回标识当前正在执行的线程，返回线程的ID</span></span><br><span class="line">[<span class="type">static</span>] <span class="function">QThread* <span class="title">currentThread</span><span class="params">()</span></span>;  <span class="comment">// 同上，返回线程指针</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">msleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span></span>;	<span class="comment">// 单位: 毫秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> secs)</span></span>;	<span class="comment">// 单位: 秒</span></span><br><span class="line">[<span class="type">static</span>] <span class="function"><span class="type">void</span> <span class="title">usleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span></span>;	<span class="comment">// 单位: 微秒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPriority</span><span class="params">(Priority priority)</span></span>;  <span class="comment">// 设置正在运行线程的优先级</span></span><br></pre></td></tr></table></figure>

<p>​    线程优先级：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QThread::IdlePriority          <span class="number">0</span><span class="comment">// 最低的优先级</span></span><br><span class="line">QThread::LowestPriority        <span class="number">1</span>   </span><br><span class="line">QThread::LowPriority           <span class="number">2</span></span><br><span class="line">QThread::NormalPriority        <span class="number">3</span> </span><br><span class="line">QThread::HighPriority          <span class="number">4</span></span><br><span class="line">QThread::HighestPriority       <span class="number">5</span></span><br><span class="line">QThread::TimeCriticalPriority  <span class="number">6</span><span class="comment">// 最高的优先级</span></span><br><span class="line">QThread::InheritPriority       <span class="number">7</span><span class="comment">// 子线程和其父线程的优先级相同, 默认是这个</span></span><br></pre></td></tr></table></figure>

<h4 id="2-Mutex互斥量"><a href="#2-Mutex互斥量" class="headerlink" title="2.Mutex互斥量"></a>2.Mutex互斥量</h4><p>​    提供互斥锁或呼出量，QMutex类的所有成员函数是线程安全的，如果对没有加锁的互斥量进行解锁，结果是未定义的，加锁和解锁必须成对出现，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造函数，默认为NonRecursive模式，还有另一种Recursive模式</span></span><br><span class="line"><span class="comment">NonRecursive只能被lock一次</span></span><br><span class="line"><span class="comment">Recursive可以被lock很多次，直到相应次数的unlock调用后，才被真正的解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QMutex::<span class="built_in">QMutex</span>(RecursionMode mode = NonRecursive); </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>;  <span class="comment">// 阻塞加锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>;  <span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">trylock</span><span class="params">()</span></span>;  <span class="comment">// 尝试加锁，不会被阻塞</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">trylock</span><span class="params">(inb timeout)</span></span>;  <span class="comment">// 阻塞等待timeout时间，超时则返回</span></span><br></pre></td></tr></table></figure>

<h4 id="3-QMutexLocker互斥锁"><a href="#3-QMutexLocker互斥锁" class="headerlink" title="3.QMutexLocker互斥锁"></a>3.QMutexLocker互斥锁</h4><p>​    引入QMutexLocker辅助QMutex来避免lcok与unlock操作，QMutexLocker对象创建时，把mutex指针传给这个对象，此时mutex指针已经加锁，等待释放QMutexLocker会销毁并解锁mutex：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMutexLocker::<span class="built_in">QMutexLocker</span>(QRecurisiveMutex *mutex);  <span class="comment">// 构造</span></span><br><span class="line">QMutexLocker::<span class="built_in">QMutexLocker</span>(QMutex *mutex);</span><br></pre></td></tr></table></figure>

<h4 id="4-QReadWriteLock读写操作锁"><a href="#4-QReadWriteLock读写操作锁" class="headerlink" title="4.QReadWriteLock读写操作锁"></a>4.QReadWriteLock读写操作锁</h4><p>​    允许多个读者读，但是只允许一个写，并且写读操作不同时进行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QReadWriteLock::<span class="built_in">QReadWriteLock</span>(QReadWriteLock::RecursionMode recursionMode=NonRecursive);  <span class="comment">// 构造，默认为NonRecursive</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lockForRead</span><span class="params">()</span></span>;  <span class="comment">// 上读锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lockForWrite</span><span class="params">()</span></span>;  <span class="comment">// 上写锁</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryLockForRead</span><span class="params">()</span></span>;  <span class="comment">// 尝试上读锁</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryLockForWrite</span><span class="params">()</span></span>;  <span class="comment">// 尝试上写锁</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryLockForRead</span><span class="params">(<span class="type">int</span> timeout)</span></span>;  <span class="comment">// 阻塞等待timeout时间，超时则返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryLockForWrite</span><span class="params">(<span class="type">int</span> timeout)</span></span>;  <span class="comment">// 阻塞等待timeout时间，超时则返回</span></span><br></pre></td></tr></table></figure>

<h4 id="5-QReadLocker和QWriteLocker"><a href="#5-QReadLocker和QWriteLocker" class="headerlink" title="5.QReadLocker和QWriteLocker"></a>5.QReadLocker和QWriteLocker</h4><p>​    类似QMutexLocker，二者对QReadWriteLock进行复制，在需要加读锁的地方使用QReadLocker，需要加写锁的地方使用QWriteLocker，用法和QMutexLocker差不多。</p>
<h4 id="6-信号量QSemaphore"><a href="#6-信号量QSemaphore" class="headerlink" title="6.信号量QSemaphore"></a>6.信号量QSemaphore</h4><p>​    是一个特殊的线程锁，允许多个线程同时访问临界资源，QSemaphore的所有成员函数都是现成安全的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSemaphore::<span class="built_in">QSemaphore</span>(<span class="type">int</span> n = <span class="number">0</span>);  <span class="comment">// 创建保护n个资源的信号量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">(<span class="type">int</span> n = <span class="number">1</span>)</span></span>;  <span class="comment">// 尝试用获取信号量保护的n个资源，如果n大于available()，将被阻塞等待</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">available</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回信号量当前可用资源</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(<span class="type">int</span> n = <span class="number">1</span>)</span></span>;  <span class="comment">// 释放信号量保护的n个资源</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryAcquire</span><span class="params">(<span class="type">int</span> n = <span class="number">1</span>)</span></span>;  <span class="comment">// 尝试获取n个信号量资源，不阻塞等待</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryAcquire</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> timeout)</span></span>;  <span class="comment">// 阻塞等待timeout时间，超时则返回</span></span><br></pre></td></tr></table></figure>

<h4 id="7-QWaitCondition等待条件"><a href="#7-QWaitCondition等待条件" class="headerlink" title="7.QWaitCondition等待条件"></a>7.QWaitCondition等待条件</h4><p>​    QWaitCondition允许线程在某些情况发生时唤醒另外的线程，一个或多个线程可以阻塞等待条件变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWaitCondition::<span class="built_in">QWaitCondition</span>();  <span class="comment">// 构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span></span>;  <span class="comment">// 唤醒所有等待线程(Qt5.8以后)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wakeAll</span><span class="params">()</span></span>;  <span class="comment">// 唤醒所有等待线程(Qt5.8以前)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_once</span><span class="params">()</span></span>;  <span class="comment">// 随即唤醒一个线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wakeOne</span><span class="params">()</span></span>;  <span class="comment">//随即唤醒一个线程(Qt5.8以前)</span></span><br><span class="line"><span class="comment">// 释放lockedMutex并阻塞在等待条件上直到满足条件或超时</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(QMutex *lockedMutex, <span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;</span><br><span class="line"><span class="comment">// 释放锁定的读写锁，并阻塞在条件变量上直到满足条件或超时</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(QReadWriteLock *lockedReadWriteLock, <span class="type">unsigned</span> <span class="type">long</span> time = ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="8-QThreadStroage"><a href="#8-QThreadStroage" class="headerlink" title="8.QThreadStroage"></a>8.QThreadStroage</h4><p>​    提供了每个线程数据存储的模板类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QThreadStorage::<span class="built_in">QThreadStorage</span>();  <span class="comment">// 构造</span></span><br><span class="line"><span class="comment">// 如果T是指针类型，若调用的线程有非0数据则返回true  </span></span><br><span class="line"><span class="comment">// 如果T是指类型，则返回为数据是否被setLocalData或localData构造</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QThreadStorage::hasLocalData</span><span class="params">()</span> <span class="type">const</span></span>;  </span><br><span class="line"><span class="function">T&amp; <span class="title">localData</span><span class="params">()</span></span>;  <span class="comment">// 返回线程的设置的数据的引用</span></span><br><span class="line"><span class="function">T <span class="title">localData</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 返回线程的设置的数据的副本（深拷贝）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLocalData</span><span class="params">(T data)</span></span>;  <span class="comment">// 将调用线程的数据设置为data</span></span><br></pre></td></tr></table></figure>

<h3 id="QML语言"><a href="#QML语言" class="headerlink" title="QML语言"></a>QML语言</h3><p>​    QML是一种声明语言，用于描述程序界面，QML将用户界面分解成一块块小的元素，每一个元素都由很多组件构成。</p>
<h4 id="QML基础语法"><a href="#QML基础语法" class="headerlink" title="QML基础语法"></a>QML基础语法</h4><ul>
<li><p>import语句：import写在头几行，主要用于包含类型的命名空间，包含QML代码文件的目录，js代码文件</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Namespace VersionMajor.VersionMinor</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../directroy&quot;</span></span><br><span class="line"><span class="keyword">import</span> QtQuick2<span class="number">.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象声明：QML代码都定义一个对象树，所有QtQuick元素都是继承自QQuickItem，对象类型以大写字母开头，在定义对象的同时，对象的属性也会被赋初值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rectangle&#123;</span><br><span class="line">    width: <span class="number">100</span></span><br><span class="line">    height: <span class="number">100</span></span><br><span class="line">    color: <span class="string">&quot;red&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子对象：每个QML对象中可以包含无限个子对象</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rectangle&#123;</span><br><span class="line">    width: <span class="number">100</span></span><br><span class="line">    height: <span class="number">100</span></span><br><span class="line">    color: <span class="string">&quot;red&quot;</span> </span><br><span class="line">    Text&#123;</span><br><span class="line">        anchors.centerIn : parent</span><br><span class="line">        text: <span class="string">&quot;Hello QML&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释：类似c++，有两种</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模块声明：QML中每个类都单独存放一个文件，每个文件都是一个模块，但不能单独声明一个函数，函数必须写在类内，引用时以模块名引用</p>
</li>
<li><p>表达式：可以包含其他对象与属性的引用，会建立约束关联</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Item</span><br><span class="line">&#123;</span><br><span class="line">     Text</span><br><span class="line">     &#123;</span><br><span class="line">         id: text1</span><br><span class="line">         x:<span class="number">2</span>;y:<span class="number">2</span></span><br><span class="line">         text: <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">     Text</span><br><span class="line">     &#123;</span><br><span class="line">         id: text2</span><br><span class="line">         x:<span class="number">2</span>;y:<span class="number">20</span></span><br><span class="line">         text: text1.text</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号处理器：允许响应事件时处理动作</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MouseArea&#123;</span><br><span class="line">    acceptedButtons: Qt.LeftButton | Qt.RightButton</span><br><span class="line">    onPressed:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mouse.button == Qt.RightButton)</span><br><span class="line">            console.<span class="built_in">log</span>(<span class="string">&quot;right mouse button pressed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="基本的可视化项"><a href="#基本的可视化项" class="headerlink" title="基本的可视化项"></a>基本的可视化项</h4><p>​    可视元素具有几何坐标，会在屏幕上占据一块显示区域：</p>
<ul>
<li>Item：基本的项元素，所有可视化项都继承自Item</li>
<li>Rectangle：基本的可视化矩形元素，在Item的基础上增加了填充色属性、边框相关的属性</li>
<li>Gradient：定义一个两种颜色的渐变过程</li>
<li>GradientStop：定义一个颜色，被Gradient使用</li>
<li>Image：在场景中使用位图</li>
<li>BorderImage：定义一张图片作为边界</li>
<li>AnimatedImage：为播放动画存储一系列的帧</li>
<li>Text：在场景中使用文本</li>
<li>TextEdit：显示多行可编辑文本</li>
<li>TextInput：显示可编辑为文本</li>
<li>IntValidatorint：验证器</li>
<li>DoubleValidator：double验证器</li>
<li>RegExpValidator：验证字符串正则表达式</li>
</ul>
<h4 id="基本的交互项"><a href="#基本的交互项" class="headerlink" title="基本的交互项"></a>基本的交互项</h4><p>​    不可视元素通常提供一种作用于可视元素的功能：</p>
<ul>
<li>MouseArea：鼠标句柄交互</li>
<li>FocusScope：键盘焦点句柄</li>
<li>Flickable：提供一种浏览整张图片的一部分的效果</li>
<li>Flipable：提供一个平面，可以进行翻转看前面或后面</li>
</ul>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul>
<li>State：定义一个配置对象和属性的集合</li>
<li>PropertyChanges：使用一个State描述属性的改变</li>
<li>StateGroup：包含一个状态集合和状态变换</li>
<li>ParentChange：重新定义父集，也就是换父节点</li>
<li>AnchorChanges：在一个状态中改变anchors</li>
</ul>
<h4 id="动画和变换"><a href="#动画和变换" class="headerlink" title="动画和变换"></a>动画和变换</h4><p>​    有很多…</p>
<h3 id="QML与c-混合编程（交互）"><a href="#QML与c-混合编程（交互）" class="headerlink" title="QML与c++混合编程（交互）"></a>QML与c++混合编程（交互）</h3><p>​    QML访问c++有两个方法：</p>
<ol>
<li><p>在Qt元对象系统中注册c++类，在QML中实例化、访问，使c++类在QML中作为一个数据类型使用</p>
<p> ​    信号在QML中使用和普通函数一样</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++类实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>: <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function"><span class="title">Q_ENUMS</span><span class="params">(Color)</span>  <span class="comment">// 枚举类型需要Q_ENUMS,在QML中使用&#x27;.&#x27;操作符直接访问枚举变量</span></span></span><br><span class="line"><span class="function"><span class="comment">// 属性声明,需要使用Q_PROPERTY宏，属性同类的数据成员一样，但又有额外的特性可通过Qt元对象系统来访问，READ读取属性值，WRITE设置属性值，NOTIFY与属性关联的可选信号</span></span></span><br><span class="line"><span class="function"><span class="title">Q_PROPERTY</span><span class="params">(Color color READ color WRITE setColor NOTIFY colorChanged)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    Hello() : m_color(RED)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Hello() is called.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">    &#123;</span><br><span class="line">        RED,</span><br><span class="line">        BLUE,</span><br><span class="line">        BLACK</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// QML如果要访问的成员函数必须为public或protected且使用Q_INVOKABLE宏</span></span><br><span class="line">    <span class="function">Q_INVOKABLE <span class="type">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;show() is called.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(<span class="type">const</span> Color&amp; color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(color != m_color)</span><br><span class="line">    	&#123;</span><br><span class="line">        	m_color = color;</span><br><span class="line">        	<span class="function">emit <span class="title">colorChanged</span><span class="params">()</span></span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Hello::dosomething() is called.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">colorChanged</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Color m_color;  <span class="comment">// 属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HELLO_H</span></span></span><br></pre></td></tr></table></figure>

<p> ​    将c++类注册到Qt元对象系统</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册C++类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQmlApplicationEngine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtQml&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  <span class="comment">//注册C++类型Hello</span></span><br><span class="line">  <span class="built_in">qmlRegisterType</span>&lt;Hello&gt;(<span class="string">&quot;Hello.module&quot;</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  QQmlApplicationEngine engine;</span><br><span class="line">  engine.<span class="built_in">load</span>(<span class="built_in">QUrl</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;qrc:/main.qml&quot;</span>)));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ​    在QML文件中导入注册的c+类：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.2</span></span><br><span class="line"><span class="comment">//导入注册的C++类</span></span><br><span class="line"><span class="keyword">import</span> Hello.<span class="keyword">module</span> <span class="number">1.0</span></span><br><span class="line"> </span><br><span class="line">Window &#123;</span><br><span class="line">    visible: <span class="literal">true</span></span><br><span class="line">    width: <span class="number">640</span></span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    title: <span class="built_in">qsTr</span>(<span class="string">&quot;Hello QML&quot;</span>)</span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            hello.<span class="built_in">begin</span>() <span class="comment">//单击鼠标调用begin信号函数</span></span><br><span class="line">            hello.<span class="built_in">show</span>()</span><br><span class="line">            hello.color = <span class="number">2</span> <span class="comment">// 修改属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Hello&#123;</span><br><span class="line">        id:hello   <span class="comment">//Hello类的实例</span></span><br><span class="line">        onBegin:<span class="built_in">doSomething</span>()</span><br><span class="line">        onColorChanged:console.<span class="built_in">log</span>(<span class="string">&quot;color changed.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在c++中实例化并设置QML上下文属性，在QML中直接使用</p>
<p> ​    先实例化在注册为QML上下文属性</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QGuiApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQuickView&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QQmlContext&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">  </span><br><span class="line">  QQuickView view;</span><br><span class="line">  Hello hello;</span><br><span class="line">  view.<span class="built_in">rootContext</span>()-&gt;<span class="built_in">setContextProperty</span>(<span class="string">&quot;hello&quot;</span>, &amp;hello);</span><br><span class="line">  view.<span class="built_in">setSource</span>(<span class="built_in">QUrl</span>(<span class="built_in">QStringLiteral</span>(<span class="string">&quot;qrc:///main.qml&quot;</span>)));</span><br><span class="line">  view.<span class="built_in">show</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ​    在main.qml中不能使用Hello来实例化，也不能调用doSomething()槽函数，因为doSomething()中的枚举类型是访问不到的，通过设置的QML上下文属性“hello”类访问c++，此时信号处理函数需要用Connections来处理</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.5</span></span><br><span class="line"> </span><br><span class="line">Item &#123;</span><br><span class="line">    width: <span class="number">640</span></span><br><span class="line">    height: <span class="number">480</span></span><br><span class="line">    MouseArea &#123;</span><br><span class="line">        anchors.fill: parent</span><br><span class="line">        onClicked: &#123;</span><br><span class="line">            hello.<span class="built_in">begin</span>()<span class="comment">//单击鼠标调用begin信号函数</span></span><br><span class="line">            hello.<span class="built_in">show</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Connections&#123;</span><br><span class="line">       target:hello</span><br><span class="line">       onBegin:console.<span class="built_in">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​     在c++中加载QML文件可以用QQMLComponent或QQucikView，然后就可以在c++中访问QML对象，QQuickView提供了一个显示用户界面的窗口，而QQMLComponent没有。</p>
<p>​    c++想要被QML访问，必须满足两个条件：</p>
<ol>
<li>派生自QObject类或为QObject类的子类</li>
<li>使用Q_OBJECT宏</li>
</ol>
<h3 id="Qt容器类"><a href="#Qt容器类" class="headerlink" title="Qt容器类"></a>Qt容器类</h3><p>​    Qt容器类分为顺序式容器与关联式容器:</p>
<p>顺序式容器：</p>
<ul>
<li>QList：最常用的容器类，在前后添加元素很快，可以以下标的方式对数据项进行访问。</li>
<li>QLinkedList：链式列表，数据项不使用连续的内存存储的，基于迭代器访问</li>
<li>QVector：动态数组，以下标索引访问数据</li>
<li>QStack：类似堆栈后入先出操作的容器</li>
<li>QQueue：类似队列先入先出操作的容器</li>
</ul>
<p>关联式容器：</p>
<ul>
<li>QMap：提供一个字典（关联数组），一个键映射一个值，存储顺序为键的顺序</li>
<li>QMultiMap：QMap的子类，允许处理多值映射的便利类，不支持’[]‘操作符</li>
<li>QHash：基于散列表实现的字典功能的模板类</li>
<li>QMultiHash：QHash的子类，用于处理多值映射的便利类，用法与QMultiMap类似</li>
<li>QSet：基于散列表的集合模板类，存储顺序不定，查找速度很快，内部是基于QHash实现的</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>MusicPlayer</title>
    <url>/2023/05/14/MusicPlayer/</url>
    <content><![CDATA[<h1 id="Qt实现的音乐播放器"><a href="#Qt实现的音乐播放器" class="headerlink" title="Qt实现的音乐播放器"></a>Qt实现的音乐播放器</h1><p>windows平台下基于Qt Creator 4.11.1实现的类网易云移动端播放界面的音乐播放器。</p>
<p>guthub:<a href="https://github.com/ZzBobo0915/Qt/tree/main/MusciPlayer">https://github.com/ZzBobo0915/Qt/tree/main/MusciPlayer</a></p>
<img src="/2023/05/14/MusicPlayer/image-20230514185428792.png" class="" title="音乐播放器">

<ul>
<li>实现了根据歌曲播放、暂停、上一首、下一首、播放模式（单曲循环、随机播放、队列循环）、歌词显示、歌曲进度改变（滑动条）、音量增大和音量减小（按钮与滑动条）、关闭提示等基本功能</li>
<li>实现了黑胶底片和摇杆的动态改变</li>
<li>实现了根据打开播放器的时间来实现系统菜单栏显示<img src="/2023/05/14/MusicPlayer/image-20230514185747669.png" class=""></li>
<li>实现了高斯模糊背景的实现</li>
<li>整个程序的UI布局全部使用代码书写，没有使用到Qt设计师工具</li>
</ul>
<h2 id="标题栏titlewindow-h-x2F-cpp"><a href="#标题栏titlewindow-h-x2F-cpp" class="headerlink" title="标题栏titlewindow.h&#x2F;cpp"></a>标题栏titlewindow.h&#x2F;cpp</h2><ul>
<li>最小化</li>
<li>最大化（没用上）</li>
<li>关闭</li>
<li>鼠标界面拖动</li>
</ul>
<p>​    部分主要代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="comment">// 进行最小化、最大化/还原、关闭操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onClicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关闭消息框的操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onbuttonClicked</span><span class="params">(QAbstractButton *btnClicked)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 双击标题栏进行界面的最大化/还原</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mouseDoubleClickEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">    <span class="comment">// 进行鼠界面的拖动</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//标题名称</span></span><br><span class="line">    QLabel *m_TitleLabel;</span><br><span class="line">    <span class="comment">//标题栏最小按钮</span></span><br><span class="line">    QPushButton *m_MinimizeButton;</span><br><span class="line">    <span class="comment">//标题栏最大按钮</span></span><br><span class="line">    QPushButton *m_MaximizeButton;</span><br><span class="line">    <span class="comment">//标题栏关闭按钮</span></span><br><span class="line">    QPushButton *m_CloseButton;</span><br><span class="line">    <span class="comment">//关闭消息框</span></span><br><span class="line">    QMessageBox *m_MessageBox;</span><br><span class="line">    <span class="comment">//消息框最小化按钮</span></span><br><span class="line">    QPushButton *m_MessageMinimize;</span><br><span class="line">    <span class="comment">//消息框关闭按钮</span></span><br><span class="line">    QPushButton *m_MessageQuit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TitleWindow::onClicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取用户点击的按钮</span></span><br><span class="line">    QPushButton *Button = <span class="built_in">qobject_cast</span>&lt;QPushButton *&gt;(<span class="built_in">sender</span>());</span><br><span class="line">    <span class="comment">//获取当前窗口指针</span></span><br><span class="line">    QWidget *Window = <span class="keyword">this</span>-&gt;<span class="built_in">window</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果小部件是独立的窗口那么返回true不然的话返回false</span></span><br><span class="line">    <span class="keyword">if</span> (Window-&gt;<span class="built_in">isWindow</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果点击的按钮是最小化</span></span><br><span class="line">        <span class="keyword">if</span> (Button == m_MinimizeButton)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//以图标的形式显示窗口</span></span><br><span class="line">            <span class="comment">//Window-&gt;showMinimized();</span></span><br><span class="line">            Window-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        &#125;<span class="comment">//如果点击的是最大化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Button == m_MaximizeButton)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//放大窗口</span></span><br><span class="line">            Window-&gt;<span class="built_in">isMaximized</span>() ? Window-&gt;<span class="built_in">showNormal</span>() : Window-&gt;<span class="built_in">showMaximized</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Button == m_CloseButton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_MessageBox-&gt;<span class="built_in">exec</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TitleWindow::onbuttonClicked</span><span class="params">(QAbstractButton *btnClicked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (btnClicked == m_MessageMinimize) &#123;</span><br><span class="line">        QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(<span class="keyword">this</span>-&gt;<span class="built_in">window</span>(), <span class="string">&quot;windowOpacity&quot;</span>);</span><br><span class="line">        animation-&gt;<span class="built_in">setDuration</span>(<span class="number">1000</span>);</span><br><span class="line">        animation-&gt;<span class="built_in">setStartValue</span>(<span class="number">1</span>);</span><br><span class="line">        animation-&gt;<span class="built_in">setEndValue</span>(<span class="number">0</span>);</span><br><span class="line">        animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">        <span class="comment">//动画结束时发出finished信号触发槽函数关闭主窗口</span></span><br><span class="line">        <span class="built_in">connect</span>(animation, <span class="built_in">SIGNAL</span>(<span class="built_in">finished</span>()), <span class="keyword">this</span>-&gt;<span class="built_in">window</span>(), <span class="built_in">SLOT</span>(<span class="built_in">hide</span>()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (btnClicked == m_MessageQuit)&#123;</span><br><span class="line">        qApp-&gt;<span class="built_in">closeAllWindows</span>();</span><br><span class="line">        qApp-&gt;<span class="built_in">quit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整个窗口随标题栏移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TitleWindow::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="comment">//释放对鼠标的捕获消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ReleaseCapture</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        QWidget *pWindow = <span class="keyword">this</span>-&gt;<span class="built_in">window</span>();</span><br><span class="line">        <span class="keyword">if</span> (pWindow-&gt;<span class="built_in">isTopLevel</span>())</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">SendMessage</span>(<span class="built_in">HWND</span>(pWindow-&gt;<span class="built_in">winId</span>()), WM_SYSCOMMAND, SC_MOVE + HTCAPTION, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       event-&gt;<span class="built_in">ignore</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="高斯模糊gaussianbur-h"><a href="#高斯模糊gaussianbur-h" class="headerlink" title="高斯模糊gaussianbur.h"></a>高斯模糊gaussianbur.h</h2><p>​    对背景图片进行高斯模糊处理，高斯模糊原理参考<a href="https://blog.csdn.net/mahabharata_/article/details/69066942">https://blog.csdn.net/mahabharata_/article/details/69066942</a></p>
<p>​    主要代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对图片做一次横向的模糊</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; in.<span class="built_in">width</span>(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; in.<span class="built_in">height</span>(); ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kx = -halfMatrixSize; kx &lt;= halfMatrixSize; ++kx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 边界处理后的x值</span></span><br><span class="line">            x1 = <span class="built_in">ReflectIndex</span>(x - kx, in.<span class="built_in">width</span>());</span><br><span class="line">            <span class="function">QColor <span class="title">color</span><span class="params">(in.pixel(x1, y))</span></span>;</span><br><span class="line">            matrixValue = mConvolutionMatrix[kx + halfMatrixSize];</span><br><span class="line">            sumRed += color.<span class="built_in">red</span>() * matrixValue;</span><br><span class="line">            sumBlue += color.<span class="built_in">blue</span>() * matrixValue;</span><br><span class="line">            sumGreen += color.<span class="built_in">green</span>() * matrixValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QRgb finalColor = <span class="built_in">qRgb</span>(sumRed, sumGreen, sumBlue);</span><br><span class="line">        <span class="comment">// 覆盖回去</span></span><br><span class="line">        image.<span class="built_in">setPixel</span>(x, y, finalColor);</span><br><span class="line">        sumRed = sumGreen = sumBlue = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对图片做一次纵向的模糊，同上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; in.<span class="built_in">width</span>(); ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; in.<span class="built_in">height</span>(); ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ky = -halfMatrixSize; ky &lt;= halfMatrixSize; ++ky)</span><br><span class="line">        &#123;</span><br><span class="line">            y1 = <span class="built_in">ReflectIndex</span>(y - ky, in.<span class="built_in">height</span>());</span><br><span class="line">            <span class="function">QColor <span class="title">color</span><span class="params">(image.pixel(x, y1))</span></span>;</span><br><span class="line">            matrixValue = mConvolutionMatrix[ky + halfMatrixSize];</span><br><span class="line">            sumRed += color.<span class="built_in">red</span>() * matrixValue;</span><br><span class="line">            sumBlue += color.<span class="built_in">blue</span>() * matrixValue;</span><br><span class="line">            sumGreen += color.<span class="built_in">green</span>() * matrixValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QRgb finalColor = <span class="built_in">qRgb</span>(sumRed, sumGreen, sumBlue);</span><br><span class="line">        image.<span class="built_in">setPixel</span>(x, y, finalColor);</span><br><span class="line">        sumRed = sumGreen = sumBlue = <span class="number">0.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存背景图片子线程cachethread-h-x2F-cpp"><a href="#缓存背景图片子线程cachethread-h-x2F-cpp" class="headerlink" title="缓存背景图片子线程cachethread.h&#x2F;cpp"></a>缓存背景图片子线程cachethread.h&#x2F;cpp</h2><p>​    创建子线程用来缓存背景图片，对音乐列表中的每一个碟片进行高斯模型并保存在cache文件中。</p>
<p>​    关键代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cachethread::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m_ResourceName.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QPixmap pixmap;</span><br><span class="line">        QString BackgroundPath;</span><br><span class="line">        BackgroundPath  =   m_ResourcePath    +   <span class="string">&quot;/&quot;</span>     +   m_ResourceName.<span class="built_in">at</span>(i) + <span class="string">&quot;.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">QFileInfo <span class="title">file</span><span class="params">(QApplication::applicationDirPath()    +   <span class="string">&quot;/Cache&quot;</span>     +</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="string">&quot;/&quot;</span>     +   m_ResourceName.at(i)    +   <span class="string">&quot;.png&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(file.<span class="built_in">exists</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pixmap.<span class="built_in">load</span>(BackgroundPath);</span><br><span class="line">        <span class="function">QSize   <span class="title">picSize</span><span class="params">(m_MainWindow-&gt;width()*<span class="number">1.2</span>,m_MainWindow-&gt;height()*<span class="number">1.2</span>)</span></span>;</span><br><span class="line">        QPixmap scaledPixmap = pixmap.<span class="built_in">scaled</span>(picSize);</span><br><span class="line">        QPixmap scaledPixmap2 = scaledPixmap.<span class="built_in">copy</span>(m_MainWindow-&gt;<span class="built_in">pos</span>().<span class="built_in">x</span>()+<span class="number">30</span>,</span><br><span class="line">                                                  m_MainWindow-&gt;<span class="built_in">pos</span>().<span class="built_in">y</span>()+<span class="number">30</span>,</span><br><span class="line">                                                  m_MainWindow-&gt;<span class="built_in">width</span>(),m_MainWindow-&gt;<span class="built_in">height</span>());</span><br><span class="line">        QImage Image = scaledPixmap2.<span class="built_in">toImage</span>();</span><br><span class="line">        QImage img = m_blur-&gt;<span class="built_in">BlurImage</span>(Image);</span><br><span class="line">        BackgroundPath  =   QApplication::<span class="built_in">applicationDirPath</span>()    +   <span class="string">&quot;/Cache&quot;</span>     +</span><br><span class="line">                <span class="string">&quot;/&quot;</span>     +   m_ResourceName.<span class="built_in">at</span>(i)    +   <span class="string">&quot;.png&quot;</span>;</span><br><span class="line">        img.<span class="built_in">save</span>(BackgroundPath);</span><br><span class="line">        m_MainWindow-&gt;<span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基类主窗口basiwindow-h-x2F-cpp"><a href="#基类主窗口basiwindow-h-x2F-cpp" class="headerlink" title="基类主窗口basiwindow.h&#x2F;cpp"></a>基类主窗口basiwindow.h&#x2F;cpp</h2><ul>
<li>阴影窗口</li>
<li>设置窗口圆角</li>
<li>自定义背景</li>
</ul>
<p>​    主要代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//阴影窗口</span></span><br><span class="line">    QWidget* m_EffectWindow;</span><br><span class="line">    <span class="comment">//窗口阴影实例</span></span><br><span class="line">    QGraphicsDropShadowEffect * m_shadow;</span><br><span class="line">    <span class="comment">//窗口主要布局</span></span><br><span class="line">    QVBoxLayout*m_VmainLayout;</span><br><span class="line">    <span class="comment">//自定义背景</span></span><br><span class="line">    <span class="type">bool</span> BackgroundState;</span><br><span class="line">    <span class="comment">//自定义背景路径</span></span><br><span class="line">    QString BackgroundPath;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//设置窗口圆角;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//设置窗口阴影</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWindowEffect</span><span class="params">(<span class="type">int</span> w,<span class="type">int</span> h)</span></span>;</span><br><span class="line">    <span class="comment">//创建标题栏</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createTitlew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//高斯背景图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写paintEvent事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Basiwindow::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);  <span class="comment">// QUNUSED用来告诉编译器其中的变量没有使用，不需要提示警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::SmoothPixmapTransform);  <span class="comment">// 线性插值</span></span><br><span class="line">    painter.<span class="built_in">setRenderHint</span>(QPainter::Antialiasing);  <span class="comment">// 反锯齿;</span></span><br><span class="line">    painter.<span class="built_in">save</span>();</span><br><span class="line">    QRect rect = <span class="keyword">this</span>-&gt;<span class="built_in">rect</span>();</span><br><span class="line">    painter.<span class="built_in">setPen</span>(Qt::transparent);</span><br><span class="line">    <span class="keyword">if</span>(BackgroundState == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">230</span>,<span class="number">230</span>,<span class="number">230</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        QPixmap blurImage;</span><br><span class="line">        <span class="comment">// 如果读取到图片</span></span><br><span class="line">        <span class="keyword">if</span>(blurImage.<span class="built_in">load</span>(BackgroundPath))</span><br><span class="line">        &#123;</span><br><span class="line">            m_blurImage     =   blurImage.<span class="built_in">toImage</span>();</span><br><span class="line"></span><br><span class="line">            QBrush brush;</span><br><span class="line">            brush.<span class="built_in">setTextureImage</span>(<span class="built_in">QImage</span>(m_blurImage));</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line">            <span class="comment">//painter.drawImage(-150,-150,m_blurImage,0,0,this-&gt;width()*2,this-&gt;height()*2);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有读取到则默认黑色</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            painter.<span class="built_in">setBrush</span>(<span class="built_in">QBrush</span>(<span class="built_in">QColor</span>(<span class="number">230</span>,<span class="number">230</span>,<span class="number">230</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rect.<span class="built_in">setWidth</span>(rect.<span class="built_in">width</span>());</span><br><span class="line">    rect.<span class="built_in">setHeight</span>(rect.<span class="built_in">height</span>());</span><br><span class="line">    painter.<span class="built_in">drawRoundedRect</span>(rect, <span class="number">8</span>, <span class="number">8</span>);  <span class="comment">// 绘制带有圆角的矩形，8为圆度，0时为直角，99时为最大圆度</span></span><br><span class="line">    QWidget::<span class="built_in">paintEvent</span>(event);           <span class="comment">// 转发到基类的事件处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="胶片、摇杆区域mylovewindow-h-x2F-cpp"><a href="#胶片、摇杆区域mylovewindow-h-x2F-cpp" class="headerlink" title="胶片、摇杆区域mylovewindow.h&#x2F;cpp"></a>胶片、摇杆区域mylovewindow.h&#x2F;cpp</h2><ul>
<li>胶片的动态转动</li>
<li>摇杆的改变</li>
</ul>
<p>​    主要代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//黑胶片的timer</span></span><br><span class="line">    QTimer *        m_RestoreCover;</span><br><span class="line">    <span class="comment">//回复杆的timer</span></span><br><span class="line">    QTimer *        m_RecoveryRod;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>             m_Increasing;</span><br><span class="line">    QString         m_Love;</span><br><span class="line">    <span class="comment">//黑胶片转动的角度，会有定时器来改变它</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//转动杆的转动角度，会有定时器来改变它</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置音乐封面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCoverSeting</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//绘制事件，所有的动态实现就在这里面实现的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLoveWindow::changeCover</span><span class="params">()</span><span class="comment">//转动黑胶片的槽函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">360</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLoveWindow::changeRod</span><span class="params">()</span><span class="comment">//摇杆改变的槽函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    j-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_RecoveryRod-&gt;<span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理歌词、播放时间的子线程thread-h-x2F-cpp"><a href="#处理歌词、播放时间的子线程thread-h-x2F-cpp" class="headerlink" title="处理歌词、播放时间的子线程thread.h&#x2F;cpp"></a>处理歌词、播放时间的子线程thread.h&#x2F;cpp</h2><ul>
<li>歌词的动态改变</li>
<li>播放时间的动态改变</li>
</ul>
<p>​    代码都很主要，在github中产看，这里是重点！</p>
<h2 id="主窗口dialog-h-x2F-cpp"><a href="#主窗口dialog-h-x2F-cpp" class="headerlink" title="主窗口dialog.h&#x2F;cpp"></a>主窗口dialog.h&#x2F;cpp</h2><p>​    继承自basiwindow.h把功能都集成到一起，并设计UI布局。</p>
<p>参考：<a href="https://blog.csdn.net/NVAS_CN/article/details/122658874">https://blog.csdn.net/NVAS_CN/article/details/122658874</a></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt-socket</title>
    <url>/2023/06/01/Qt-socket/</url>
    <content><![CDATA[<h1 id="Qt中的Tcp网络通信"><a href="#Qt中的Tcp网络通信" class="headerlink" title="Qt中的Tcp网络通信"></a>Qt中的Tcp网络通信</h1><p>​    Qt中的Tcp网络通信使用的是Qt封装的Tcp&#x2F;IP的客户端与服务端的类，想要使用需要在.pro中添加以下内容：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Qt  += network</span><br></pre></td></tr></table></figure>

<h2 id="QTcpServer类"><a href="#QTcpServer类" class="headerlink" title="QTcpServer类"></a>QTcpServer类</h2><p>​    QTcpServer，继承自QObject，用于服务端监听和建立与客户端的连接：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTcpServer::<span class="built_in">QTcpServer</span>(QObject* parent=<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 设置监听的地址与套接字，QHostAddress::Any表示自定绑定，端口为0表示自动选择一个端口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::listen</span><span class="params">(<span class="type">const</span> QHostAddress &amp;address=QHostAddress::Any, qunit16 port = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 判断是否在监听</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::isListening</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回当前正在监听的服务器地址信息，没有则返回QHostAddress::Null </span></span><br><span class="line"><span class="function">QHostAddress <span class="title">QTcpServer::serverAddress</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 返回当前正在监听的端口，没有则返回0</span></span><br><span class="line"><span class="function">quint16 <span class="title">QTcpServer::serverPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 获取客户端连接的套接字对象</span></span><br><span class="line"><span class="function">QTcpSocket *<span class="title">QTcpServer::nextPendingConnection</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 阻塞等待客户端发起连接请求，msec表示最大阻塞时间ms，timedOut为传出参数，超时为true</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QTcpServer::waitForNewConnection</span><span class="params">(<span class="type">int</span> msec = <span class="number">0</span>, <span class="type">bool</span> *timedOut = Q_NULLPTR)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="QTcpSocket类"><a href="#QTcpSocket类" class="headerlink" title="QTcpSocket类"></a>QTcpSocket类</h2><p>​    QTcpSocket类为一个套接字通信类，继承自QAbstractSocket类，QAbstractSocket类继承自QIODevice类，客户端和服务端都要使用。</p>
<p>​    在 Qt 中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由 Qt 框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTcpSocket::<span class="built_in">QTcpSocket</span>(QObject *parent = <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 连接服务器，指定hostName与port</span></span><br><span class="line">[<span class="keyword">virtual</span>] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connectToHost</span><span class="params">(<span class="type">const</span> QString &amp;hostName, quint16 port,OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol)</span></span>;</span><br><span class="line"><span class="comment">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::read</span><span class="params">(<span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 指定可接收的最大字节数 maxSize，返回接收的字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QIODevice::read</span><span class="params">(qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 将当前可用操作数据全部读出，通过返回值返回读出的字符串</span></span><br><span class="line"><span class="function">QByteArray <span class="title">QIODevice::readAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 发送指针 data 指向的内存中的 maxSize 个字节的数据</span></span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data, qint64 maxSize)</span></span>;</span><br><span class="line"><span class="comment">// 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span>;</span><br><span class="line"><span class="comment">// 发送参数指定的字符串</span></span><br><span class="line"><span class="function">qint64 <span class="title">QIODevice::write</span><span class="params">(<span class="type">const</span> QByteArray &amp;byteArray)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>QTcpSocket通信中，使用信号传递双方的状态与要进行的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readyRead()说明对端发送的数据到达了，接下来可以用read函数接收数据</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QIODevice::readyRead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// connectToHost连接成功，发出connected()信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::connected</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 套接字断开连接发出disconnected()信号</span></span><br><span class="line">[signal] <span class="function"><span class="type">void</span> <span class="title">QAbstractSocket::disconnected</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol>
<li>创建套接字服务器 QTcpServer 对象</li>
<li>通过 QTcpServer 对象设置监听，即：QTcpServer::listen()</li>
<li>基于 QTcpServer::newConnection() 信号检测是否有新的客户端连接</li>
<li>如果有新的客户端连接调用 QTcpSocket *QTcpServer::nextPendingConnection() 得到通信的套接字对象</li>
<li>使用通信的套接字对象 QTcpSocket 和客户端进行通信</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Tcp服务端&quot;</span>);</span><br><span class="line">    ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8899&quot;</span>);</span><br><span class="line">    ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听对象</span></span><br><span class="line">    tcpServer = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(tcpServer, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_tcp = tcpServer-&gt;<span class="built_in">nextPendingConnection</span>();</span><br><span class="line">        <span class="comment">//m_status-&gt;setPixmap(QPixmap(&quot;:/connect.jpg&quot;).scaled(20, 20));</span></span><br><span class="line">        m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;已连接&quot;</span>);</span><br><span class="line">        ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;用户连接了服务器!&quot;</span>);</span><br><span class="line">        <span class="comment">// 检测是否可以接受数据</span></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            QByteArray data = m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">            ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端say:&quot;</span>+data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">            <span class="comment">//m_tcp-&gt;deleteLater();  // 封装了delete操作</span></span><br><span class="line">            <span class="comment">//m_status-&gt;setPixmap(QPixmap(&quot;:/disconnect.jpg&quot;).scaled(20, 20));</span></span><br><span class="line">            m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;未连接&quot;</span>);</span><br><span class="line">            ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">            ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;用户断开了服务器!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态栏</span></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;</span><br><span class="line">    <span class="comment">//m_status-&gt;setPixmap(QPixmap(&quot;:/disconnect.jpg&quot;).scaled(20, 20));</span></span><br><span class="line">    m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;未连接&quot;</span>);</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态:&quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_setListen_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();</span><br><span class="line">    tcpServer-&gt;<span class="built_in">listen</span>(QHostAddress::Any, port);</span><br><span class="line">    ui-&gt;setListen-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendMessage_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    QString msg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());</span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务器say:&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li><p>创建通信的套接字类 QTcpSocket 对象</p>
</li>
<li><p>使用服务器端绑定的 IP 和端口连接服务器 QAbstractSocket::connectToHost()</p>
</li>
<li><p>使用 QTcpSocket 对象和服务器进行通信</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Tcp客户端&quot;</span>);</span><br><span class="line">    m_tcp = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8899&quot;</span>);</span><br><span class="line">    ui-&gt;ip-&gt;<span class="built_in">setText</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    ui-&gt;disconnectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">       QByteArray data = m_tcp-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">       ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务端say:&quot;</span>+data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [=]&#123;</span><br><span class="line">        m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">//m_tcp-&gt;deleteLater();</span></span><br><span class="line">        <span class="comment">//m_status-&gt;setPixmap(QPixmap(&quot;:/disconnect.jpg&quot;).scaled(20,20));</span></span><br><span class="line">        m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;未连接&quot;</span>);</span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;断开连接!&quot;</span>);</span><br><span class="line">        ui-&gt;connectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">        ui-&gt;disconnectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">       m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/connect.jpg&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">       m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;已连接&quot;</span>);</span><br><span class="line">       ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;已经成功连接了服务器！&quot;</span>);</span><br><span class="line">       ui-&gt;connectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">       ui-&gt;disconnectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">       ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态栏</span></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;</span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.jpg&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态:&quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_connectBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString ip = ui-&gt;ip-&gt;<span class="built_in">text</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(ip), port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendMessage_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());</span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端say:&quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_disconnectBtn_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_tcp-&gt;<span class="built_in">close</span>();</span><br><span class="line">    m_status-&gt;<span class="built_in">setText</span>(<span class="string">&quot;未连接&quot;</span>);</span><br><span class="line">    ui-&gt;connectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);</span><br><span class="line">    ui-&gt;disconnectBtn-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">    ui-&gt;sendMessage-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/2023/06/01/Qt-socket/image-20230601114255964.png" class="" title="image-20230601114255964">
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>QML-Component</title>
    <url>/2023/06/26/QML-Component/</url>
    <content><![CDATA[<h1 id="QML-Component详解"><a href="#QML-Component详解" class="headerlink" title="QML-Component详解"></a>QML-Component详解</h1><p>​    Component（组件）是Qt QML中的重要元素，用于定义可重用的QML元素，可以视作为自定义控件，要注意：</p>
<ul>
<li>Component只能包含一个顶层的Item或者实例，而且这个在Item之外不能定义除了id以外的任何数据</li>
<li>Component通常用来给一个视图（ListView等）提供图形化组件</li>
<li>Component不是Item的派生类，而是从QQmlComponent继承而来的，虽然它通过自己的顶层Item为其他的View提供可视化组件，但它本身不是可见元素</li>
</ul>
<p>​    下面是Component在视图中的一个应用</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">    <span class="title">ColumnLayout</span>&#123;</span><br><span class="line">        <span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line">        <span class="title">Item</span>&#123;</span><br><span class="line">            <span class="attribute">Layout.fillWidth</span>: <span class="literal">true</span></span><br><span class="line">            <span class="attribute">Layout.preferredHeight</span>: <span class="number">150</span></span><br><span class="line">            <span class="title">MusicBorderImage</span>&#123;</span><br><span class="line">                <span class="attribute">anchors.centerIn</span>: <span class="built_in">parent</span></span><br><span class="line">                <span class="attribute">height</span>: <span class="number">100</span></span><br><span class="line">                <span class="attribute">width</span>: <span class="number">100</span></span><br><span class="line">                <span class="attribute">borderRadius</span>: <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 列表菜单</span></span><br><span class="line">        <span class="title">ListView</span>&#123;</span><br><span class="line">            <span class="comment">//id: menuListView</span></span><br><span class="line">            <span class="attribute">id:</span><span class="string"> menuView</span></span><br><span class="line">            <span class="attribute">height</span>: <span class="built_in">parent</span>.height</span><br><span class="line">            <span class="attribute">Layout.fillHeight</span>: <span class="literal">true</span></span><br><span class="line">            <span class="attribute">Layout.fillWidth</span>: <span class="literal">true</span></span><br><span class="line">            <span class="attribute">model</span>: <span class="title">ListModel</span>&#123;</span><br><span class="line">                <span class="attribute">id:</span><span class="string"> menuViewModel</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">delegate</span>: menuViewDelegate</span><br><span class="line">            <span class="attribute">highlight</span>: <span class="title">Rectangle</span>&#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="string">&quot;#f1efed&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">highlightMoveDuration</span>: <span class="number">10</span>    <span class="comment">// 设置切换列表中的变形时间</span></span><br><span class="line">            <span class="attribute">highlightResizeDuration</span>: <span class="number">10</span>  <span class="comment">// 设置下拉列表的变形时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Component作为代理为ListView提供可视化组件</span></span><br><span class="line">    <span class="title">Component</span> &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> menuViewDelegate</span></span><br><span class="line">        <span class="title">Rectangle</span>&#123;</span><br><span class="line">            <span class="attribute">id:</span><span class="string"> menuViewDelegateItem</span></span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200</span></span><br><span class="line">            <span class="attribute">height</span>: <span class="number">50</span></span><br><span class="line">            <span class="attribute">color</span>: menuView.isCurrentItem?<span class="string">&quot;#f1efed&quot;</span>:<span class="string">&quot;#ffffff&quot;</span></span><br><span class="line">            <span class="title">RowLayout</span>&#123;</span><br><span class="line">                <span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line">                <span class="attribute">anchors.centerIn</span>: <span class="built_in">parent</span></span><br><span class="line">                <span class="attribute">spacing</span>: <span class="number">15</span></span><br><span class="line">                <span class="title">Item</span>&#123;</span><br><span class="line">                   <span class="attribute">width</span>: <span class="number">30</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title">Image</span>&#123;</span><br><span class="line">                    <span class="attribute">source</span>: <span class="string">&quot;qrc:/images/&quot;</span>+icon</span><br><span class="line">                    <span class="attribute">Layout.preferredHeight</span>: <span class="number">20</span></span><br><span class="line">                    <span class="attribute">Layout.preferredWidth</span>: <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title">Text</span>&#123;</span><br><span class="line">                    <span class="attribute">text</span>: value</span><br><span class="line">                    <span class="attribute">Layout.fillWidth</span>: <span class="literal">true</span></span><br><span class="line">                    <span class="attribute">height</span>: <span class="number">50</span></span><br><span class="line">                    <span class="attribute">font.family</span>: <span class="built_in">window</span>.mFONT_FAMILY</span><br><span class="line">                    <span class="attribute">font.pointSize</span>: <span class="number">12</span></span><br><span class="line">                    <span class="attribute">color</span>: <span class="string">&quot;#000000&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// onCompleted表示</span></span><br><span class="line">    <span class="attribute">Component.onCompleted</span>: &#123;</span><br><span class="line">        menuViewModel.append(qmlList.filter(item=&gt;item.menu))</span><br><span class="line">        <span class="keyword">var</span> loader = repeater.itemAt(defaultIndex)</span><br><span class="line">        loader.visible = <span class="literal">true</span></span><br><span class="line">        loader.source = qmlList[defaultIndex].qml + <span class="string">&quot;.qml&quot;</span></span><br><span class="line">        menuView.currentIndex = defaultIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为一个嵌入式的Component必须用Loader来显示</span></span><br><span class="line"><span class="title">Repeater</span>&#123;  <span class="comment">// 重复构造</span></span><br><span class="line">    <span class="attribute">id:</span><span class="string"> repeater</span></span><br><span class="line">    <span class="attribute">model</span>: qmlList.length  <span class="comment">// filter过滤</span></span><br><span class="line">    <span class="title">Loader</span> &#123;</span><br><span class="line">       <span class="attribute">visible</span>: <span class="literal">false</span></span><br><span class="line">       <span class="attribute">Layout.fillWidth</span>: <span class="literal">true</span></span><br><span class="line">       <span class="attribute">Layout.fillHeight</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-1:回顾</title>
    <url>/2023/07/03/TinyWebServer-1/</url>
    <content><![CDATA[<h1 id="从零开始实现C-TinyWebServer-①"><a href="#从零开始实现C-TinyWebServer-①" class="headerlink" title="从零开始实现C++TinyWebServer-①"></a>从零开始实现C++TinyWebServer-①</h1><p>​    记录一下重新学习c++11新标准构建的TinyWebServer！</p>
<p>参考代码地址：<a href="https://github.com/ZzBobo0915/TinyWebServer/blob/master">https://github.com/ZzBobo0915/TinyWebServer/blob/master</a></p>
<h2 id="什么是WebServer"><a href="#什么是WebServer" class="headerlink" title="什么是WebServer"></a>什么是WebServer</h2><p>​    WebServer是一种基于B&#x2F;S架构的软件程序，服务器用来处理来自客户端（浏览器）发来的HTTP请求，并对其请求进行HTTP响应：向浏览器提供HTML界面、图像、CSS和JS等Web资源。</p>
<h2 id="WebServer如何和用户进行通信"><a href="#WebServer如何和用户进行通信" class="headerlink" title="WebServer如何和用户进行通信"></a>WebServer如何和用户进行通信</h2><p>​    一个WebServer想要和用户进行通信，需要在浏览器中输入<strong>域名或IP地址:端口号</strong>，浏览器会先对你的域名解析成DNS或者直接根据你的IP地址:端口号向对应的Web服务器发送一个HTTP请求，进行三次握手连接与服务器建立连接，然后发送HTTP请求报文给服务器，这个报文中包含了请求行、请求头部、空行和主体(请求数据)四个内容，通过TCP&#x2F;TP协议发送到Web服务器上。</p>
<img src="/2023/07/03/TinyWebServer-1/web-server-16883467860613.svg" class="" title="WebServer通信过程">

<p>​    WebServer通过通过socket监听来自用户的请求：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建监听socket的文件描述符</span></span><br><span class="line"><span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 创建监听socket的TCP的IPV4地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="comment">// INADDR_ANY表示将套接字绑定到任意可用的端口</span></span><br><span class="line">address.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// SO_REUSEADDR表示端口可以重复使用</span></span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"><span class="comment">// 绑定socket和地址</span></span><br><span class="line">ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="comment">// 创建监听的队列</span></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="I-x2F-O的五种模型"><a href="#I-x2F-O的五种模型" class="headerlink" title="I&#x2F;O的五种模型"></a>I&#x2F;O的五种模型</h2><ol>
<li>阻塞I&#x2F;O：用户线程发送I&#x2F;O请求后会等待阻塞数据是否就绪，若未就绪则阻塞等待，直到数据就绪在会解除阻塞等待</li>
<li>非阻塞I&#x2F;O：用户线程发送I&#x2F;O请求后不会阻塞等待数据是否就绪，而是会不停地去请求直到有数据才进行I&#x2F;O操作，但是期间不会释放cpu资源</li>
<li>信号驱动I&#x2F;O：当用户线程需要读写操作时，给对应的套接字发送一个信号，用户线程继续执行，直到数据就绪时会发送给用户线程一个信号，用户线程接收到信号后进行I&#x2F;O操作</li>
<li>多路复用I&#x2F;O：I&#x2F;O多路复用中主线程通过轮询的方式监听多个socket状态，直到有一个或多个socket状态发生变化才会进行I&#x2F;O操作</li>
<li>异步I&#x2F;O：用户线程发送I&#x2F;O请求后，可以立刻去做别的事情，内核等待数据就绪后，就将数据拷贝到用户线程时，整个过程用户线程完全不知道I&#x2F;O操作是如何进行的</li>
</ol>
<p>​    <strong>同步I&#x2F;O与异步I&#x2F;O的区别的实质其实就是内核发送给用户线程的状态，同步I&#x2F;O中发送的是数据的就绪态，异步I&#x2F;O中发送的是数据的完成态。</strong></p>
<h2 id="如何实现一个高并发的WebServer"><a href="#如何实现一个高并发的WebServer" class="headerlink" title="如何实现一个高并发的WebServer"></a>如何实现一个高并发的WebServer</h2><p>​    使用多路复用I&#x2F;O来实现一个高并发的WebServer：</p>
<p>​    Web服务器通过socket来监听用户的请求，很多用户尝试connect()这个socket套接字，监听到的这些连接会被排队等待accept()，由于用户连接是随机到达的异步事件，每当监听socket监听到新的连接并放在监听队列中，我们都需要告诉Web服务器有连接来了，accept()这个连接并分配一个逻辑单元来处理这个用户请求。而且在处理这个请求的同时，还需要继续监听其他客户的请求并分配其另一个逻辑单元来处理，这就是并发。</p>
<p>​    Linux下可以使用三种技术来进行I&#x2F;O多路复用：select、poll、epoll。</p>
<ol>
<li>select：基于轮询机制的数组，在一段时间内，监听用户所感兴趣的套接字上的读、写和异常事件。每次调用select都需要复制两次fd_set数组，开销大；需要全部变了才知道哪些文件描述符有I&#x2F;O操作；有监听上限：32位系统最多能监听1024个文件描述符，64位为2048个；只有水平触发LT模式。</li>
<li>poll：采用链表方式替代fd_set数组，可以突破监听文件描述符的1024&#x2F;2048的上限，poll函数返回的是需要进行I&#x2F;O操作的文件描述符，只需遍历返回的数组即可，效率变高；只有水平触发LT模式。</li>
<li>epoll：在内核使用<strong>红黑树</strong>来监控所有待检测的socket，不用传入整个socket合集，只需要传入待检测的socket，减少了内核和用户空间的数据拷贝与内存分配；采用事件驱动(回调函数)机制，内核维护了一个<strong>链表</strong>来记录有事件产生的就绪事件，只将有事件发生的socket合集传递给用户态应用程序，提高了效率；支持水平触发LT与边缘触发ET。</li>
</ol>
<p>​    虽然I&#x2F;O复用可以同时监听多个socket，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外的措施，程序只能按照顺序一个一个处理文件描述符，所有可以采用线程池来实现多线程并发，为每个就绪的文件描述符分配一个逻辑单元(线程)来处理。</p>
<h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><p>​    有两种事件处理模式：</p>
<ol>
<li>Reactor模式：主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，若有则立即通知工作线程(逻辑单元)，将socket事件放入请求队列，交给工作线程处理，<strong>这个过程是同步的，读取完数据后应用进程才能处理数据。</strong></li>
<li>Proactor模式：将所有的I&#x2F;O操作都交给主线程和内核来处理，工作线程只负责处理逻辑，如主线程读操作完成后user[sockfd].read()，选择一个工作线程来处理客户请求pool-&gt;append(users+sockfd)</li>
</ol>
<p>​    通俗理解为Reactor下主线程是大老板，只负责接收和通知下属(工作线程)来处理I&#x2F;O操作，自己啥也不干；而Proactor模式下主线程是小老板，不仅需要接收，还需要自己和内核一起处理I&#x2F;O操作，交给下属(工作线程)的只是逻辑方面的内容。<strong>举个实际生活中的例子，Reactor 模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递。而在 Proactor 模式下，快递员直接将快递送到你家门口，然后通知你。</strong></p>
<p>​    无论是Reactor还是Proactor，都是一种基于【事件分发】的网络编程模式，区别是Reactor是基于【待完成】的I&#x2F;O事件，而Proactor是基于【已完成】的I&#x2F;O事件。</p>
<p>​    <strong>理论上Proactor模式更快，由于Proactor模式的异步I&#x2F;O在linux下没有异步I&#x2F;O接口，通常都是由同步I&#x2F;O模拟异步I&#x2F;O，即主线程完成读写后通知工作线程，但是意义不大，所以大部分都是采用Reactor模式。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    完成了对整个WebServer基础的基本了解，无代码，就当作复习了。</p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-2:Buffer缓冲区</title>
    <url>/2023/07/03/TinyWebServer-2/</url>
    <content><![CDATA[<h1 id="从零开始实现C-TinyWebServer-②"><a href="#从零开始实现C-TinyWebServer-②" class="headerlink" title="从零开始实现C++TinyWebServer-②"></a>从零开始实现C++TinyWebServer-②</h1><p>​    关于Buffer实质是参考了陈硕大佬的muduo库中的buffer应用，下面的内容大部分取自陈硕大佬的原话，详见：<a href="https://github.com/chenshuo/muduo">https://github.com/chenshuo/muduo</a> 和 <a href="https://blog.csdn.net/Solstice/article/details/6329080">https://blog.csdn.net/Solstice/article/details/6329080</a></p>
<hr>
<p>​    非阻塞I&#x2F;O的思想是避免阻塞在read()或write()等需要I&#x2F;O系统调用上，让一个线程等服务于多个socket连接，I&#x2F;O线程只能阻塞在I&#x2F;O多路复用函数上，如select&#x2F;poll&#x2F;epoll上，这样一来应用层的缓冲是必须有的。每个TCP scoket都要有有状态的inout buffr与output buffer。</p>
<p>​    <strong>要想程序在write操作上不阻塞，网络库必须要给每个TCP连接配置output buffer:</strong></p>
<ul>
<li>例如程序发送了100kb的数据，然而操作系统只能接受80kb，你肯定不想原地等待，因为不知道要等多久，程序应该尽快的交出控制权，返回event loop；对于应用程序而言，它并不关心数据是怎么发送的，它只管生成数据，这些应该有网络库管理，程序只管调用send()就行，网络库接管这剩下的20kb数据；这种情况下读缓冲区的必须的，把这20kb的数据保存到缓冲区的output buffer中，然后注册epollout事件，一旦socket可写就发送数据，如果还有剩余就重复以上操作，直到无数据可发送；</li>
<li>如果20kb没有发完又来了30kb，那么这30kb应该append到20kb后面，等待可写时一并写入；</li>
<li>如果缓冲区还有数据，但是程序想关闭连接，那么这时候网络库不能立刻关闭连接，而是要等到数据发送完毕再关闭，也就是后面会提到的<strong>“优雅关闭”</strong>。</li>
</ul>
<p>​    <strong>要想程序在read操作上不阻塞，网络库必须要给每个TCP连接配置input buffer:</strong></p>
<ul>
<li>TCP是一个无边界的字节流协议，接收方会经常碰到“收到的数据构不成一条完整的消息”、“一次收到两条消息的数据”等情况；当网络库处理socket可读事件时，必须一次性把socket里的数据读完（从操作系统buffer搬到应用层buffer），否则会反复出发POLLIN事件，那么对于“数据不完整”的情况，收到的数据通常是先放在input buffer中，等构成一条完整的消息时再通知程序的业务逻辑；这种情况下写缓冲区的必须的。</li>
</ul>
<h2 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h2><p>​    缓冲区类，设计源自moduo库：</p>
<ul>
<li>对外的接口为 <code>ReadFd(int fd, int* Errno)</code> 与 <code>WriteFd(int fd, int* Errno)</code></li>
<li>往buffer写时是writeIndex移动</li>
<li>从buffer读时是readIndex移动</li>
<li>外部写入fd时是将buffer中的readable写入fd</li>
<li>外部读取fd时是读取到writeable的位置</li>
<li>有一个prependabel空间，让程序能以很低的代价在数据<strong>前面</strong>添加几个字节</li>
<li><code>prependable = readIndex</code></li>
<li><code>readable = writeIndex-readIndex</code></li>
<li><code>writeable = size()-writeIndex</code></li>
</ul>
<img src="/2023/07/03/TinyWebServer-2/Buffer%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.gif" class="" title="Buffer的数据结构">

<p>​    <strong>ps:补充一下基础， <code>size_t</code>是无符号整型，在32位系统上长度为4个字节，64位长度位8个字节；<code>ssize_t</code>为有符号整型，32位系统上等同于int，64位等同于long int；一般采用ssize_t来表示可以被执行读写操作的数据块的大小。</strong></p>
<h2 id="实现与代码"><a href="#实现与代码" class="headerlink" title="实现与代码"></a>实现与代码</h2><p>​    <strong>WebServer中，客户端连接发来的Http请求(放到conn的读缓冲区)以及回复给客户端的响应报文(放在conn的写缓冲区)，都需要通过缓冲区来进行；以vector容器作为底层实体，封装一些方法用来实现自己的buffer缓冲区，满足读写需要。</strong></p>
<h3 id="ivoec结构体的使用"><a href="#ivoec结构体的使用" class="headerlink" title="ivoec结构体的使用"></a>ivoec结构体的使用</h3><p> iovec定义了一个向量元素，这个结构体用于一个多元素的数组，每一个元素的 <code>iov_base</code> 指向一个缓冲区，这个缓冲区存放的是网络接收的数据(read)或网络将要发送的数据(write)。<code>iov_len</code> 存放接收数据的最大长度或者写入数据的实际长度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> iov_base;</span><br><span class="line">    <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    在linux中，使用iovec的结构体变量作为参数的函数很多，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// iovcnt表示iovec数组的大小</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span>, fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p><strong>buffer.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Data    : 2023/07/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>  <span class="comment">// perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span> <span class="comment">// readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Buffer</span>(<span class="type">int</span> initBufferSize = <span class="number">1024</span>);</span><br><span class="line">	~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回三段区域可用的大小</span></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 获取读指针</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">EnsureWritable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;  <span class="comment">// 确保可写长度</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取len数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">	<span class="comment">// 读取到end位置</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line">	<span class="comment">// 取出所有数据</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="comment">// 取出剩余所有数据</span></span><br><span class="line">	<span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写指针位置</span></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加到缓冲区中</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;  <span class="comment">// 将读下表位置添加到写下标</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// httpconn中调用的读写接口</span></span><br><span class="line">	<span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">sszie_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// buffer的开头</span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>;  </span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// 扩展空间</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;  </span><br><span class="line"></span><br><span class="line">	std::vector&lt;<span class="type">char</span>&gt; buffer_;  <span class="comment">// buffer缓冲区的存储实体</span></span><br><span class="line">	std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_;  <span class="comment">// 读的下标，即readIndex</span></span><br><span class="line">	std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;  <span class="comment">// 写的下表，即writeIndex</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !BUFFER_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>buffer.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Data    : 2023/07/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数初始化</span></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> initBufferSize) : <span class="built_in">buffer_</span>(initBufferSize), <span class="built_in">readPos_</span>(<span class="number">0</span>), <span class="built_in">writePos_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeable长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readable长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> writePos_ - readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留空间prependable的长度</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读指针</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;buffer_[readPos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保可写长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWritable</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 判断可写长度是否够用，不够用则扩充</span></span><br><span class="line">	<span class="keyword">if</span> (len &gt; <span class="built_in">WritableBytes</span>()) <span class="built_in">MakeSpace_</span>(len);</span><br><span class="line">	<span class="built_in">assert</span>(len &lt;= <span class="built_in">WritableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动写下标，在Append中使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	writePos_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取len数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	readPos_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取到end位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end);</span><br><span class="line">	<span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>());  <span class="comment">// 长度=end指针-读指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除所有数据后的操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">bzero</span>(&amp;buffer_[<span class="number">0</span>], buffer_.<span class="built_in">size</span>());  <span class="comment">// 覆盖原有数据(清空数据)</span></span><br><span class="line">	readPos_ = writePos_ = <span class="number">0</span>;  <span class="comment">// 位置归0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取剩余可读的str</span></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::string <span class="title">str</span><span class="params">(Peek(), ReadableBytes())</span></span>;</span><br><span class="line">	<span class="built_in">RetrieveAll</span>();  <span class="comment">// 读取完后清空</span></span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;buffer_[writePos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;buffer_[writePos_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加字符串到缓冲区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(str);</span><br><span class="line">	<span class="built_in">EnsureWritable</span>(len);  <span class="comment">// 确保可写长度</span></span><br><span class="line">	std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());  <span class="comment">// 将str放到写下标开始的地方</span></span><br><span class="line">	<span class="built_in">HasWritten</span>(len);  <span class="comment">// 移动写下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面三个调用上面的Append(cosnt char*,size_t)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Append</span>(str.<span class="built_in">c_str</span>(), str.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将buff中读下标的位置放在写当前buffer的写下标开始位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读接口：</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">65535</span>];  <span class="comment">// 栈区</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];  <span class="comment">// 缓冲区</span></span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">WritableBytes</span>();</span><br><span class="line">	<span class="comment">// 分散读，保证数据全部读完</span></span><br><span class="line">	iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginWrite</span>();</span><br><span class="line">	iov[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">	iov[<span class="number">1</span>].iov_base = buff;</span><br><span class="line">	iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff);</span><br><span class="line"></span><br><span class="line">	<span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		*Errno = errno;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 小于说明写区可以容纳len</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writable) &#123;</span><br><span class="line">		writePos_ += len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写区满了，下标移动到最后</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		writePos_ = buffer_.<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">Append</span>(buff, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len - writable));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写接口：</span></span><br><span class="line"><span class="function"><span class="type">sszie_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// write(int handle, void *buf, int nbyte);</span></span><br><span class="line">	<span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd, <span class="built_in">Peek</span>(), <span class="built_in">ReadableBytes</span>());</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		*Errno = errno;</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Retrieve</span>(len);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;buffer_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;buffer_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// len大于当前buffer_空间，直接扩充buffer_</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len) &#123;</span><br><span class="line">		buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 若小于等于，则将readPos_到writePos_数据拷贝至最前面</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">		srd::<span class="built_in">copy</span>(<span class="built_in">BeginPtr_</span>() + readPos_, <span class="built_in">BeginPtr_</span>() + writePos_, <span class="built_in">BeginPtr_</span>());</span><br><span class="line">		readPos_ = <span class="number">0</span>;</span><br><span class="line">		writePos_ = readable;</span><br><span class="line">		<span class="built_in">asserr</span>(readable == ReadableBytes);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>​    外部使用的主要接口为<code>ReadFd</code>与 <code>WriteFd</code>，调用这两个接口进行I&#x2F;O的读写操作，这两个接口直接调用read()&#x2F;write()、readv()&#x2F;writev()来实现。</p>
<p>​    至此Buffer类的所有内容就都完成啦！</p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-3:日志模块</title>
    <url>/2023/07/03/TinyWebServer-3/</url>
    <content><![CDATA[<h1 id="从零开始实现c-TinyWebServer-③"><a href="#从零开始实现c-TinyWebServer-③" class="headerlink" title="从零开始实现c++TinyWebServer-③"></a>从零开始实现c++TinyWebServer-③</h1><p>​    上次我们把缓冲区写完了，这次我们来写日志系统：日志系统可以方便我们进行项目的调试、错误定位与分析等。需要设计一个异步日志模块来顺利写日志但是又不占用主线程时间去写。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​    单例模式是设计模式中最常用的一个，目的是保证一个类只有一个实例并且提供一个他的全局访问点，该实例被所有代码块共享，在构造这种类的时候构造函数和析构函数都应放在private中。</p>
<p>​    单例模式有两种实现方法：<strong>懒汉单例模式</strong>与<strong>饿汉单例模式</strong></p>
<ul>
<li>懒汉单例模式：只有当调用获取该实例的时候才会初始化这个实例，使用时需要加锁；在c++11后，使用静态局部变量即可，不需要加锁</li>
<li>饿汉单例模式：在程序运行时立刻初始化。饿汉模式不需要加锁，就可是实现线程安全。</li>
</ul>
<h2 id="异步日志"><a href="#异步日志" class="headerlink" title="异步日志"></a>异步日志</h2><p>​    考虑到I&#x2F;O操作是非常耗时的，所以为了不占用主线程的时间，采用异步日志的方法来管理日志，先将内容放在内存中，然后日志线程有空时再写到文件里。</p>
<p>​    日志队列其实就是一个生产者消费者模型，需要我们使用锁、条件变量等来实现。</p>
<ul>
<li>同步日志：写入日志操作与工作线程串行，当写的日志内容比较大时，同步模式下会阻塞在整个处理流程，并发能力会下降</li>
<li>异步日志：先将日志内容加入阻塞队列中，写线程从阻塞队列中取出内容然后写入日志</li>
</ul>
<h2 id="异步日志的工作流程"><a href="#异步日志的工作流程" class="headerlink" title="异步日志的工作流程"></a>异步日志的工作流程</h2><ul>
<li><p>通过懒汉单例模式（局部静态变量）获取实例 <code>Log::Instance()</code></p>
</li>
<li><p><code>Log::Instance()-&gt;init()</code> 完成初始化，若设置阻塞队列大小大于0则为异步，为0则为同步</p>
</li>
<li><p>外部通过调用接口 <code>write()</code> 写日志，根据当前时刻创建日志（前缀为时间，后缀为.log，并更新日志日期和当前行数），写操作时需要加锁</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数采用了不定参数的形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向buffer中写入时间，添加日志等级</p>
</li>
<li><p><code>va_start(va_List, format);</code></p>
</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>​    阻塞队列blockqueue采用c++11中的deque实现，若 <code>MaxCapacity</code> 为0，说明为同步日志，不需要阻塞队列，内部包含生产者消费者模型、互斥锁、条件变量等，其中消费者需要防止队列为空，生产者防止队列满。</p>
<p>blockqueue_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutecx&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 日志队列中MaxCapacity&gt;0表示异步，=0表示同步</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">BlockQueue</span><span class="params">(<span class="type">size_t</span> MaxCapacity = <span class="number">1000</span>)</span></span>;</span><br><span class="line">	~<span class="built_in">BlockQueue</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">T <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">T <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">posh_front</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;  <span class="comment">// 弹出任务放item中</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::deque&lt;T&gt; deq_;  <span class="comment">// 底层数据结构队列</span></span><br><span class="line">	<span class="type">size_t</span> capacity_;    <span class="comment">// 请求队列的最大容量</span></span><br><span class="line">	std::mutex mtx_;     <span class="comment">// 互斥锁</span></span><br><span class="line">	<span class="type">bool</span> isClose_;       <span class="comment">// 是否关闭</span></span><br><span class="line">	std::condition_variable condConsumer_;  <span class="comment">// 消费者条件变量</span></span><br><span class="line">	std::condition_variable condProducer_;  <span class="comment">// 生产者条件变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockQueue&lt;T&gt;::<span class="built_in">BlockQueue</span>(<span class="type">size_t</span> MaxCapacity) : <span class="built_in">capacity_</span>(MaxCapacity) &#123;</span><br><span class="line">	<span class="built_in">assert</span>(MaxCapacity &gt; <span class="number">0</span>);</span><br><span class="line">	isClose_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockQueue&lt;T&gt;::~<span class="built_in">BlockQueue</span>() &#123;</span><br><span class="line">	<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">empty</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">full</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockQueue&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockQueue&lt;T&gt;::<span class="built_in">capacity</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockQueue&lt;T&gt;::<span class="built_in">front</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockQueue&lt;T&gt;::<span class="built_in">back</span>() &#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; item) &#123;</span><br><span class="line">	<span class="comment">// 条件变量需要搭配unique_lock</span></span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="comment">// 队列满了，需要等待</span></span><br><span class="line">	<span class="keyword">while</span> (deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">		condProducer_.<span class="built_in">wait</span>(locker);  <span class="comment">// 生产者暂停生产，等待条件变量欢唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">	deq_.<span class="built_in">push_back</span>(item);</span><br><span class="line">	condConsumer_.<span class="built_in">notify_one</span>();  <span class="comment">// 唤醒消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">posh_front</span>(<span class="type">const</span> T&amp; item) &#123;</span><br><span class="line">	<span class="comment">// 条件变量需要搭配unique_lock</span></span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="comment">// 队列满了，生产者需要等待</span></span><br><span class="line">	<span class="keyword">while</span> (deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">		condProducer_.<span class="built_in">wait</span>(locker);  <span class="comment">// 生产者暂停生产，等待条件变量欢唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">	deq_.<span class="built_in">push_front</span>(item);</span><br><span class="line">	condConsumer_.<span class="built_in">notify_one</span>();  <span class="comment">// 唤醒消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item) &#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mutex)</span></span>;</span><br><span class="line">	<span class="comment">// 队列为空，消费者需要等待</span></span><br><span class="line">	<span class="keyword">while</span> (deq_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		condConsumer_.<span class="built_in">wait</span>(locker);  <span class="comment">// 消费者停止拿出，等待条件变量唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">	item = deq_.<span class="built_in">front</span>();</span><br><span class="line">	deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">condProducer_</span>(locker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockQueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item, <span class="type">int</span> timeout) &#123;</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mutex)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (deq_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">// 等待timeout秒</span></span><br><span class="line">		<span class="keyword">if</span> (condConsumer_.<span class="built_in">wait_for</span>(locker, std::chrono::<span class="built_in">seconds</span>(timeout))</span><br><span class="line">			== std::cv_status::timeout)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (isClose_)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	item = deq_.<span class="built_in">front</span>();</span><br><span class="line">	deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">condProducer_</span>(locker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒消费者</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">flush</span>() &#123;</span><br><span class="line">	condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列关闭</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockQueue&lt;T&gt;::<span class="built_in">Close</span>() &#123;</span><br><span class="line">	<span class="built_in">clear</span>();</span><br><span class="line">	isClose_ = <span class="literal">true</span>;</span><br><span class="line">	condProducer_.<span class="built_in">notify_all</span>();</span><br><span class="line">	condConsumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BLOCKQUEUE_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<h2 id="日志内容"><a href="#日志内容" class="headerlink" title="日志内容"></a>日志内容</h2><p>​    外部调用公有方法 （作为对外接口）<code>FlushLogThread()</code> 来写日志，<code>FlushLogThread</code>内部调用私有方法 <code>AsyncWrite()</code>执行写线程</p>
<p>​    日志的分级：</p>
<ul>
<li><code>Debug</code>：调试代码时的输出，在系统运行时一般不使用</li>
<li><code>Warn</code>：这种警告与调试时终端的warning类似，运行时一般不使用</li>
<li><code>Info</code>：报告系统当前的状态、执行的程序或接受的信息等</li>
<li><code>Errno</code>：输出系统的错误信息</li>
</ul>
<p>​    日志的分文件：</p>
<ul>
<li>按天分：日志写入前先判断当前today是否为创建日志时间，若不是则按照当前天创建新的日志文件写入</li>
<li>按行分：日志写入前会判断行数是否超过最大行限制，若超过则在日志的末尾添加lineCount_ &#x2F; MAX_LOG_MINES为后缀创建新的log文件</li>
</ul>
<p>log_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>    <span class="comment">// vastart va_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  <span class="comment">// mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化日志，</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">const</span> <span class="type">char</span>* suffix = <span class="string">&quot;.log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>;  <span class="comment">// 异步写日志的公有方法，调用私有方法asyncWrite</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> is Open_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Log</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>;  <span class="comment">// 日志路径最长长度</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>;  <span class="comment">// 日志最长名字</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;   <span class="comment">// 日志文件最大日志行数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* path_;    <span class="comment">// 路径名</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* suffix_;  <span class="comment">// 后缀名</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> MAX_LINES_;       <span class="comment">// 最大日志行数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> lineCount_;       <span class="comment">// 日志行数</span></span><br><span class="line">	<span class="type">int</span> toDay;            <span class="comment">// 按日期区分文件</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> isOpen_;</span><br><span class="line"></span><br><span class="line">	Buffer buff_;         <span class="comment">// 输出的缓冲区内容</span></span><br><span class="line">	<span class="type">int</span> level;            <span class="comment">// 日志等级</span></span><br><span class="line">	<span class="type">bool</span> isAsync_;        <span class="comment">// 是否开启异步日志</span></span><br><span class="line"></span><br><span class="line">	FILE* fp_;            <span class="comment">// 打开log的文件指针</span></span><br><span class="line">	std::unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; queue_;  <span class="comment">// 阻塞队列</span></span><br><span class="line">	std::unique_ptr&lt;std::thread&gt; writeThread_;        <span class="comment">// 写线程的指针</span></span><br><span class="line">	std::mutex mtx_;                                  <span class="comment">// 同步日志必须的互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">	do &#123;\</span></span><br><span class="line"><span class="meta">		Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;getLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">			log-&gt;write(level, format, ##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">			log-&gt;flush();\</span></span><br><span class="line"><span class="meta">		&#125;\</span></span><br><span class="line"><span class="meta">	&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	四个宏定义 用于不同的类型日志输出，也就是外部使用的日志接口</span></span><br><span class="line"><span class="comment">	...表示可变参数 __VA_ARGS__就是将...的内容复制到这里</span></span><br><span class="line"><span class="comment">	前面加上##的作用：当可变参数为0时，这里的##就可以把前面多余的,去掉，否则编译会出错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LOG_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>log_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line">Log::<span class="built_in">Log</span>() &#123;</span><br><span class="line">	lineCount_ = <span class="number">0</span>;</span><br><span class="line">	toDay = <span class="number">0</span>;</span><br><span class="line">	fp_ = <span class="literal">nullptr</span>;</span><br><span class="line">	queue_ = <span class="literal">nullptr</span>;</span><br><span class="line">	writeThread_ = <span class="literal">nullptr</span>;</span><br><span class="line">	isAsync_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>() &#123;</span><br><span class="line">	<span class="comment">// 若队列不为空，唤醒消费者处理</span></span><br><span class="line">	<span class="keyword">while</span> (!queue_-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		queue_-&gt;<span class="built_in">flush</span>();  </span><br><span class="line">	&#125;</span><br><span class="line">	queue_-&gt;<span class="built_in">Close</span>();       <span class="comment">// 关闭队列</span></span><br><span class="line">	writeThread_-&gt;<span class="built_in">join</span>();  <span class="comment">// 等待当前线程完成手中的任务</span></span><br><span class="line">	<span class="comment">// 冲洗文件缓冲区，关闭文件描述符</span></span><br><span class="line">	<span class="keyword">if</span> (_fp) &#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">		<span class="built_in">flush</span>();</span><br><span class="line">		<span class="built_in">fclose</span>(fp_);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒阻塞队列消费者，开始写日志</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 只有异步日志会用到queue</span></span><br><span class="line">	<span class="keyword">if</span> (!isAsync_) queue_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">	<span class="built_in">fflush</span>(fp_);  <span class="comment">// 清空缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉单例模式，静态局部变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Log::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> Log log;</span><br><span class="line">	<span class="keyword">return</span> &amp;log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步日志的写线程公有方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写线程真正执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (queue_-&gt;<span class="built_in">pop</span>(str)) &#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">		<span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);  <span class="comment">// 输出到fp_</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化日志实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* suffix, <span class="type">int</span> maxQueueCapacity)</span> </span>&#123;</span><br><span class="line">	isOpen_ = <span class="literal">true</span>;</span><br><span class="line">	level_ = levet;</span><br><span class="line">	path_ = path;</span><br><span class="line">	suffix_ = suffix;</span><br><span class="line">	<span class="comment">// maxQueueCapacity不为0开启异步线程日志</span></span><br><span class="line">	<span class="keyword">if</span> (maxQueueCapacity) &#123;</span><br><span class="line">		isAsync_ = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 队列为空创建一个</span></span><br><span class="line">		<span class="keyword">if</span> (!queue_) &#123;</span><br><span class="line">			std::unique_ptr&lt;BlockQueue&lt;std::string&gt;&gt; <span class="built_in">newQueue</span>(<span class="keyword">new</span> BlockQueue&lt;std::string&gt;);</span><br><span class="line">			<span class="comment">// 因为unique_ptr不支持不同的拷贝或赋值操作，所以采用move</span></span><br><span class="line">			<span class="comment">// 将动态申请的内存全给queue，newQueue被释放</span></span><br><span class="line">			queue_ = std::<span class="built_in">move</span>(newQueue);  <span class="comment">// 左值变右值，newQueue变空</span></span><br><span class="line"></span><br><span class="line">			<span class="function">std::unique_ptr&lt;std::thread&gt; <span class="title">newThread</span><span class="params">(<span class="keyword">new</span> Thread(FlushLogThread))</span></span>;</span><br><span class="line">			writeThread_ = std::<span class="built_in">move</span>(newThewad);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		isAsync_ = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lineCount_ = <span class="number">0</span>;</span><br><span class="line">	<span class="type">time_t</span> timer = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tm</span>* systime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">	<span class="type">char</span> fileName[LOG_NAME_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN - <span class="number">1</span>, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>,</span><br><span class="line">		path_, systime-&gt;tm_year+<span class="number">1900</span>, systime-&gt;tm_mon+<span class="number">1</span>, systime-&gt;tm_mday, syffix_);</span><br><span class="line">	toDay = systime-&gt;tm_mday;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">		buff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">		<span class="comment">// 重新打开</span></span><br><span class="line">		<span class="keyword">if</span> (fp_) &#123;</span><br><span class="line">			<span class="built_in">flush</span>();</span><br><span class="line">			<span class="built_in">fclose</span>(fp_);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 打开文件读取并附加写入</span></span><br><span class="line">		fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (fp_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);</span><br><span class="line">			fp_ = <span class="built_in">open</span>(fileName, <span class="string">&quot;a&quot;</span>);  <span class="comment">// 生成目录文件</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tm</span>* sysTime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">	va_list vaList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 日志日期，日志行数，如果不是今天或者行数超了</span></span><br><span class="line">	<span class="keyword">if</span> (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_ % MAX_LINES == <span class="number">0</span>))) &#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">		locker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> newFile[LOG_NAME_LEN];</span><br><span class="line">		<span class="type">char</span> tail[<span class="number">36</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 时间不匹配，替换为新的日志文件名</span></span><br><span class="line">		<span class="keyword">if</span> (toDay_ != t.tm_mday) &#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);</span><br><span class="line">			toDay_ = t.tm_mday;</span><br><span class="line">			lineCount_ = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail, (lineCount_ / MAX_LINES), suffix_);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		locker.<span class="built_in">lock</span>();</span><br><span class="line">		<span class="built_in">flush</span>();</span><br><span class="line">		<span class="built_in">fclose</span>(fp_);</span><br><span class="line">		fp_ = <span class="built_in">open</span>(newFile, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在buffer内生成一条对应的日志文件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">		lineCount_++;</span><br><span class="line">		<span class="type">int</span> n = <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;</span>,</span><br><span class="line">			t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday,</span><br><span class="line">			t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);</span><br><span class="line">		buff_.<span class="built_in">HasWritten</span>(n);</span><br><span class="line">		<span class="built_in">AppendLogLevelTitle_</span>(level);  <span class="comment">// 写入日志等级</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">va_start</span>(vaList, format);</span><br><span class="line">		<span class="comment">// vsnprintf将格式化数据从可变参数表写入缓冲区</span></span><br><span class="line">		<span class="type">int</span> m = <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);</span><br><span class="line">		<span class="built_in">va_end</span>(vaList);</span><br><span class="line"></span><br><span class="line">		buff_.<span class="built_in">HasWritten</span>(m);</span><br><span class="line">		buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 异步方式</span></span><br><span class="line">		<span class="keyword">if</span> (isAsync_ &amp;&amp; queue_ &amp;&amp; !queue_-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">			queue_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 同步方式</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_);  </span><br><span class="line">		&#125;</span><br><span class="line">		buff_.<span class="built_in">RetrieveAll</span>();  <span class="comment">// 清空buff_</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加日志等级</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (level)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info]:  &quot;</span>, <span class="number">9</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn]:  &quot;</span>, <span class="number">9</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		buff_.<span class="built_in">Append</span>(<span class="string">&quot;[errno]: &quot;</span>, <span class="number">9</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info]:  &quot;</span>, <span class="number">9</span>); <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	level_ = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-4:线程池</title>
    <url>/2023/07/04/TinyWebServer-4/</url>
    <content><![CDATA[<h1 id="从零开始实现c-TinyWebServer-④"><a href="#从零开始实现c-TinyWebServer-④" class="headerlink" title="从零开始实现c++TinyWebServer-④"></a>从零开始实现c++TinyWebServer-④</h1><p>​    缓冲区和日志这俩轮子都写完了，剩下的全都是上层的东西了，这节我们来写池相关的东西！</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>​    首先要知道什么是池，<strong>池表示一类资源的集合；而线程池是指初始化一个多线程程序过程中创建的一个线程集合</strong>，线程池在任务未到来之前，会创建一定量的线程放进空闲队列中，处于睡眠状态，直到有任务来了后唤醒线程池中的线程以抢占式的方式处理任务。</p>
<p>​    线程池有以下优点：</p>
<ul>
<li>使用线程池可以降低资源消耗：通过重复利用已经创建的线程，减少创建和销毁线程带来的消耗</li>
<li>提高响应速度：当任务到达时，在队列未满时不需要等待线程创建就能立刻执行</li>
<li>提高线程的可管理性</li>
</ul>
<p>​    关于线程同步的问题涉及到了互斥量、条件变量、匿名函数、共享指针、左值右值等，具体看下面的代码了解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用make_shared代替new，如果通过new在传递给shared_ptr，内存是不连续的。会造成内存碎片</span></span><br><span class="line">	<span class="comment">// make_shared:传递右值，功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span></span></span><br><span class="line"><span class="function">		: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span></span><br><span class="line">		<span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">			std::<span class="built_in">thread</span>([pool = pool_] &#123;</span><br><span class="line">				<span class="comment">//锁</span></span><br><span class="line">				std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">						<span class="comment">// 左值变右值</span></span><br><span class="line">						<span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">						pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">						<span class="comment">// 因为把任务取出来了，所以可以提前解锁</span></span><br><span class="line">						locker.<span class="built_in">unlock</span>();</span><br><span class="line">						<span class="built_in">task</span>();</span><br><span class="line">						<span class="comment">// 马上又要取任务了，加锁</span></span><br><span class="line">						locker.<span class="built_in">lock</span>();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (pool-&gt;isClosed) <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);  <span class="comment">// 等待任务来了唤醒</span></span><br><span class="line">				&#125;</span><br><span class="line">				&#125;).<span class="built_in">detach</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;</span><br><span class="line">			<span class="comment">// lock_guard期间会自动加锁，析构解锁</span></span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">			pool_-&gt;isClosed = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 唤醒所有任务（解除所有阻塞）</span></span><br><span class="line">		pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁一个阻塞，线程抢占式解锁</span></span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">		std::mutex mtx;                           <span class="comment">// 互斥锁</span></span><br><span class="line">		std::condition_variable cond;             <span class="comment">// 条件变量</span></span><br><span class="line">		<span class="type">bool</span> isClosed;                            <span class="comment">// 是否关闭线程</span></span><br><span class="line">		std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;  <span class="comment">// 任务队列，类型为void()</span></span><br><span class="line">	&#125;;</span><br><span class="line">	std::shared_ptr&lt;Pool&gt; pool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !THREADPOOL_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>​    首先需要知道什么RAII：<strong>RAII译为资源获取即初始化，是c++语言的一种管理资源、避免资源泄漏的常用方法。RAII的做法通常是使用一个对象，在其构造时获取资源，在对象生命周期内控制对资源的访问，使之始终有效，最后子析构的时候安全释放构造时的的资源。</strong>我们常用的智能指针，如 <code>unique_ptr</code> 、锁<code>lock_guard</code>都是采用了RAII的机制。</p>
<p>​    那为什么要使用连接池呐？</p>
<ul>
<li>由于服务器需要频繁的创建、断开与数据库的连接，该过程是一个很耗时的操作，频繁的创建与断开也不有利于数据库的安全</li>
<li>在程序初始化时，集中创建并管理多个数据库连接，可以保证较快的数据库读写速度，更安全可靠</li>
</ul>
<p>​    <strong>在连接池的实现中，使用到了信号量来管理资源的数量，而锁的使用是为了访问公共资源的时候使用，所以说无论是条件变量与信号量，使用时都需要上锁。不同的是，信号量使用前要先 <code>sem_wait</code>再上锁，而条件变量需要先上锁再 <code>wait</code>。</strong></p>
<p>​    具体的可见这个博客：<a href="https://blog.csdn.net/modi000/article/details/104779937">https://blog.csdn.net/modi000/article/details/104779937</a></p>
<p>sqlconnpool_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">SqlConnPool</span>();</span><br><span class="line">	~<span class="built_in">SqlConnPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> SqlConnPool* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">MYSQL* <span class="title">GetConn</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">FreeConn</span><span class="params">(MYSQL* conn)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetFreeConnCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> <span class="type">char</span>* user, <span class="type">const</span> <span class="type">char</span>* pwd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClosePool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> MAX_CONN_;</span><br><span class="line">	<span class="type">int</span> useCount_;</span><br><span class="line">	<span class="type">int</span> freeCount_;</span><br><span class="line"></span><br><span class="line">	std::queue&lt;MYSQL*&gt; connQue_;</span><br><span class="line">	std::mutex mtx_;</span><br><span class="line">	<span class="type">sem_t</span> semId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源在对象构造内初始化，资源在析构时释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span> &#123;</span><br><span class="line">	<span class="built_in">SqlConnRAII</span>(MYSQL** sql, SqlConnPool* connpool) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(connpool);</span><br><span class="line">		*sql = connpool-&gt;<span class="built_in">GetConn</span>();</span><br><span class="line">		sql_ = *sql;</span><br><span class="line">		connpool_ = connpool;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (sql_) &#123;</span><br><span class="line">			connpool_-&gt;<span class="built_in">FreeConn</span>(sql_);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL* sql_;</span><br><span class="line">	SqlConnPool* connpool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !SQLCONNPOOL_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>sqlconnpool_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SqlConnPool::<span class="built_in">SqlConnPool</span>() &#123;</span><br><span class="line">	useCount_ = <span class="number">0</span>;</span><br><span class="line">	freeCount_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqlConnPool::~<span class="built_in">SqlConnPool</span>() &#123;</span><br><span class="line">	<span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> SqlConnPool* <span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> SqlConnPool connpool;</span><br><span class="line">	<span class="keyword">return</span> &amp;connpool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (connQue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnpool busy!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sem_wait</span>(&amp;semId_);  <span class="comment">// 信号量-1</span></span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	conn = connQue_.<span class="built_in">front</span>();</span><br><span class="line">	connQue_.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存入连接池中，其实没有关闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* conn)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(conn);</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	connQue_.<span class="built_in">push</span>(conn);</span><br><span class="line">	<span class="built_in">sem_post</span>(&amp;semId_);  <span class="comment">// 信号量+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得空闲连接数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">const</span> <span class="type">char</span>* user, <span class="type">const</span> <span class="type">char</span>* pwd,</span></span></span><br><span class="line"><span class="params"><span class="function">				c	<span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connSize; ++i) &#123;</span><br><span class="line">		MYSQL* conn = <span class="literal">nullptr</span>;</span><br><span class="line">		conn = <span class="built_in">mysql_init</span>(conn);</span><br><span class="line">		<span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Mysql init error!&quot;</span>);</span><br><span class="line">			<span class="built_in">assert</span>(conn);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建连接</span></span><br><span class="line">		conn = <span class="built_in">mysql_real_connect</span>(conn, host, user, pwd, dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">			<span class="built_in">LOG_ERRR</span>(<span class="string">&quot;Mysql connect error!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		connQue_.<span class="built_in">emplace</span>(conn);</span><br><span class="line">	&#125;</span><br><span class="line">	MAX_CONN_ = connSize;</span><br><span class="line">	<span class="comment">// 初始化信号量值</span></span><br><span class="line">	<span class="built_in">sem_init</span>(&amp;semId, <span class="number">0</span>, MAX_CONN_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭所有连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (!connQue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> conn = connQue_.<span class="built_in">front</span>();</span><br><span class="line">		connQue_.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">mysql_close</span>(conn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-5:HTTP请求报文</title>
    <url>/2023/07/05/TinyWebServer-5/</url>
    <content><![CDATA[<h1 id="从零实现自己的c-TinyWebServer-⑤"><a href="#从零实现自己的c-TinyWebServer-⑤" class="headerlink" title="从零实现自己的c++TinyWebServer-⑤"></a>从零实现自己的c++TinyWebServer-⑤</h1><p>​    上一节完成了池的内容，这节对http的请求报文进行分析，首先我们要知道HTTP报文是什么</p>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>​    HTTP报文分为<strong>请求报文</strong>与<strong>响应报文</strong>，是面向文本的，具体格式如下图所示：</p>
<img src="/2023/07/05/TinyWebServer-5/HTTP-1.jpg" class="" title="HTTP请求报文">

<p>​    请求报文主要包含以下四部分：</p>
<ul>
<li><p>请求行</p>
</li>
<li><p>请求头部</p>
</li>
<li><p>空行</p>
</li>
<li><p>实体（请求数据）</p>
<p>  GET的请求报文如下所示：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host:img.mukewang.com</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)</span><br><span class="line">AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept:image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer:http://www.imooc.com/</span><br><span class="line">Accept-Encoding:gzip, deflate, sdch</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8</span><br><span class="line">空行</span><br><span class="line">请求数据为空</span><br></pre></td></tr></table></figure>

<p>​    POST的请求报文如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR          2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">空行</span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>

<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>​    对于HTTP请求报文的解析采用了有限状态机的方法，首先要知道什么是有限状态机，有限状态机是一种用来描述对象不同状态之间相互转换的模型；在代码中以 <code>parse()</code>函数完成，分别调用了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parse</span>(Buffer&amp; buff);   <span class="comment">// 状态机解析请求报文 共有接口</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ParesRequestLine_</span>();   <span class="comment">// 处理请求行</span></span><br><span class="line"><span class="built_in">ParseHeader_</span>();        <span class="comment">// 处理请求头部</span></span><br><span class="line"><span class="built_in">ParseBody_</span>();          <span class="comment">// 处理实体/请求数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ParsePath_</span>();          <span class="comment">// 处理请求路径</span></span><br><span class="line"><span class="built_in">ParsePost_</span>();          <span class="comment">// 处理Post请求的消息内容</span></span><br><span class="line"><span class="built_in">ParseFromUrlencoede_</span>();<span class="comment">// 从url解析编码</span></span><br></pre></td></tr></table></figure>

<p>​    在解析时会用到正则表达式，简单介绍一下正则表达式：</p>
<ul>
<li><code>used?</code>：<code>？</code>代表前面的字符可以出现0次或1次</li>
<li><code>ab*c</code>：<code>*</code>代表前面的字符可以出现0次或无数次</li>
<li><code>ab+c</code>：<code>+</code>会匹配出现1次以上的字符</li>
<li><code>ab&#123;2,6&#125;c</code>：指定出现次数，这里指2-6次，也可使指定一个数或者多于这个数</li>
<li><code>(ab)+c</code>：<code>()</code>里的数会一起匹配</li>
<li><code>.*</code>：<code>.</code>表示匹配任意字符，这里是匹配任意字符任意次</li>
<li><code>^a</code>：限定开头，这里表示只能以字符a开头；<code>[^]</code>表示取反，<code>[^a]</code>这里表示取除了a外的任意字符</li>
<li><code>a$</code>：行尾匹配，这里表示只能以字符a结尾</li>
</ul>
<p>httprequest_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTPREQUEST_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTPREQUEST_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span>  <span class="comment">// 正则表达式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">PARSE_STATE</span> &#123;</span><br><span class="line">		REQUEST_LINE,  <span class="comment">// 请求行</span></span><br><span class="line">		HEADERS,       <span class="comment">// 请求头部</span></span><br><span class="line">		BODY,          <span class="comment">// 请求内容</span></span><br><span class="line">		FINISH,         <span class="comment">// 请求结束</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">HTTP_CODE</span> &#123;</span><br><span class="line">		NO_REQUEST = <span class="number">0</span>,</span><br><span class="line">		GET_REQUEST,</span><br><span class="line">		BAD_REQUEST,</span><br><span class="line">		NO_RESOURSE,</span><br><span class="line">		FORBIDDENT_REQUEST,</span><br><span class="line">		FILE_REQUEST,</span><br><span class="line">		INTERNAL_ERROR,</span><br><span class="line">		CLOSED_CONNECTION,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HttpRequest</span>() &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">	~<span class="built_in">HttpRequest</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;  <span class="comment">// 初始化</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">parse</span><span class="params">(Buffer&amp; buff)</span></span>;  <span class="comment">// 对外接口，状态机解析请求报文</span></span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">path</span><span class="params">()</span> cosnt</span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">method</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">version</span><span class="params">()</span> cosnt</span>;</span><br><span class="line">	<span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ParseRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;  <span class="comment">// 处理请求行</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;       <span class="comment">// 处理请求头部</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;         <span class="comment">// 处理请求内容</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ParsePath_</span><span class="params">()</span></span>;                                <span class="comment">// 处理请求路径</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ParsePost_</span><span class="params">()</span></span>;                                <span class="comment">// 处理POST请求</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ParseFromUrlencoded_</span><span class="params">()</span></span>;                      <span class="comment">// 从url及解析编码</span></span><br><span class="line">	<span class="comment">// 用户验证</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string* pwd, <span class="type">bool</span> isLogin)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PARSE_STATE state_;</span><br><span class="line">	<span class="comment">// 请求方法(GET/POST) URL资源 HTTP版本 请求内容</span></span><br><span class="line">	std::string method_, path_, version_, body_;</span><br><span class="line">	std::unordered_map&lt;std::string, std::string&gt; header_;  <span class="comment">// 请求头部</span></span><br><span class="line">	std::unordered_map&lt;std::string, std::string&gt; post_;    <span class="comment">// post请求的数据</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> std::unordered_set&lt;std::string&gt; DEFAULT_HTML;  <span class="comment">// 响应的html页面</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; DEFAULT_HTML_TAG;  <span class="comment">// 注册后响应的html页面?</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">CoverHex</span><span class="params">(<span class="type">char</span> cn)</span></span>;  <span class="comment">// 16进制转10进制</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !HTTPREQUEST_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>httprequest.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_set&lt;std::string&gt; HttpRequest::DEFAULT_HTML&#123;</span><br><span class="line">	<span class="string">&quot;/index&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/welcome&quot;</span>, <span class="string">&quot;/video&quot;</span>, <span class="string">&quot;picture&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;std::string&gt; HttpRequest::DEFAULT_HTML_TAG&#123;</span><br><span class="line">	&#123;<span class="string">&quot;/register.html&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;/login.html&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	method_ = path_ = version_ = body_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	state_ = REQUEST_LINE;</span><br><span class="line">	header_.<span class="built_in">clear</span>();</span><br><span class="line">	post_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机解析请求报文接口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> CRLF = <span class="string">&quot;\r\n&quot;</span>;  <span class="comment">// 行结束标识</span></span><br><span class="line">	<span class="keyword">if</span> (buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 无可读字节</span></span><br><span class="line">	<span class="comment">// 读取数据</span></span><br><span class="line">	<span class="keyword">while</span> (buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_ != FINISH) &#123;</span><br><span class="line">		<span class="comment">// 从buff中的读指针开始到读指针结束，这块区域是未读取得数据并去处&quot;\r\n&quot;，返回有效数据得行末指针</span></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* lineEnd = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), CRLF, CRLF + <span class="number">2</span>);</span><br><span class="line">		<span class="function">std::string <span class="title">line</span><span class="params">(buff.Peek(), lineEnd)</span></span>;  <span class="comment">// 转换为string</span></span><br><span class="line">		<span class="comment">/*-- 状态机解析请求报文 请求行-&gt;请求头部-&gt;请求内容 --*/</span></span><br><span class="line">		<span class="keyword">switch</span> (state_)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> REQUEST_LINE:</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">ParseRequestLine_</span>(line)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="built_in">ParsePath_</span>();  <span class="comment">// 解析路径</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> HEADERS:</span><br><span class="line">			<span class="built_in">ParseHeader_</span>(line);</span><br><span class="line">			<span class="keyword">if</span> (buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) state_ = FINISH;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BODY:</span><br><span class="line">			<span class="built_in">ParseBody_</span>(line);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 读完了退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (lineEnd == buff.<span class="built_in">BeginWrite</span>()) <span class="keyword">break</span>;</span><br><span class="line">		buff.<span class="built_in">RetrieveUntil</span>(lineEnd + <span class="number">2</span>);  <span class="comment">// 跳过/r/n</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::ParseRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 正则表达式</span></span><br><span class="line">	<span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^]*) ([^]*) HTTP/([^]*)$&quot;</span>)</span></span>;</span><br><span class="line">	smatch subMatch;</span><br><span class="line">	<span class="comment">// 匹配规则中 ()划分组别 []表示整体</span></span><br><span class="line">	<span class="comment">// regex_match匹配指定字符串时候符合，subMatch为传入传出参数</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">regex_match</span>(line, subMatch, patten)) &#123;</span><br><span class="line">		method_ = subMatch[<span class="number">1</span>];</span><br><span class="line">		path_ = subMatch[<span class="number">2</span>];</span><br><span class="line">		version_ = subMatch[<span class="number">3</span>];</span><br><span class="line">		state_ = HEADERS;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;RequestLine Error&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span> </span>&#123;</span><br><span class="line">	<span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^:]): ?(.*)$&quot;</span>)</span></span>;</span><br><span class="line">	smatch subMatch;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">regex_match</span>(line, subMatch, patten)) &#123;</span><br><span class="line">		header_[subMatch[<span class="number">1</span>]] = subMatch[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		state_ = BODY;  <span class="comment">// 转换为下一状态</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span> </span>&#123;</span><br><span class="line">	body_ = line;</span><br><span class="line">	<span class="built_in">ParsePost_</span>();</span><br><span class="line">	state_ = FINISH;  <span class="comment">// 转换状态</span></span><br><span class="line">	<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Body:%s, len:%d&quot;</span>, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求的url</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePath_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path_ == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">		path_ = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : DEFAULE_HTML) &#123;</span><br><span class="line">			<span class="keyword">if</span> (item == path_) &#123;</span><br><span class="line">				path_ += item + <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理Post请求</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePost_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (method_ == <span class="string">&quot;POST&quot;</span> &amp;&amp; header_[<span class="string">&quot;Content-Type&quot;</span>] == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">		<span class="built_in">ParseFromUrlencoded_</span>();  <span class="comment">// POST请求体示例</span></span><br><span class="line">		<span class="keyword">if</span> (DEFAULT_HTML_TAG.<span class="built_in">count</span>(path_)) &#123;  <span class="comment">// 如果是登录/注册的path</span></span><br><span class="line">			<span class="type">int</span> tag = DEFAULT_HTML_TAG.<span class="built_in">find</span>(path_)-&gt;second;</span><br><span class="line">			<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Tag:%d&quot;</span>, tag);</span><br><span class="line">			<span class="keyword">if</span> (tag == <span class="number">0</span> || tag == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="type">bool</span> isLogin = (tag == <span class="number">1</span>);  <span class="comment">// 1是登录</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">UserVerify</span>(post_[<span class="string">&quot;username&quot;</span>], post_[<span class="string">&quot;password&quot;</span>], isLogin))</span><br><span class="line">					path_ = <span class="string">&quot;/welcome.html&quot;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					path_ = <span class="string">&quot;/error.html&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从url解析编码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseFromUrlencoded_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (body_.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	std::string key, value;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> n = body_.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">char</span> ch = bpdy_[i];</span><br><span class="line">		<span class="keyword">switch</span> (ch)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">			key = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	    <span class="comment">// 键值对中空格替换为&#x27;+&#x27;或者%20</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">			body_[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">			num = <span class="built_in">CoverHex</span>(body_[i + <span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">CoverHex</span>(body_[i + <span class="number">2</span>]);</span><br><span class="line">			body_[i + <span class="number">2</span>] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			body_[i + <span class="number">1</span>] = num / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			i += <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 键值对连接符</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">			value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			post_[key] = value;</span><br><span class="line">			<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s = %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(j &lt;= i);</span><br><span class="line">	<span class="keyword">if</span> (post_.<span class="built_in">count</span>(key) == <span class="number">0</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">		value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">		post_[key] = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录注册验证</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">HttpRequest::UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string* pwd, <span class="type">bool</span> isLogin)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (name == <span class="string">&quot;&quot;</span> || pwd == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Verify name:%s, pwd:%s&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());</span><br><span class="line">	MYSQL* sql;</span><br><span class="line">	<span class="built_in">SqlConnRAII</span>(&amp;sql, SqlConnPool::<span class="built_in">Instance</span>());</span><br><span class="line">	<span class="built_in">assert</span>(sql);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> order[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	MYSQLFIELD* fields = <span class="literal">nullptr</span>;</span><br><span class="line">	MYSQL_RES* res = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">is</span>(!isLogin) flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 查询用户以及密码</span></span><br><span class="line">	<span class="built_in">snprintf</span>(order, <span class="number">256</span>, <span class="string">&quot;SELECT username, password FROM user WHERE username=&#x27;%s&#x27; LIMIT 1&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(sql, order)) &#123;</span><br><span class="line">		<span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="built_in">mysql_store_result</span>(sql);</span><br><span class="line">	j = <span class="built_in">mysql_num_fields</span>(res);</span><br><span class="line">	fields = <span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res)) &#123;</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;MYSQL ROW: %s %s&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">		<span class="function">std::string <span class="title">password</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">		<span class="comment">// 注册 且用户名未被使用</span></span><br><span class="line">		<span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pwd == password) flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="built_in">LOG_INFO</span>(<span class="string">&quot;pwd ERROR!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;user UESD!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册行为 且用户名未被使用</span></span><br><span class="line">	<span class="keyword">if</span> (!isLogin &amp;&amp; flag == <span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;register!&quot;</span>);</span><br><span class="line">		<span class="built_in">bzero</span>(order, <span class="number">256</span>);</span><br><span class="line">		<span class="built_in">snprintf</span>(order, <span class="number">256</span>, <span class="string">&quot;INSERT INTO user(username, password) VALUES(&#x27;%s&#x27;, &#x27;%s&#x27;)&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>()));</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot; %s &quot;</span>, order);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(sql, order)) &#123;</span><br><span class="line">			<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Insert ERROR!&quot;</span>);</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		flag = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;UserVerify SUCCESS!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::path</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">HttpRequest::path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::method</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> method_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::version</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> version_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(key != <span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(key != <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否保持连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (header_.<span class="built_in">count</span>(<span class="string">&quot;Connection&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> header_[<span class="string">&quot;Connection&quot;</span>]-&gt;second == <span class="string">&quot;keep-alive&quot;</span> &amp;&amp; version_ == <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-6:HTTP响应报文</title>
    <url>/2023/07/08/TinyWebServer-6/</url>
    <content><![CDATA[<h1 id="从零实现自己的c-TinyWebServer-⑥"><a href="#从零实现自己的c-TinyWebServer-⑥" class="headerlink" title="从零实现自己的c++TinyWebServer-⑥"></a>从零实现自己的c++TinyWebServer-⑥</h1><p>​    上一节完成的是对HTTP请求报文的解析，还有响应报文相关的内容</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><img src="/2023/07/08/TinyWebServer-6/HTTP-1.jpg" class="" title="HTTP响应报文">

<p>​    HTTP响应报文主要由以下四部分组成：</p>
<ul>
<li>状态行：由Http协议版本号、状态码、状态消息三部分组成</li>
<li>首部行（消息报头）：用来说明客户端要使用的一些附加信息</li>
<li>空行：消息报头后的空行是必须的，它的作用是告诉客户端头部到此为止</li>
<li>实体（响应正文），服务器返回给客户端的文本信息</li>
</ul>
<p>​    HTTP响应报文如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">空行</span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="生成报文流程"><a href="#生成报文流程" class="headerlink" title="生成报文流程"></a>生成报文流程</h2><ul>
<li>通过公有函数 <code>HttpResponse::MakeResponse(Buffer&amp; buff)</code>实现<ul>
<li><code>stat(const char* pathname, struct stat* buf)</code>判断文件属性</li>
<li>添加状态行 <code>HttpResponse::AddStateLine_(Buffer&amp; buff)</code></li>
<li>添加消息报头 <code>HttpResponse::AddHeader_(Buffer&amp; buff)</code></li>
<li>添加响应正文 <code>HttpResponse::AddContent_(Buffer&amp; buff)</code></li>
</ul>
</li>
</ul>
<p>​    这个流程用到了stat函数，在响应正文处用到了mmap：</p>
<h2 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h2><p>​    Linux下使用stat查看文件属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="keyword">struct</span> stat* buf)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span>&#123;</span><br><span class="line">	 <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line">	 <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line">	 <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line">	 <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line">	 <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line">	 <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line">	 <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line">	 <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line">	 <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line">	 <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">timespec</span> st_atim; <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">timespec</span> st_mtim; <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line">	 <span class="keyword">struct</span> <span class="title class_">timespec</span> st_ctim; <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>pathname：用于指定一个需要查看的文件路径</li>
<li>buf：传入传出参数，传出获取文件属性的信息</li>
<li>返回值：成功返回0，失败返回-1并设置errno</li>
</ul>
<h2 id="mmap映射"><a href="#mmap映射" class="headerlink" title="mmap映射"></a>mmap映射</h2><p>​    内存映射是指让一个磁盘文件与内存中的一个缓冲区相映射，进程访问这块内存时，就等于访问文件对应的映射部分，不必再调用read&#x2F;write，可以使用mmap函数来建立内存与文件某一部分的映射关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>addr：映射的内存地址，一般设置为NULL</li>
<li>length：为映射地址空间分配的字节数</li>
<li>prot：指定内存空间的访问权限<ul>
<li>PROT_READ：可读</li>
<li>PROT_WRITE：可写</li>
<li>PROT_EXEC：可执行</li>
<li>PROT_NONE：不可访问</li>
</ul>
</li>
<li>flags：指定内存空间的映射方式（MAP_SHARED与MAP_PRIVATE必须二选一）<ul>
<li>MAP_SHARED：共享，表示其他进程可以看到</li>
<li>MAP_PRIVATE：私有，代表其他进程看不到</li>
<li>MAP_ANONYMOUS：匿名，一般用于有血缘关系之间的进程</li>
</ul>
</li>
<li>fd：指定要映射的文件，如果是匿名映射，填-1</li>
<li>offset：映射文件的偏移量</li>
</ul>
<h2 id="HttpResponse"><a href="#HttpResponse" class="headerlink" title="HttpResponse"></a>HttpResponse</h2><p>httpresponse_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTPRESPONSE_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTPRESPONSE_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>     <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  <span class="comment">// stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  <span class="comment">// mmap munmap</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line">	<span class="built_in">HttpResponse</span>();</span><br><span class="line">	~<span class="built_in">HttpResponse</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// HttpResponse类参数初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlive = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 生成响应报文函数(对外接口) 调用私有方法生成响应报文</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">	<span class="comment">// 解除mmap映射</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 返回mmFile_</span></span><br><span class="line">	<span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;     </span><br><span class="line">	<span class="comment">// 返回mmFileStat_的大小</span></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="comment">// 资源无法访问</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;                     </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 添加状态行</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">	<span class="comment">// 添加消息报头</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">	<span class="comment">// 添加响应正文</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> code_;                <span class="comment">// 状态码</span></span><br><span class="line">	<span class="type">bool</span> isKeepAlive_;        <span class="comment">// 持久连接</span></span><br><span class="line">	std::string path_;        <span class="comment">// 请求的文件路径</span></span><br><span class="line">	std::string srcDir_;      <span class="comment">// 请求文件的根路径</span></span><br><span class="line">	<span class="type">char</span>* mmFile_;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;  <span class="comment">// struct stat 结构体变量</span></span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;  <span class="comment">// </span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;          <span class="comment">// 状态码</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_PATH;            <span class="comment">// 本地html地址</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !HTTPRESPONSE_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>httpresponse_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;.html&quot;</span>,  <span class="string">&quot;text/html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xml&quot;</span>,   <span class="string">&quot;text/xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.txt&quot;</span>,   <span class="string">&quot;text/plain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.rtf&quot;</span>,   <span class="string">&quot;application/rtf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.pdf&quot;</span>,   <span class="string">&quot;application/pdf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.word&quot;</span>,  <span class="string">&quot;application/nsword&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.png&quot;</span>,   <span class="string">&quot;image/png&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gif&quot;</span>,   <span class="string">&quot;image/gif&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpg&quot;</span>,   <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpeg&quot;</span>,  <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.au&quot;</span>,    <span class="string">&quot;audio/basic&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpeg&quot;</span>,  <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpg&quot;</span>,   <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.avi&quot;</span>,   <span class="string">&quot;video/x-msvideo&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gz&quot;</span>,    <span class="string">&quot;application/x-gzip&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.tar&quot;</span>,   <span class="string">&quot;application/x-tar&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.css&quot;</span>,   <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.js&quot;</span>,    <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123;<span class="number">200</span>, <span class="string">&quot;OK&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123;<span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">	code_ = <span class="number">-1</span>;</span><br><span class="line">	isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line">	path_ = srcDir_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">	mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    <span class="built_in">UnmapFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, <span class="type">const</span> std::string&amp; path, <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmFile_) <span class="built_in">UnmapFile</span>();</span><br><span class="line">    code_ = code;</span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    path_ = path;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求文件不存在或请求的为文件夹 设置404</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;</span><br><span class="line">        code_ = <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不可读(即权限不够) 设置403 S_IROTH表示004 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line">        code_ = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常处理请求</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        code_ = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();</span><br><span class="line">    <span class="built_in">AddStateLine_</span>();</span><br><span class="line">    <span class="built_in">AddHeader_</span>();</span><br><span class="line">    <span class="built_in">AddContent_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mmFile_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size);</span><br><span class="line">        mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmFile_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmFileStat_.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span> </span>&#123;</span><br><span class="line">    std::string body, status;</span><br><span class="line">    body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    body += std::<span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + std::<span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    std::string status;</span><br><span class="line">    <span class="keyword">if</span> (CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        code_ = <span class="number">400</span>;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + std::<span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (isKeepAlive_) &#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-typpe: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (srcFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将文件映射到内存提高文件的访问速度</span></span><br><span class="line"><span class="comment">       Map_PRIVATE 建立一个写入时拷贝的私有映射 */</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file patt:%s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">    <span class="type">int</span>* mmRet = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmRet &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mmFile_ = (<span class="type">char</span>*)mmRet;</span><br><span class="line">    <span class="built_in">close</span>(srcFd);</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + std::<span class="built_in">to_string</span>(mmFileStat_.st_size) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">        <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件类型</span></span><br><span class="line">    std::string::size_type idx = path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 找不到类型</span></span><br><span class="line">    <span class="keyword">if</span> (idx == std::string::npos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string suffix = path_.<span class="built_in">substr</span>(idx);</span><br><span class="line">    <span class="keyword">if</span> (SUFFIX_TYPE.<span class="built_in">find</span>(suffix) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-7:HttpConn连接类</title>
    <url>/2023/07/08/TinyWebServer-7/</url>
    <content><![CDATA[<h1 id="从零实现自己的c-TinyWebServer-⑦"><a href="#从零实现自己的c-TinyWebServer-⑦" class="headerlink" title="从零实现自己的c++TinyWebServer-⑦"></a>从零实现自己的c++TinyWebServer-⑦</h1><p>​    已经完成了请求报文的解析与响应报文的操作，接下来我们需要进行HTTP连接相关的内容：</p>
<h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>​    简单的HTTP连接过程其实就是</p>
<ol>
<li>读取请求</li>
<li>解析请求</li>
<li>生成响应</li>
<li>发送响应</li>
</ol>
<p>​    所以设计了一个HttpConn类来封装在整个HTTP连接操作，在类中，有两种缓冲区，读缓冲区 <code>readBuff_</code>与写缓冲区 <code>writeBuff_</code>，注意这里的读与写的含义，读缓冲区是用来接收浏览器发来的请求报文，写缓冲区存入的是将要发送的响应报文。</p>
<p>​    解析请求报文与生成响应报文都在 <code>HttpConn::process()</code> 中完成，在解析完请求报文后随即生成了响应报文，之后这个生成的响应报文便放在缓冲区等待 <code>writev()</code>函数将去发送给fd。</p>
<p>httpconn_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTPCONN_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTPCONN_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HttpConn</span>();</span><br><span class="line">	~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// HttpConn初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in* addr)</span></span>;</span><br><span class="line">	<span class="comment">// 将请求报文写进readBuff_</span></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line">	<span class="comment">// 将writeBuff_发送到浏览器</span></span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> iov_[<span class="number">0</span>].lov_len + iov[<span class="number">1</span>].lov_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">bool</span> isET;                   <span class="comment">// 是否为ET触发</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;          <span class="comment">// </span></span><br><span class="line">	<span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;  <span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> fd_;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr_;</span><br><span class="line">	<span class="type">bool</span> isClose_;</span><br><span class="line">	<span class="type">int</span> iovCnt_;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读缓冲区</span></span><br><span class="line">	Buffer readBuff_;</span><br><span class="line">	<span class="comment">// 写缓冲区</span></span><br><span class="line">	Buffer writeBuff_;</span><br><span class="line"></span><br><span class="line">	HttpRequest  request_;</span><br><span class="line">	HttpResponse response_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !HTTPCONN_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>httpconn_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount;</span><br><span class="line"><span class="type">bool</span> HttpConn::isET;</span><br><span class="line"></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123;</span><br><span class="line">	fd_ = <span class="number">-1</span>;</span><br><span class="line">	addr_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	isClose_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123;</span><br><span class="line">	<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(sockfd &gt; <span class="number">0</span>);</span><br><span class="line">	userCount++;</span><br><span class="line">	addr_ = addr;</span><br><span class="line">	fd_ = sockfd;</span><br><span class="line">	writeBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">	readBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">	isClose_ = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);</span><br><span class="line">	&#125; <span class="keyword">while</span> (isET);</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用writev连续写</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;</span><br><span class="line">	<span class="type">size_t</span> len = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		len = <span class="built_in">writev</span>(fd_, iov_, iovCnt_);</span><br><span class="line">		<span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			*saveErrno = errno;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 传输结束</span></span><br><span class="line">		<span class="keyword">if</span> (iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 否则</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len)&#123;</span><br><span class="line">			iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">			iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">			<span class="keyword">if</span> (iov_[<span class="number">0</span>].iov_len) &#123;</span><br><span class="line">				writeBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">				iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len;</span><br><span class="line">			iov_[<span class="number">0</span>].iov_len -= len;</span><br><span class="line">			writeBuff_.<span class="built_in">Retrieve</span>(len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	response_.<span class="built_in">UnmapFile</span>();</span><br><span class="line">	<span class="keyword">if</span> (isClose_ == <span class="literal">false</span>) &#123;</span><br><span class="line">		isClose_ = <span class="literal">true</span>;</span><br><span class="line">		userCount--;</span><br><span class="line">		<span class="built_in">close</span>(fd_);</span><br><span class="line">		<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fd_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> addr.sin_port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr.sin_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sockaddr_in <span class="title">HttpConn::GetAddr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	request_.<span class="built_in">init</span>();</span><br><span class="line">	<span class="comment">// 读缓冲区没有可读数据</span></span><br><span class="line">	<span class="keyword">if</span> (readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析成功</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">parse</span>(readBuff_)) &#123;</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());</span><br><span class="line">		response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析失败</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成响应报文放在writeBuff_中</span></span><br><span class="line">	response_.<span class="built_in">MakeResponse</span>(writeBuff_);</span><br><span class="line">	<span class="comment">/* 响应头  iov记录了需要把数据从缓冲区发送出去的相关信息</span></span><br><span class="line"><span class="comment">	   iov_base为缓冲区首地址，iov_len为缓冲区长度 */</span></span><br><span class="line">	iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());</span><br><span class="line">	iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();</span><br><span class="line">	iovCnt_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文件</span></span><br><span class="line">	<span class="keyword">if</span> (response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span> &amp;&amp; response_.<span class="built_in">File</span>()) &#123;</span><br><span class="line">		iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">		iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">		iovCnt_ = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>(), iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-8:小根堆定时器</title>
    <url>/2023/07/09/TinyWebServer-8/</url>
    <content><![CDATA[<h1 id="从零实现自己的c-TinyWebServer-⑧"><a href="#从零实现自己的c-TinyWebServer-⑧" class="headerlink" title="从零实现自己的c++TinyWebServer-⑧"></a>从零实现自己的c++TinyWebServer-⑧</h1><h2 id="时间堆"><a href="#时间堆" class="headerlink" title="时间堆"></a>时间堆</h2><p>​    网络编程中除了I&#x2F;O操作外，定时事件也是不可获取的，比如定期检查一个客户的连接状态等。我们的服务器常常需要处理众多的定时事件，因此有效的组织定时事件，使之能在与其时间内被触发且不影响服务器主要逻辑，对我们服务器性能影响特别大。</p>
<p>​    一般的做法是将每个定时事件封装成定时器，并使某种容器类数据结构将所有的定时器保存好，实现对定时事件的统一管理，常用方法有时间堆、链表、时间轮，这里使用的是时间堆。</p>
<h2 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h2><p>​    传统的定时方案是以固定频率调用起搏函数tick，进而执行定时器上的回调函数。而时间堆的做法则是将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔，当超时时间到达时，处理超时事件，然后再次从剩余定时器中找出超时时间最小的一个，依次反复即可。</p>
<ul>
<li><p>当前系统时间：8:00</p>
</li>
<li><p>1号定时器超时时间：8:05</p>
</li>
<li><p>2号定时器超时时间：8:08</p>
</li>
<li><p>设置心搏间隔：8:05-8:00&#x3D;5</p>
</li>
<li><p>5分钟到达后处理1号定时器事件，再根据2号超时时间设定心搏间隔.</p>
</li>
</ul>
<p>​    为了后面处理过期连接的方便，我们给每一个定时器里面放置一个回调函数，用来关闭过期连接。</p>
<p>​    为了便于定时器结点的比较，主要是后续堆结构的实现方便，我们还需要重载比较运算符。</p>
<p>​    这里还用到了c++11的一些特性，讲一下：</p>
<ul>
<li><code>std::chrono::high_resolution_clock</code>返回当前时间，按s为单位<ul>
<li><code>dutation</code> 一段时间</li>
<li><code>time_point</code> 时间点</li>
</ul>
</li>
<li><code>std::chrono::millseconds</code> 表示毫秒</li>
<li><code>std::function&lt;void()&gt;</code>函数模板</li>
</ul>
<h2 id="HeapTimer类"><a href="#HeapTimer类" class="headerlink" title="HeapTimer类"></a>HeapTimer类</h2><p>heaptimer_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAPTIMER_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAPTIMER_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; TimeoutCallBack;</span><br><span class="line"><span class="keyword">typedef</span> std::chrono::high_resolution_clock Clock;  <span class="comment">// 获取时间 以s为单位</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds MS;</span><br><span class="line"><span class="keyword">typedef</span> Clock::time_point TimeStamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> id;              <span class="comment">// 设置唯一标识</span></span><br><span class="line">	TimeStamp expires;   <span class="comment">// 设置过期时间</span></span><br><span class="line">	TimeoutCallBack cb;  <span class="comment">// 设置回调函数</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode&amp; t) &#123;</span><br><span class="line">		<span class="keyword">return</span> expires &lt; t.expires;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> TimerNode&amp; t) &#123;</span><br><span class="line">		<span class="keyword">return</span> expires &gt; t.expires;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HeapTimer</span>() &#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;</span><br><span class="line">	~<span class="built_in">HeapTimer</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout, cosnt TimeoutCallBack&amp; cb)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line">	<span class="comment">// 向上调整</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">	<span class="comment">// 向下调整 不能调整则返回false</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line">	<span class="comment">// 交换节点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;</span><br><span class="line">	std::vector&lt;TimerNode&gt; heap_;</span><br><span class="line">	<span class="comment">// id对应的在heap_中的下标，方便用heap_的时候查找</span></span><br><span class="line">	std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !HEAPTIMER_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>heaptimer_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    : 2023/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 调整指定id的节点</span></span><br><span class="line">	<span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id) &gt; <span class="number">0</span>);</span><br><span class="line">	heap_[ref_[id]].expries = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(newExpires);</span><br><span class="line">	<span class="built_in">siftdown_</span>(ref_[id], heap_.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout, <span class="type">const</span> TimeoutCallBack&amp; cb)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">if</span> (ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 新节点 插入堆尾 调整堆</span></span><br><span class="line">		i = heap_.<span class="built_in">size</span>();</span><br><span class="line">		ref_[id] = i;</span><br><span class="line">		heap_.<span class="built_in">push_back</span>(&#123; id, Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout), cb &#125;);</span><br><span class="line">		<span class="built_in">siftup_</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 已有节点 调整堆</span></span><br><span class="line">		i = ref_[id];</span><br><span class="line">		heap_[i].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);</span><br><span class="line">		heap_[i].cb = cb;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">siftdown_</span>(i, <span class="built_in">heap_size</span>())) &#123;</span><br><span class="line">			<span class="built_in">siftup_</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 删除指定id的节点 并触发回调函数</span></span><br><span class="line">	<span class="keyword">if</span> (heap_.<span class="built_in">empty</span>() || ref_[i].<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> i = ref_[id];</span><br><span class="line">	TimerNode node = heap_[i];</span><br><span class="line">	node.<span class="built_in">cb</span>();</span><br><span class="line">	<span class="built_in">del_</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ref_.<span class="built_in">clear</span>();</span><br><span class="line">	heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 清理超时节点</span></span><br><span class="line">	<span class="keyword">if</span> (heap_.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TimerNode node = heap_.<span class="built_in">front</span>();</span><br><span class="line">		<span class="keyword">if</span> (std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node.<span class="built_in">cb</span>();</span><br><span class="line">		<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">	<span class="built_in">del_</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">tick</span>();</span><br><span class="line">	<span class="type">size_t</span> res = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		res = std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();</span><br><span class="line">		<span class="keyword">if</span> (res &lt; <span class="number">0</span>) res = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 删除指定位置的节点</span></span><br><span class="line">	<span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">// 将要删除的节点换到队尾 然后调整堆</span></span><br><span class="line">	<span class="type">size_t</span> i = index;</span><br><span class="line">	<span class="type">size_t</span> n = heap_.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">assert</span>(i &lt;= n);</span><br><span class="line">	<span class="comment">// 如果在队尾就不用移动</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">		<span class="built_in">SwapNode_</span>(i, n);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">siftdown_</span>(i, n))</span><br><span class="line">			<span class="built_in">siftup_</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 队尾元素删除</span></span><br><span class="line">	ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">	heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 向上调整</span></span><br><span class="line">	<span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">size_t</span> parent = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (parent &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (heap_[parent] &lt; heap_[i]) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">SwapNode_</span>(i, parent);</span><br><span class="line">		i = parent;</span><br><span class="line">		parent = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 向下调整</span></span><br><span class="line">	<span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">	<span class="type">size_t</span> i = index;</span><br><span class="line">	<span class="type">size_t</span> child = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((child + <span class="number">1</span> &lt; n) &amp;&amp; heap_[child + <span class="number">1</span>] &lt; heap_[child]) child++;</span><br><span class="line">		<span class="keyword">if</span> (heap_[i] &lt; heap_[child]) <span class="keyword">break</span>;</span><br><span class="line">		i = child;</span><br><span class="line">		child = (i * <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j &gt; index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">	std::<span class="built_in">swap</span>(heap_[i], heap_[j]);</span><br><span class="line">	ref_[heap_[i].id] = i;</span><br><span class="line">	ref_[heap_[j].id] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-9:Epoll类与IO流程</title>
    <url>/2023/07/09/TinyWebServer-9/</url>
    <content><![CDATA[<h1 id="从零实现自己的c-TinyWebServer-⑨"><a href="#从零实现自己的c-TinyWebServer-⑨" class="headerlink" title="从零实现自己的c++TinyWebServer-⑨"></a>从零实现自己的c++TinyWebServer-⑨</h1><p>​    终于到了实现服务器最重要的部分：构建Epoller类来搭建服务器。</p>
<h2 id="Epoller"><a href="#Epoller" class="headerlink" title="Epoller"></a>Epoller</h2><p>​    epoll的接口其实就以下几个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys.epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line">    - 参数</span><br><span class="line">        size: 必须大于<span class="number">0</span>，告诉内核要创建多大的epoll（无实际意义）</span><br><span class="line">    - 返回值</span><br><span class="line">        <span class="number">-1</span>：失败</span><br><span class="line">        &gt;<span class="number">0</span>：返回epoll的文件描述符</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">union</span> epoll_data&#123;</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> *fd;</span><br><span class="line">    <span class="type">unit32_t</span> u32;</span><br><span class="line">    <span class="type">unit64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="comment">// epoll_event为一个时间表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line">    - 参数</span><br><span class="line">        events：监听的事件类型，可以为以下值之一</span><br><span class="line">            EPOLLIN：表示对应的文件描述符上有数据可读</span><br><span class="line">			EPOLLOUT：表示对应的文件描述符上可以写入数据</span><br><span class="line">			EPOLLRDHUP：表示对端已经关闭连接，或者关闭了写操作端的写入</span><br><span class="line">			EPOLLPRI：表示有紧急数据可读</span><br><span class="line">			EPOLLERR：表示发生错误</span><br><span class="line">			EPOLLHUP：表示文件描述符被挂起</span><br><span class="line">			EPOLLET：表示将epoll设置为边缘触发模式</span><br><span class="line">			EPOLLONESHOT：表示将事件设置为一次性事件</span><br><span class="line">        data：用户数据，可以是一个指针或者文件描述符等</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span></span>;</span><br><span class="line">    - 参数</span><br><span class="line">        epfd：epoll对应的文件描述符</span><br><span class="line">        op：进行的操作</span><br><span class="line">            EPOLL_CTL_ADD 添加</span><br><span class="line">            EPOLL_CTL_DEL 删除</span><br><span class="line">            EPOLL_CTL_MOD 修改</span><br><span class="line">        fd：操作的目标文件描述符</span><br><span class="line">        event：文件描述符发生的事件</span><br><span class="line">    - 返回值</span><br><span class="line">        <span class="number">-1</span>：失败</span><br><span class="line">        <span class="number">0</span>：成功</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> tiemout)</span></span>;</span><br><span class="line">	- 参数</span><br><span class="line">        epfd：监听文件描述符</span><br><span class="line">        events：传入传出参数，保存了发生变化的文件描述符信息</span><br><span class="line">        maxevents：events的大小</span><br><span class="line">        timeout：阻塞时间</span><br><span class="line">            =<span class="number">0</span> 不阻塞</span><br><span class="line">            &gt;<span class="number">0</span> 阻塞的时间ms</span><br><span class="line">            &lt;<span class="number">0</span> 一直阻塞，直到检测到有文件描述符发生变化，解除阻塞</span><br><span class="line">    - 返回值</span><br><span class="line">        <span class="number">-1</span>：失败</span><br><span class="line">        &gt;<span class="number">0</span>：返回发生变化的文件描述符的个数</span><br></pre></td></tr></table></figure>

<p>​    常见epoll检测事件的过程：</p>
<p>我们时常会用一个while(true)死循环去接收缓冲区中客户端socket的连接，如果这个时候我们设置socket状态为非阻塞，那么accept如果在某个时间段没有接收到客户端的连接，因为是非阻塞的IO，accept函数会立即返回，并将errno设置为EAGAIN。</p>
<p>epoller_new.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    ：2023/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvents = <span class="number">1024</span>);</span><br><span class="line">	~<span class="built_in">Epoller</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> epollFd_;</span><br><span class="line">	std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !EPOLLER_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>epoller_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    ：2023/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvents = <span class="number">1024</span>) : <span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvents) &#123;</span><br><span class="line">	<span class="built_in">assert</span>(epollFd_ &gt; <span class="number">0</span> &amp;&amp; event_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">	<span class="built_in">close</span>(epollFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	epoll_event ev = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ev.data.fd = fd;</span><br><span class="line">	ev.events = events;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	epoll_event ev = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	ev.data.fd = fd;</span><br><span class="line">	ev.events = events;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	epoll_event ev = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLLCTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebServer类"><a href="#WebServer类" class="headerlink" title="WebServer类"></a>WebServer类</h2><p>​    启动WebServer，首先需要设定epoll_wait()等待的时间，这里我们选择调用定时器的 <code>GetNextTick()</code>函数，这个函数返回最小堆堆顶的连接设定的过期时间与现在时间的差值，接着调用epoll_wait()返回需要就绪事件的数目，这里分为两类：接收新的http连接和其他的读写事件，这里设置两个变量fd和events来分别存储就绪事件的文件描述符与事件类型。</p>
<ol>
<li><p>接收到新的HTTP请求</p>
<p> 在fd&#x3D;&#x3D;listenfd的时候，也就是收到新的HTTP请求的时候，调用<code>DealListen_()</code>处理监听，接收客户端的连接</p>
</li>
<li><p>已经建立连接的HTTP请求发来的I&#x2F;O请求</p>
<p> 在events&amp;EPOLLIN或events&amp;EPOLLOUT为真时，需要进行读写处理。分别调用 <code>DealRead_(&amp;users_[fd])</code>与 <code>DealWrite_(&amp;users_[fd])</code>函数，交给线程池中的线程处理</p>
</li>
</ol>
<p><strong>这就是Reactor，读写事件都交给工作线程处理</strong></p>
<h2 id="I-x2F-O处理的具体流程"><a href="#I-x2F-O处理的具体流程" class="headerlink" title="I&#x2F;O处理的具体流程"></a>I&#x2F;O处理的具体流程</h2><p>​    <code>DealRead_(&amp;users_[fd])</code>和<code>DealWrite_(&amp;users_[fd]) </code>通过调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));     <span class="comment">//读</span></span><br><span class="line">threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));    <span class="comment">//写</span></span><br></pre></td></tr></table></figure>

<p>​    函数来取出线程池中的线程继续进行读写，而主进程这时可以继续监听新来的就绪事件了。</p>
<p>注意此处用std:;bind将参数绑定，他可以将可调用对象将参数绑定为一个仿函数，绑定后的结果可以使用std::function保存，而且bind绑定类成员函数时，第一个参数表示对象的成员函数的指针（所以上面的函数用的是&amp;WebServer::OnRead_），第二个参数表示对象的地址。</p>
<p>​    OnRead_()函数首先把数据从缓冲区中读出来(调用HttpConn的read,read调用ReadFd读取到读缓冲区BUFFER)，然后交由逻辑函数OnProcess()处理。这里多说一句，process()函数在解析请求报文后随即就生成了响应报文等待OnWrite_()函数发送，这一点我们前面谈到过的。</p>
<p><strong>这里必须说清楚OnRead_()和OnWrite_()函数进行读写的方法，那就是：分散读和集中写</strong></p>
<p>​    分散读（scatter read）和集中写（gatherwrite）具体来说是来自读操作的输入数据被分散到多个应用缓冲区中，而来自应用缓冲区的输出数据则被集中提供给单个写操作。 这样做的好处是：它们只需一次系统调用就可以实现在文件和进程的多个缓冲区之间传送数据，免除了多次系统调用或复制数据的开销。</p>
<p>​    OnWrite_()函数首先把之前根据请求报文生成的响应报文从缓冲区交给fd，传输完成后修改该fd的<code>events</code>.</p>
<p>​    OnProcess()就是进行业务逻辑处理（解析请求报文、生成响应报文）的函数了。</p>
<p><strong>这里我要提一嘴我之前犯的思想错误，一定要记住：“如果没有数据到来，epoll是不会被触发的”。当浏览器向服务器发出request的时候，epoll会接收到EPOLL_IN读事件，此时调用OnRead去解析，将fd(浏览器)的request内容放到读缓冲区，并且把响应报文写到写缓冲区，这个时候调用OnProcess()是为了把该事件变为EPOLL_OUT，让epoll下一次检测到写事件，把写缓冲区的内容写到fd。当EPOLL_OUT写完后，整个流程就结束了，此时需要再次把他置回原来的EPOLL_IN去检测新的读事件到来。</strong></p>
<p>webserver_new.h</p>
<ul>
<li><p>构造函数: 设置服务器参数　＋　初始化定时器／线程池／反应堆／连接队列</p>
</li>
<li><p>析构函数: 关闭listenFd_，　销毁　连接队列&#x2F;定时器／线程池／反应堆</p>
</li>
<li><p>主函数start()</p>
</li>
<li><p>创建端口，绑定端口，监听端口，　创建epoll反应堆，　将监听描述符加入反应堆</p>
</li>
<li><p>等待事件就绪</p>
</li>
<li><p>连接事件－－＞DealListen()</p>
</li>
<li><p>写事件－－＞DealWrite()</p>
</li>
<li><p>读事件－－＞DealRead()</p>
</li>
<li><p>事件处理完毕，修改反应堆，再跳到２处循环执行</p>
</li>
<li><p>DealListen: 新初始化一个ＨttpConnection对象</p>
</li>
<li><p>DealWrite：　对应连接对象进行处理－－＞若处理成功，则监听事件转换成　读　事件</p>
</li>
<li><p>DealRead：　 对应连接对象进行处理－－＞若处理成功，则监听事件转换成　写　事件</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    ：2023/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_NEW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_NEW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/httpconn_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../timer/heaptimer_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/threadpool_new.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	    端口号        触发模式         超时时间       优雅触发</span></span><br><span class="line"><span class="comment">		数据库端口    数据库root名     数据库密码</span></span><br><span class="line"><span class="comment">		数据库名      数据库连接池数量  线程池线程数量</span></span><br><span class="line"><span class="comment">		是否开启日志   日志等级        log队列日志</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">WebServer</span>(</span><br><span class="line">		<span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger,</span><br><span class="line">		<span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span> <span class="type">char</span>* sqlPwd,</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">		<span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize);</span><br><span class="line">	~<span class="built_in">WebServer</span>();</span><br><span class="line">	<span class="comment">// 启动服务器</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 初始化scoket函数</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">InitSocket_</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 初始化事件函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">InitEventMode_</span><span class="params">(<span class="type">int</span> trigNode)</span></span>;</span><br><span class="line">	<span class="comment">// 添加新连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddClient_</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr_in addr)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理新连接事件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealListen_</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 任务队列添加读事件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">	<span class="comment">// 任务队列添加写事件</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DealRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 发送错误函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* info)</span></span>;</span><br><span class="line">	<span class="comment">// 延长连接的时长</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ExtentTime_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">	<span class="comment">// 关闭连接函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CloseConn_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnProcess</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置fd为NONBLOCK</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> port_;         <span class="comment">// 端口</span></span><br><span class="line">	<span class="type">bool</span> openLinger_;  <span class="comment">// 优雅关闭</span></span><br><span class="line">	<span class="type">int</span> timeoutMS_;    <span class="comment">// 定时器默认过期时间ms</span></span><br><span class="line">	<span class="type">bool</span> isClose_;     <span class="comment">// 启动器是否关闭</span></span><br><span class="line">	<span class="type">int</span> listenFd_;     <span class="comment">// 监听文件描述符</span></span><br><span class="line">	<span class="type">char</span>* srcDir_;     <span class="comment">// 需要获取的路径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听触发模式</span></span><br><span class="line">	<span class="type">uint32_t</span> listenEvent_;</span><br><span class="line">	<span class="comment">// http连接触发模式</span></span><br><span class="line">	<span class="type">uint32_t</span> connEvent_;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unique_ptr定时器</span></span><br><span class="line">	std::unique_ptr&lt;HeapTimer&gt; timer_;</span><br><span class="line">	<span class="comment">// unique_ptr线程池</span></span><br><span class="line">	std::unique_ptr&lt;ThreadPool&gt; threadpool_;</span><br><span class="line">	<span class="comment">// unique_ptr的epoll反应堆</span></span><br><span class="line">	std::unique_ptr&lt;Epoller&gt; epoller_;</span><br><span class="line">	<span class="comment">// http连接队列</span></span><br><span class="line">	std::unordered_map&lt;<span class="type">int</span>, HttpConn&gt; users_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !WEBSERVER_NEW_H</span></span></span><br></pre></td></tr></table></figure>

<p>webserver_new.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author  : Zhu Zhibo</span></span><br><span class="line"><span class="comment"> * @Date    ：2023/07/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver_new.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>(</span><br><span class="line">	<span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger,</span><br><span class="line">	<span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span> <span class="type">char</span>* sqlPwd,</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">	<span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize) :</span><br><span class="line">	<span class="built_in">port_</span>(port), <span class="built_in">openLinger_</span>(OptLinger), <span class="built_in">timeoutMS_</span>(timeoutMS), <span class="built_in">isClose_</span>(<span class="literal">false</span>),</span><br><span class="line">	<span class="built_in">timer_</span>(<span class="keyword">new</span> <span class="built_in">HeapTimer</span>()), <span class="built_in">threadpool_</span>(<span class="keyword">new</span> <span class="built_in">ThreadPool</span>(threadNum)), <span class="built_in">epoller_</span>(<span class="keyword">new</span> <span class="built_in">Epoller</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// getcwd将当前工作目录的绝对路径复制到指定内存空间，如果传入的为NULL/nullptr，会动态分派，记得释放</span></span><br><span class="line">	srcDir_ = <span class="built_in">getcwd</span>(<span class="literal">nullptr</span>, <span class="number">256</span>);</span><br><span class="line">	<span class="built_in">assert</span>(srcDir_);</span><br><span class="line">	<span class="built_in">strncat</span>(srcDir_, <span class="string">&quot;/resources/&quot;</span>, <span class="number">16</span>);</span><br><span class="line">	HttpConn::useCount = <span class="number">0</span>;</span><br><span class="line">	HttpConn::srcDir = srcDir_;</span><br><span class="line">	<span class="comment">// 懒汉单例模式创建数据库连接池</span></span><br><span class="line">	SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>, sqlPort, sqlUser, sqlPwd, dbName, connPoolNum);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InitEventMode_</span>(trigMode);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">InitSocket_</span>()) &#123; isClose_ = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (openLog) &#123;</span><br><span class="line">		<span class="comment">// 单例模式创建日志队列</span></span><br><span class="line">		Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">init</span>(logLevel, <span class="string">&quot;./log&quot;</span>, <span class="string">&quot;.log&quot;</span>, logQueSize);</span><br><span class="line">		<span class="keyword">if</span> (isClose_) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;========== Server init ERROR! ==========&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server init ==========&quot;</span>);</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Port:%d, OpenLinger: %s&quot;</span>, port_, OptLinger ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Listen Mode: %s, OpenConn Mode: %s&quot;</span>,</span><br><span class="line">				(listenEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span> : <span class="string">&quot;LT&quot;</span>),</span><br><span class="line">				(connEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span> : <span class="string">&quot;LT&quot;</span>));</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;LogSys level: %d&quot;</span>, logLevel);</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;srcDir: %s&quot;</span>, HttpConn::srcDir);</span><br><span class="line">			<span class="built_in">LOG_INFO</span>(<span class="string">&quot;SqlConnPool num: %d, ThreadPool num: %d&quot;</span>, connPoolNum, threadNum)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>() &#123;</span><br><span class="line">	<span class="built_in">close</span>(listenFd_);</span><br><span class="line">	isClose_ = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 释放动态分配的srcDir_</span></span><br><span class="line">	<span class="built_in">free</span>(srcDir_);</span><br><span class="line">	SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// epoll_wait 的timeout为-1时无事件将阻塞</span></span><br><span class="line">	<span class="type">int</span> timeMS = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!isClose_) &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server start! ==========&quot;</span>); &#125;</span><br><span class="line">	<span class="comment">// 主线程</span></span><br><span class="line">	<span class="keyword">while</span> (!isClose_) &#123;</span><br><span class="line">		<span class="keyword">if</span> (timeoutMS_ &gt; <span class="number">0</span>)</span><br><span class="line">			timeMS = timer_-&gt;<span class="built_in">GetNextTick</span>();</span><br><span class="line">		<span class="type">int</span> eventCnt = epoller_-&gt;<span class="built_in">Wait</span>(timeMS);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCnt; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> fd = epoller_-&gt;<span class="built_in">GetEventFd</span>(i);</span><br><span class="line">			<span class="type">uint32_t</span> events = epoller_-&gt;<span class="built_in">GetEvents</span>(i);</span><br><span class="line">			<span class="comment">// 新连接进入</span></span><br><span class="line">			<span class="keyword">if</span> (fd == listenFd_) &#123;</span><br><span class="line">				<span class="built_in">DealListen_</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 连接失效的几种情况之一</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">				<span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">CloseConn_</span>(&amp;user_[fd]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 读</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="built_in">assert</span>(user_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">DealRead_</span>(&amp;user_[fd]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 写</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EPOLLOUT) &#123;</span><br><span class="line">				<span class="built_in">assert</span>(user_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">DealWrite_</span>(&amp;user_[fd]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Unexpected event!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建监听socket</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::InitSocket_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (port_ &gt; <span class="number">65535</span> || port_ &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Port:%d error!&quot;</span>, port_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建socket地址</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_int</span> addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	addr.sin_port = <span class="built_in">htons</span>(port_);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">linger</span> optLinger = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (openLinger_) &#123;</span><br><span class="line">		<span class="comment">// 优雅关闭：直到数据都处理完再关闭</span></span><br><span class="line">		openLinger.l_onoff = <span class="number">1</span>;</span><br><span class="line">		openLinger.l_linger = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建监听socket</span></span><br><span class="line">	listenFd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (listenFd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Create socket error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, <span class="built_in">sizeof</span>(openLinger));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">close</span>(listenFd_);</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Init linger error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 端口复用 只有最后一个套接字正常接收数据</span></span><br><span class="line">	ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;potval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;set socket setsockopt error !&quot;</span>);</span><br><span class="line">		<span class="built_in">close</span>(listenFd_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// bind</span></span><br><span class="line">	ret = <span class="built_in">bind</span>(listenFd_, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Bind Port:%d error!&quot;</span>, port_);</span><br><span class="line">		<span class="built_in">close</span>(listenFd_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// listen</span></span><br><span class="line">	ret = <span class="built_in">listen</span>(listenFd_, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Listen port:%d error!&quot;</span>, port_);</span><br><span class="line">		<span class="built_in">close</span>(listenFd_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册监听事件</span></span><br><span class="line">	ret = epoller_-&gt;<span class="built_in">AddFd</span>(listenFd_, listenEvent_ | EPOLLIN);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Add listen error!&quot;</span>);</span><br><span class="line">		<span class="built_in">close</span>(listenFd_);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SetFdNonblock</span>(listenFd_);</span><br><span class="line">	<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Server port:%d success!&quot;</span>, port_);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span> </span>&#123;</span><br><span class="line">	listenEvent_ = EPOLLRDHUP;</span><br><span class="line">	connEvent_ = EPOLLONESHOT | EPOLLRDHP;</span><br><span class="line">	<span class="keyword">switch</span> (trigMode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		connEvent_ |= EPOLLET;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		listenEvent_ |= EPOLLET;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		connEvent_ |= EPOLLET;</span><br><span class="line">		listenEvent_ |= EPOLLET;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		listenEvent_ |= EPOLLET;</span><br><span class="line">		connEvent_ |= EPOLLET;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HttpConn::isET = (connEvent_ &amp; EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::AddClient_</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr_in addr)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">	users_[fd].<span class="built_in">init</span>(fd, addr);</span><br><span class="line">	<span class="keyword">if</span> (timeoutMS_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		timer_-&gt;<span class="built_in">add</span>(fd, timeoutMS_, std::<span class="built_in">bind</span>(&amp;WebServer::CloseConn_, <span class="keyword">this</span>, &amp;user_[fd]));</span><br><span class="line">	&#125;</span><br><span class="line">	epoller_-&gt;<span class="built_in">AddFd</span>(fd, EPOLLIN | connEvent_);</span><br><span class="line">	<span class="built_in">SetFdNonblock</span>(fd);</span><br><span class="line">	<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] in!&quot;</span>, users_[fd].<span class="built_in">GetFd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealListen_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_int</span> addr;</span><br><span class="line">	<span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="type">int</span> fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr*)&amp;addr, len);</span><br><span class="line">		<span class="keyword">if</span> (fd &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (HttpConn::<span class="built_in">userCount</span>(fd) &gt;= MAX_FD) &#123;</span><br><span class="line">			<span class="built_in">SendError_</span>(fd, <span class="string">&quot;Server busy!&quot;</span>);</span><br><span class="line">			<span class="built_in">LOG_WARN</span>(<span class="string">&quot;Clients is full!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">AddClient_</span>(fd, addr);</span><br><span class="line">	&#125;<span class="keyword">while</span> (listenEvent_ &amp; EPOLLET)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(client);</span><br><span class="line">	<span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">	threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(client);</span><br><span class="line">	<span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">	threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>* info)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">send</span>(fd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG_WARN</span>(<span class="string">&quot;send error to client[%d] error!&quot;</span>, fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::ExtentTime_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(client);</span><br><span class="line">	<span class="keyword">if</span> (timeoutMS_ &gt; <span class="number">0</span>) &#123; timer_-&gt;<span class="built_in">adjust</span>(client-&gt;<span class="built_in">GetFd</span>(), timeoutMS_); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::CloseConn_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(client);</span><br><span class="line">	<span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] quit!&quot;</span>, client-&gt;<span class="built_in">GetFd</span>());</span><br><span class="line">	epoller_-&gt;<span class="built_in">DelFd</span>(client-&gt;<span class="built_in">GetFd</span>());</span><br><span class="line">	client-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(client);</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> readErrno = <span class="number">0</span>;</span><br><span class="line">	ret = client-&gt;<span class="built_in">read</span>(&amp;readErrno);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span> &amp;&amp; readErrno != EAGAIN) &#123;</span><br><span class="line">		<span class="built_in">CloseConn_</span>(client);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">OnProcess</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(client);</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> writeErrno = <span class="number">0</span>;</span><br><span class="line">	ret = client-&gt;<span class="built_in">write</span>(writeErrno);</span><br><span class="line">	<span class="comment">// 传输完毕</span></span><br><span class="line">	<span class="keyword">if</span> (client-&gt;<span class="built_in">ToWriteBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (client-&gt;<span class="built_in">isKeepAlive</span>()) &#123;</span><br><span class="line">			<span class="built_in">OnProcess</span>(client);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 继续传输</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (writeErrno == EAGAIN) &#123;</span><br><span class="line">			epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CloseConn_</span>(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnProcess</span><span class="params">(HttpConn* client)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (client-&gt;<span class="built_in">process</span>()) &#123;</span><br><span class="line">		epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLIN);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">WebServer::SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETFL, <span class="built_in">fcntl</span>(fd, F_GETFD, <span class="number">0</span>) | O_NONBLOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>至此，整个WebServer就完成啦！</strong></p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>TinyWebServer-总结</title>
    <url>/2023/07/10/TinyWebServer-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="从零实现自己的c-TinyWebServer-总结"><a href="#从零实现自己的c-TinyWebServer-总结" class="headerlink" title="从零实现自己的c++TinyWebServer-总结"></a>从零实现自己的c++TinyWebServer-总结</h1><h2 id="为什么要做这么一个项目？"><a href="#为什么要做这么一个项目？" class="headerlink" title="为什么要做这么一个项目？"></a>为什么要做这么一个项目？</h2><p>​    因为研究生阶段做的都是一些深度学习相关的知识，感觉自身对与后台开发知识有点薄弱，故此想学习一下有关后台开发的相关知识，同时还能巩固c++11的特性，操作系统、网络编程等知识点。</p>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>​    该项目设计的知识由Modern C++、网络编程、多线程编程、linux库函数等，参开了高性能服务器与Linux多线程服务器两本数据，以及一些开源代码进行开发，代码量约3000行。</p>
<h2 id="项目描述（重点）"><a href="#项目描述（重点）" class="headerlink" title="项目描述（重点）"></a>项目描述（重点）</h2><p>​    该项目的总体框架采用的是<strong>单Reactor多线程模型</strong>，在主线程中通过I&#x2F;O多路复用监听多个文件描述符上的事件。主线程负责连接的建立与断开，把读写和逻辑处理函数加入线程池的任务队列，由<strong>线程池</strong>中的子线程完成响应的读写操作，实现任务的高并发。在最底层实现了自动增长的<strong>Buffer缓冲区</strong>，在应用层方面实现心跳机制，通过<strong>定时器</strong>清理不活跃的连接以减少高并发场景下不必要的系统资源占用。对于<strong>HTTP请求报文</strong>，采用分散读进行读取，使用<strong>有限状态机</strong>对请求报文进行解析，并且通过集中写与内存映射的方法对<strong>响应报文</strong>进行传输，还实现了<strong>数据库</strong>功能，采用RAII机制实现数据库连接池，可以实现基本的注册登录功能。最后还加入了<strong>日志模块</strong>帮助项目开发和记录日常使用的情况。</p>
<h2 id="项目功能（重点）"><a href="#项目功能（重点）" class="headerlink" title="项目功能（重点）"></a>项目功能（重点）</h2><ul>
<li>利用I&#x2F;O多路复用技术epoll与线程池实现多线程Reactor的高并发模型</li>
<li>利用标准库容器vector实现了自动增长的Buffer缓冲区</li>
<li>基于小根堆与双向升序链表实现定时器，对不活跃的活动进行处理</li>
<li>使用有限状态机与正则表达式对请求报文进行解析，并发送响应报文</li>
<li>利用RAII机制实现了数据库连接池，实现了注册登录功能</li>
<li>利用懒汉单例模式与阻塞队列实现了异步的日志系统</li>
</ul>
<h2 id="项目流程（重点）"><a href="#项目流程（重点）" class="headerlink" title="项目流程（重点）"></a>项目流程（重点）</h2><ul>
<li><p>通过构造WevServer类的对象传递参数进行服务器参数相关的设定</p>
<p>  主要参数有：线程池数量、是否优雅关闭、触发模式、日志是否开启、日志的异步数量等</p>
</li>
<li><p>通过设定的参数对服务器的各个模块进行初始化</p>
<p>  主要有：日志、数据库连接池、线程池、HTTP对象、阻塞队列等</p>
</li>
<li><p>服务器各个模块初始化完毕后，主线程I&#x2F;O复用监听事件的循环</p>
<p>  监听是否有事件发生：</p>
<ul>
<li>新连接进入：初始化HTTP连接，添加读事件，设置非阻塞</li>
</ul>
<ol>
<li><p>读事件：调整定时器事件，读任务放进线程池，抢占式地执行；</p>
<p> 执行读事件最主要的是完成一个非阻塞读取调用知道读完，将数据缓存到用户缓冲区中，接着执行一个消息解析的操作，根据是否解析成功判断来决定是重新注册读事件还是写事件。解析成功就制作响应报文并注册写事件，如果解析失败则重新注册读事件并等待下次读取更多数据直到完成一个完整的HTTP请求</p>
</li>
</ol>
<ul>
<li>写事件</li>
<li>异常事件：关闭连接并移除监听事件和定时器</li>
</ul>
</li>
</ul>
<h2 id="HTTP请求报文的解析与HTTP响应报文的制作"><a href="#HTTP请求报文的解析与HTTP响应报文的制作" class="headerlink" title="HTTP请求报文的解析与HTTP响应报文的制作"></a>HTTP请求报文的解析与HTTP响应报文的制作</h2><p>​    解析采用的是有限状态机与正则表达式，每次都读取**’’\r\n’<strong>为结尾的一段字符串，通过状态机来判断获取的字符串属于哪一部分（请求行，请求报头，请求正文），再跳转到相应的函数进行解析，如果读取的字符串没有以’\r\n’结尾说明此次获取的数据不完整，返回解析失败并重新注册读事件，解析的时候判断是否有</strong>POST<strong>请求，如果是的话需要解析POST的数据，包含了登录注册的用户信息，这时通过数据库连接池去进行业务逻辑的判断，这部分的数据是在</strong>BODY<strong>部分，如果是</strong>GET**请求的话。那么BODY是空的。解析完成后根据解析过程中保存的相应信息，制作响应报文，通过集中写将资源文件和响应报文分别发送给客户端。</p>
<h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><p>​    日志模块的初始化是先建立一个日志文件，通过一个变量按照天数去划分不同的日志文件。线程池采用RAII手法，在构造时创建线程，折构时唤醒所有睡眠的线程使其退出循环。IO复用是对epoll函数调用的一个封装。HTTP对象主要设置文件存放的相关路径。缓冲区和阻塞队列主要完成指定大小的参数设定</p>
<h2 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h2><p>​    学习了基本的网络编程与多线程编程，并且对c++语法有了更新的了解，了解了常用的网络设计模式，并且对一个项目框架和模块的设计有了更深刻的理解。</p>
<h2 id="网络设计模式"><a href="#网络设计模式" class="headerlink" title="网络设计模式"></a>网络设计模式</h2><h3 id="简单的说一下服务器使用的并发模型"><a href="#简单的说一下服务器使用的并发模型" class="headerlink" title="简单的说一下服务器使用的并发模型"></a>简单的说一下服务器使用的并发模型</h3><p>​    该项目采用的是单Reactor多线程模型，主线程负责监听文件描述符上是否有事件发生，如果有则立刻通知工作线程，将socket可读可写事件放入请求队列，读写数据均在工作线程中完成。</p>
<h3 id="Reactor与Proactor的区别"><a href="#Reactor与Proactor的区别" class="headerlink" title="Reactor与Proactor的区别"></a>Reactor与Proactor的区别</h3><ul>
<li>Reactor采用的是同步IO，多路复用监听事件，然后根据事件类型进行任务分发，让线程池处理。</li>
<li>Proactor采用的是异步IO，主线程只负责发起I&#x2F;O操作，真正的IO实现由操作系统处理</li>
</ul>
<p><strong>无论是Reactor和Proactor都是基于事件分发的网络编程模式，区别在于Reactor是基于待完成的IO事件，Proactor是基于已完成的IO事件</strong></p>
<h3 id="同步IO与异步IO的区别"><a href="#同步IO与异步IO的区别" class="headerlink" title="同步IO与异步IO的区别"></a>同步IO与异步IO的区别</h3><p>​    核心区别就是内核通知给用户空间的是就绪态还是完成态。</p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
  </entry>
  <entry>
    <title>小红书c++实习一面</title>
    <url>/2023/07/14/%E5%B0%8F%E7%BA%A2%E4%B9%A6c-%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="2023-07-14小红书c-一面"><a href="#2023-07-14小红书c-一面" class="headerlink" title="2023.07.14小红书c++一面"></a>2023.07.14小红书c++一面</h1><p>小红书c++实习生(特效生产工具方向)一面</p>
<p>面试官很和蔼，全程没问项目，大约45分钟，代码题做了20min没做出来被狠狠的拷打</p>
<ol>
<li>自我介绍</li>
<li>什么是指针</li>
<li>指针与引用的区别</li>
<li>了解智能指针么</li>
<li>malloc与new的区别</li>
<li>一个类构造的过程（这个题没理解）</li>
<li>多态是什么</li>
<li>c和c++中的存储区域</li>
<li>了解AVL么</li>
<li>图是什么</li>
<li>广度优先与深度优先</li>
</ol>
<p>代码题：给定一个Q点(x2,y2)和P点(x1,y1)，求P点绕Q点顺时针旋转45度后的坐标位置。</p>
<p>​    没做出来，面试官说可以直接用三角函数硬推或者使用坐标运算之类的，后来看了一下用三角函数就行，自己不了解了属于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> x1, x2, y1, y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    逆时针的绕原点旋转为：</span></span><br><span class="line"><span class="comment">    x= x1 * cos(θ) - y1 * sin(θ)</span></span><br><span class="line"><span class="comment">    y= x1 * sin(θ) + y1 * cos(θ)</span></span><br><span class="line"><span class="comment">    逆时针绕点x2y2旋转为：</span></span><br><span class="line"><span class="comment">    x= (x1 - x2)*cos(θ) - (y1 - y2)*sin(θ) + x2</span></span><br><span class="line"><span class="comment">    y= (x1 - x2)*sin(θ) + (y1 - y2)*cos(θ) + y2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    x = (x1 - x2)*<span class="built_in">cos</span>(<span class="number">315</span>) - (y1-y2)*<span class="built_in">sin</span>(<span class="number">315</span>) + x2;</span><br><span class="line">    y = (x1 - x2)*<span class="built_in">sin</span>(<span class="number">315</span>) + (y1-y2)*<span class="built_in">cos</span>(<span class="number">315</span>) + y2;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反问：</p>
<ol>
<li>部门做的业务大概是什么</li>
<li>还有什么需要改进的；面试官比较注重基础，说是项目的话主要其实会问一些实习进行的工作，像在学校自己弄得项目来说他觉得大家肯定都理解的差不多了</li>
</ol>
<p>​    个人感觉：问的都比较基础，自己答得感觉一般般，虽然感觉是kpi面哈哈，就招一个人，也不知道会不会有二面，继续努力吧！</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
  <entry>
    <title>秋招知识点补充</title>
    <url>/2023/08/10/%E7%A7%8B%E6%8B%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="秋招知识点补充"><a href="#秋招知识点补充" class="headerlink" title="秋招知识点补充"></a>秋招知识点补充</h1><p>对秋招过程中发现的问题与学习的新知识进行总结！</p>
<h3 id="端口号是什么？"><a href="#端口号是什么？" class="headerlink" title="端口号是什么？"></a>端口号是什么？</h3><p>​    端口号可以用来标识同一个主机上通信的不同应用程序，端口号+ip就可以组成一个套接字，用来标识一个进程：</p>
<ul>
<li>0-1023：知名端号，一般用于协议</li>
<li>1024-65535：操作系统动态分派的端口号</li>
</ul>
<p>​    在linux中通过 <code>cat /etc/services</code> 来查看知名端口号。</p>
<h3 id="一个进程可以bind多个端口号么？"><a href="#一个进程可以bind多个端口号么？" class="headerlink" title="一个进程可以bind多个端口号么？"></a>一个进程可以bind多个端口号么？</h3><p>​    可以。因为一个进程可以打开多个文件描述符，而每个文件描述符都对应一个端口号</p>
<h3 id="一个端口可以绑定多个进程么？"><a href="#一个端口可以绑定多个进程么？" class="headerlink" title="一个端口可以绑定多个进程么？"></a>一个端口可以绑定多个进程么？</h3><p>​    通常情况下是不可以的，但有一种情况可以：如果父进程先绑定一个端口号，然后fork一个子进程，那么这样的话子进程是可以绑定父进程的端口号，但是同时只能有一个进程执行bind；在支持SO_REUSEPORT的内核中，支持同uid的进程绑定同一个端口号，多个进程可以随便bind函数绑定同一个端口；在支持SO_REUSEADDR的内核中允许重复绑定，但是只用于UDP的多播。</p>
<h3 id="SO-REUSEADDR的作用"><a href="#SO-REUSEADDR的作用" class="headerlink" title="SO_REUSEADDR的作用"></a>SO_REUSEADDR的作用</h3><p>以下内容摘自《Unix网络编程》卷一，即UNPv1</p>
<ul>
<li>当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。（这个是tcp专用的）</li>
<li>SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。</li>
<li>SO_REUSEADDR允许单个进程绑定相同的端口到多个<a href="https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020">socket</a>上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。（这里我在linux下试验了，下，要求一个的ip不能是0.0.0.0）</li>
<li>SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li>
</ul>
<h3 id="大端存储与小端存储"><a href="#大端存储与小端存储" class="headerlink" title="大端存储与小端存储"></a>大端存储与小端存储</h3><p>​    大端和小端是两种不同的字节序，本质的区别就是高字节与低字节的存储顺序不同。大端字节序为高字节在低地址，低字节在高地址；而小端字节序为高字节在高地址，低字节在低地址；取决于计算机的硬件。</p>
<p>​    可以通过联合体或强转来判断计算机的存储方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span> s;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> (un.c == <span class="number">0x01</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (un.c == <span class="number">0x02</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Littile Endian\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么不淘汰select呐？"><a href="#为什么不淘汰select呐？" class="headerlink" title="为什么不淘汰select呐？"></a>为什么不淘汰select呐？</h3><ol>
<li>可移植性：select在每个支持网络和非阻塞套接字的平台都会支持select，但是他可能不支持poll</li>
<li>select的超时时间理论上可以精确到纳秒，而poll和epoll的精度只有微秒，对于桌面或者服务器系统来说没什么区别，但是对于某些硬件嵌入式平台来说还可能是需要这种量级的。</li>
</ol>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><ul>
<li>纯虚函数是指在一个基类中只声明而没有定义的虚函数，要求子类必须对其进行重写，可以使用纯虚函数来模拟实现接口</li>
<li>一个具有纯虚函数的类被称为抽象类<ol>
<li>抽象类对象不能做函数参数，不能创建对象，不能作为函数返回类型</li>
<li>可以声明抽象类指针与抽象类引用</li>
<li>子类必须重写父类的纯虚函数才能创建对象</li>
</ol>
</li>
</ul>
<h3 id="什么函数不能被声明为虚函数"><a href="#什么函数不能被声明为虚函数" class="headerlink" title="什么函数不能被声明为虚函数"></a>什么函数不能被声明为虚函数</h3><ol>
<li>非类的成员函数：虚函数是依托类的，脱离类是不存在虚函数的</li>
<li>构造函数：虚函数指针是在构造函数中初始化的，如果构造函数为虚函数则创建不了虚函数指针，互相矛盾</li>
<li>内联函数：内敛函数为静态编译，是在编译期间直接展开的，而虚函数本意是动态编译，是在运行时期进行编译确定，二者冲突</li>
<li>静态函数：静态函数的调用无法传递传递this指针，但是虚函数的调用需要调用this指针，来找到虚函数表，互相矛盾</li>
<li>友元函数：C++不支持友元函数的继承，不能继承的函数肯定不是虚函数</li>
</ol>
<h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><ol>
<li>先来先服务算法：每次调度都是从后备线程队列中选取一个或多个最先进入队列的进程，将他们调入内存，为他们分配资源并创建进程，加入就绪队列；当前正在运行的进程停止运行时，选择在就绪队列中存在时间最长的进程执行</li>
<li>短作业优先：从后备队列选择一个或多个估计运行时间最短的进程，调入内存中并加入就绪队列，等待执行</li>
<li>优先级调度算法：优先级用于描述进程运行的紧迫程度，每次选择优先级最高的进程</li>
<li>高响应比优先调度算法：主要用于作业调度，为平衡短作业优先与优先级调度的一种调度算法，考虑每个作业的等待时间和估计运行时间，每次调度时，计算后配作业队列中每个作业的响应比，选取响应比最高的作业</li>
<li>时间片轮转调度算法：主要适用于分时系统，每次调度时，把CPU分配给队首进程并令其执行一个时间片，执行的时间片用完时发出中断，把它送往队列末尾，然后再重新分配时间片给新的队首</li>
<li>多级反馈队列调度算法：为时间片与优先调度算法的综合，动态调正进程优先级与时间片大小</li>
</ol>
<h3 id="物理内存与虚拟内存"><a href="#物理内存与虚拟内存" class="headerlink" title="物理内存与虚拟内存"></a>物理内存与虚拟内存</h3><ul>
<li>物理内存：在没有虚拟内存时，寻址都是找物理内存，<strong>范围有限</strong>，比如32位平台下，每创建一个进程就给4G物理内存，内存很快就不够用了；并且由于指令都是访问物理内存，那么任何进程都可以直接修改其他进程的数据，<strong>隔离性差</strong>。</li>
<li>虚拟内存：为了让物理内存扩充更大的逻辑内存，使其使用的空间更多，在需要的时候映射到物理内存，变相扩大了物理内存；并且每个进程都有自己的页表，每个进程相互独立，更加安全。</li>
</ul>
<h3 id="段表与页表"><a href="#段表与页表" class="headerlink" title="段表与页表"></a>段表与页表</h3><ul>
<li>分段主要为了解决内存独立&#x2F;隔离，有利于共享和保护</li>
<li>分页与物理内存映射，实现虚拟内存，获得更大的地址空间</li>
</ul>
<p>​    系统为每个进程都会建立一张的段表，每个分段都有一张页表：</p>
<ul>
<li>段表包括至少：段号、页表长度、页表地址</li>
<li>页表包括至少：页号、块号</li>
</ul>
<p>​    在进行地址转换时，首先通过段表查到页表地址，然后通过页表找到页帧号，最终形成物理地址。</p>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul>
<li>HTTP基于TCP，端口号位为80，传输的数据都是明文传输，握手阶段速度约1RTT，几乎没有安全性</li>
<li>HTTPS是HTTP+TLS&#x2F;SSL，端口号为443，在建立连接时会有一种证书文件而不是响应报文，此时客户端验证证书并创建密钥，随后与服务端的动心都是使用密钥加密的，几乎无法破解，整个耗时为3RTT</li>
</ul>
<h3 id="TCP粘包问题"><a href="#TCP粘包问题" class="headerlink" title="TCP粘包问题"></a>TCP粘包问题</h3><p>​    在多个数据包连续发送的情况下，对数据包进行读取时无法判断发生方的发送边界，而采用某一估测值大小来进行数据读取，若发送方的数据包长度与接收方在缓存中读取的数据包长度不一致，就会发生粘包，发送端堆积了两次数据。比如发送方一次发送了100字节的数据，在接收方堆叠了两次既200字节的数据，接收方一次读取120字节的数据，这样在一次读取就会包括下一个报文段的头部，从而造成粘包。</p>
<p>​    造成的本质其实是TCP并不维护数据边界，解决粘包的方法如下：</p>
<ul>
<li>发送方关闭Nagle算法，Nagle算法主要是避免发送小的数据包，要求TCP连接上最多只能由一个未被确认的小组，在该分组的确认达到之前不能发送其他的小分组</li>
<li>发送定长的数据包，这样接收方更容易区分数据包的边界</li>
<li>数据包末尾加上\r\n标记，模拟FTP协议，但是如果正文中包含\r\n的话，会被误判为消息的边界</li>
<li>数据包头部加上数据包长度</li>
<li>应用层自定义规则</li>
</ul>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
  </entry>
  <entry>
    <title>中移苏小研C++一面</title>
    <url>/2023/09/20/%E4%B8%AD%E7%A7%BB%E8%8B%8F%E5%B0%8F%E7%A0%94C-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="中移苏小研C-x2F-C-一面"><a href="#中移苏小研C-x2F-C-一面" class="headerlink" title="中移苏小研C&#x2F;C++一面"></a>中移苏小研C&#x2F;C++一面</h1><p>盲面，提前打电话通知你的序号，全程不能提名字，两个面试官</p>
<ol>
<li><p>自我介绍</p>
</li>
<li><p>介绍一下c++的项目</p>
</li>
<li><p>线程池的具体实现</p>
</li>
<li><p>select了解么</p>
</li>
<li><p>select监听上限为什么是1024，可以通过修改代码或者内核来修改么(不会)</p>
</li>
<li><p>我看你线程池用的epoll，介绍一下</p>
</li>
<li><p>ET与LT的区别</p>
</li>
<li><p>vector和list的区别</p>
</li>
<li><p>介绍一下多态</p>
</li>
<li><p>TCP与UDP的区别与应用场景</p>
</li>
<li><p>三次握手</p>
</li>
<li><p>如果第一次握手没有被服务端接收到会发生什么(答错了感觉)</p>
</li>
<li><p>为什么需要第三次握手</p>
</li>
<li><p>四次挥手</p>
</li>
<li><p>为什么需要第四次挥手</p>
</li>
<li><p>惊群效应怎么产生的</p>
</li>
</ol>
<p>反问了几个问题<br>最后问了下我相同条件下成都和苏州你会选择哪个地方😂(当时条了意向城市为成都和苏州，自己给自己挖坑)</p>
<p>感觉问的很基础，面试官人也挺好的，不会的也会给你简单解答一下，一周左右有通知</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
  </entry>
</search>
